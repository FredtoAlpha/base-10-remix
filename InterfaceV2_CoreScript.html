<script>
// Scripts principaux extraits de InterfaceV2.html pour am√©liorer la lisibilit√©.
// =======================================================
// FONCTIONS UTILITAIRES GLOBALES (accessibles partout)
// =======================================================

// üîß PROTECTION REALTIME FEEDBACK
window.RealTimeFeedback = window.RealTimeFeedback || null;


// ========== BARRE DE PROGRESSION SAUVEGARDE ==========
class SaveProgressManager {
  constructor() {
    this.progressBar = null;
    this.progressFill = null;
    this.progressPercentage = null;
    this.currentSave = null;
    this.init();
  }
  
  init() {
    // Cr√©er la barre de progression dynamiquement
    const progressHTML = `
      <div id="saveProgressBar" class="save-progress-bar">
        <div class="save-progress-header">
          <span><i class="fas fa-save mr-2"></i>Cr√©ation des onglets FIN...</span>
          <button id="minimizeProgress" class="text-white hover:text-yellow-200 transition-colors">
            <i class="fas fa-minus"></i>
          </button>
        </div>
        <div class="save-progress-content">
          <div class="progress-bar-container">
            <div id="progressBarFill" class="progress-bar-fill"></div>
          </div>
          <div id="progressPercentage" class="text-center text-sm font-semibold text-gray-700">0%</div>
          <div class="progress-steps">
            <div id="step1" class="progress-step">
              <i class="fas fa-circle-notch"></i>
              <span>Pr√©paration des donn√©es...</span>
            </div>
            <div id="step2" class="progress-step">
              <i class="fas fa-circle-notch"></i>
              <span>Validation LV2 obligatoire...</span>
            </div>
            <div id="step3" class="progress-step">
              <i class="fas fa-circle-notch"></i>
              <span>Cr√©ation onglets FIN...</span>
            </div>
            <div id="step4" class="progress-step">
              <i class="fas fa-circle-notch"></i>
              <span>Formatage automatique...</span>
            </div>
            <div id="step5" class="progress-step">
              <i class="fas fa-circle-notch"></i>
              <span>Finalisation...</span>
            </div>
          </div>
        </div>
      </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', progressHTML);
    
    this.progressBar = document.getElementById('saveProgressBar');
    this.progressFill = document.getElementById('progressBarFill');
    this.progressPercentage = document.getElementById('progressPercentage');
    
    this.setupEventListeners();
  }
  
  setupEventListeners() {
    const minimizeBtn = document.getElementById('minimizeProgress');
    if (minimizeBtn) {
      minimizeBtn.addEventListener('click', () => this.toggleMinimize());
    }
  }
  
  start() {
    if (this.currentSave) {
      toast('Une sauvegarde est d√©j√† en cours...', 'warning');
      return false;
    }
    this.currentSave = Date.now();
    this.show();
    this.updateProgress(0, 'step1');
    return true;
  }
  
  show() {
    if (this.progressBar) {
      this.progressBar.classList.add('show');
    }
  }
  
  hide() {
    if (this.progressBar) {
      this.progressBar.classList.remove('show');
    }
    this.currentSave = null;
    setTimeout(() => this.reset(), 300);
  }
  
  updateProgress(percentage, activeStep) {
    if (this.progressFill) {
      this.progressFill.style.width = percentage + '%';
    }
    if (this.progressPercentage) {
      this.progressPercentage.textContent = Math.round(percentage) + '%';
    }
    
    const steps = ['step1', 'step2', 'step3', 'step4', 'step5'];
    const activeIndex = steps.indexOf(activeStep);
    
    steps.forEach((stepId, index) => {
      const stepElement = document.getElementById(stepId);
      if (!stepElement) return;
      
      const icon = stepElement.querySelector('i');
      if (index < activeIndex) {
        stepElement.className = 'progress-step completed';
        icon.className = 'fas fa-check-circle';
      } else if (index === activeIndex) {
        stepElement.className = 'progress-step active';
        icon.className = 'fas fa-spinner';
      } else {
        stepElement.className = 'progress-step';
        icon.className = 'fas fa-circle-notch';
      }
    });
  }
  
  complete(success = true) {
    if (success) {
      this.updateProgress(100, 'step5');
      ['step1', 'step2', 'step3', 'step4', 'step5'].forEach(stepId => {
        const stepElement = document.getElementById(stepId);
        if (stepElement) {
          stepElement.className = 'progress-step completed';
          stepElement.querySelector('i').className = 'fas fa-check-circle';
        }
      });
      
      const header = this.progressBar?.querySelector('.save-progress-header span');
      if (header) {
        header.innerHTML = '<i class="fas fa-check mr-2"></i>Onglets INT cr√©√©s et format√©s !';
      }
      setTimeout(() => this.hide(), 2000);
    } else {
      const header = this.progressBar?.querySelector('.save-progress-header span');
      if (header) {
        header.innerHTML = '<i class="fas fa-exclamation-triangle mr-2"></i>Erreur cr√©ation INT';
        header.parentElement.style.background = 'linear-gradient(135deg, #dc2626 0%, #b91c1c 100%)';
      }
      setTimeout(() => this.hide(), 3000);
    }
  }
  
  reset() {
    this.updateProgress(0, 'step1');
    const header = this.progressBar?.querySelector('.save-progress-header span');
    if (header) {
      header.innerHTML = '<i class="fas fa-save mr-2"></i>Cr√©ation des onglets FIN...';
      header.parentElement.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
    }
  }
  
  toggleMinimize() {
    // Impl√©mentation simple du toggle
    const content = this.progressBar?.querySelector('.save-progress-content');
    if (content) {
      content.style.display = content.style.display === 'none' ? 'block' : 'none';
    }
  }
}

// Initialiser le gestionnaire
window.saveProgressManager = new SaveProgressManager();

// Fonction de sauvegarde avec barre de progression
async function saveWithProgressINT() {
  if (!window.saveProgressManager.start()) return;
  
  try {
    // √âtape 1 : Pr√©paration (25%)
    window.saveProgressManager.updateProgress(25, 'step1');
    await new Promise(resolve => setTimeout(resolve, 500));
    
    const disposition = exportDisposition();
    if (Object.keys(disposition).length === 0) {
      throw new Error('Aucune classe √† sauvegarder');
    }
    
    // √âtape 2 : Validation LV2 (50%)
    window.saveProgressManager.updateProgress(50, 'step2');
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // √âtape 3 : Cr√©ation des onglets FIN (75%)
    window.saveProgressManager.updateProgress(75, 'step3');

    // Sauvegarder depuis le mode actuellement actif (sources/test/def/CACHE)
    const result = await gsRun('saveElevesSnapshot', disposition, STATE.currentMode);
    if (!result?.success) {
      throw new Error(result?.error || 'Erreur serveur');
    }
    
    // √âtape 4 : Formatage automatique (90%)
    window.saveProgressManager.updateProgress(90, 'step4');
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // √âtape 5 : Finalisation (100%)
    window.saveProgressManager.updateProgress(100, 'step5');
    await new Promise(resolve => setTimeout(resolve, 200));
    
    window.saveProgressManager.complete(true);
    toast(`Onglets INT cr√©√©s et format√©s avec succ√®s pour ${Object.keys(disposition).length} classes`, 'success');
    
  } catch (error) {
    console.error('Erreur cr√©ation onglets FIN:', error);
    window.saveProgressManager.complete(false);
    toast('Erreur: ' + error.message, 'error');
  }
}

// ========== ANCIENNES FONCTIONS MIGR√âES VERS App.* ==========
// Les fonctions suivantes ont √©t√© d√©plac√©es vers l'architecture modulaire :
// - toast() -> App.UI.toast()
// - adjustSimpleNamesFontSize() -> App.UI.adjustSimpleNamesFontSize()
// - isRealClass() -> App.Utils.isRealClass()
// - updateColumnStats() -> App.UI.updateColumnStats()
// - updateAllColumnStats() -> App.UI.updateAllColumnStats()
// - updateAdvancedStats() -> App.Stats.updateAdvancedStats()
// - exportDisposition() -> App.Data.exportDisposition()
// - saveImmediateCache() -> App.Data.saveImmediateCache()
// - updateUndoRedoButtons() -> App.History.updateUndoRedoButtons()
//
// Des wrappers globaux sont disponibles pour compatibilit√© (voir section WRAPPERS ci-dessous)
// undo() et redo() migr√©s vers App.History

// ========== APPELS GOOGLE APPS SCRIPT ==========
function gsRun(fnName, ...args) {
  return new Promise((resolve, reject) => {
    console.log(`üì° Appel fonction: ${fnName}`);

    try {
      // V√©rifier si on est dans l'environnement Google Apps Script
      if (typeof google !== 'undefined' && google.script && google.script.run) {
        const api = google.script.run;

        if (typeof api[fnName] === 'function') {
          // Appel correct : d'abord les handlers, puis la fonction
          api
            .withSuccessHandler((result) => {
              console.log(`‚úÖ ${fnName} succ√®s:`, result);
              resolve(result);
            })
            .withFailureHandler((error) => {
              console.error(`‚ùå ${fnName} erreur:`, error);
              reject(error);
            })[fnName](...args);
          return;
        }
        // ‚úÖ Fonction non disponible
        reject(new Error(`Fonction ${fnName} non disponible dans google.script.run`));
        return;
      }

      // ‚úÖ Google Apps Script non disponible
      reject(new Error('Google Apps Script non disponible. Assurez-vous que l\'application est d√©ploy√©e.'));

    } catch (error) {
      console.error(`üí• Erreur dans gsRun:`, error);
      reject(error);
    }
  });
}

// ========== FONCTION AFFICHAGE D'ERREUR UNIVERSELLE ==========
function showErrorState(message, suggestions = []) {
  const board = document.getElementById('board');
  if (!board) {
    console.error('√âl√©ment #board introuvable');
    return;
  }
  
  const defaultSuggestions = [
    'V√©rifiez que vos onglets se terminent par "TEST" (ex: 4¬∞1TEST, 4¬∞2TEST...)',
    'Assurez-vous que vos onglets contiennent des donn√©es avec au moins les colonnes ID et NOM',
    'Cr√©ez un onglet "_STRUCTURE" avec les r√®gles de r√©partition',
    'V√©rifiez la configuration de votre Google Sheet'
  ];
  
  const allSuggestions = suggestions.length > 0 ? suggestions : defaultSuggestions;
  
  board.innerHTML = `
    <div class="col-span-full">
      <div class="error-container">
        <div class="error-icon">
          <i class="fas fa-exclamation-triangle"></i>
        </div>
        <h2 class="error-title">Aucune donn√©e trouv√©e</h2>
        <div class="error-message">
          ${message}
        </div>
        <div class="error-suggestions">
          <h3 class="font-semibold mb-2">Suggestions pour r√©soudre le probl√®me :</h3>
          <ul>
            ${allSuggestions.map(s => `<li>${s}</li>`).join('')}
          </ul>
        </div>
        <div class="mt-4">
          <button onclick="attemptRefresh()" class="btn btn-primary">
            <i class="fas fa-sync"></i> R√©essayer
          </button>
          <button onclick="createDemoStructure()" class="btn btn-secondary ml-3">
            <i class="fas fa-plus"></i> Cr√©er structure exemple
          </button>
        </div>
      </div>
    </div>
  `;
}

// ========== D√âTECTION AUTOMATIQUE DU NIVEAU ==========
function detectNiveau(data) {
  if (!data || data.length === 0) return '';
  
  // Analyser les noms de classes pour d√©tecter le niveau
  const classes = data.map(group => group.classe);
  const niveaux = new Set();
  
  classes.forEach(classe => {
    const match = classe.match(/^(\d¬∞)/);
    if (match) {
      niveaux.add(match[1]);
    }
  });
  
  if (niveaux.size === 1) {
    return Array.from(niveaux)[0];
  } else if (niveaux.size > 1) {
    return `Multi-niveaux (${Array.from(niveaux).join(', ')})`;
  }
  
  return 'Niveau non d√©tect√©';
}

// ========== FONCTION DE TRI DES COLONNES ==========
function sortColumn(classe, sortType, direction = 'asc') {
  const dropZone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
  if (!dropZone) return;

  const cards = Array.from(dropZone.querySelectorAll('.student-card'));
  const students = cards.map(card => ({
    card,
    data: STATE.students[card.dataset.id]
  }));

  // facteur : +1 en asc, -1 en desc
  const f = direction === 'asc' ? 1 : -1;

  switch (sortType) {
    /* --- NOM ------------------------------------------------------- */
    case 'name':
      students.sort((a, b) => f * a.data.nom.localeCompare(b.data.nom));
      break;

    /* --- LV2 ------------------------------------------------------- */
    case 'lv2':
      students.sort((a, b) => {
        const ordre = ['ESP', 'ITA', 'ALL', 'LATIN', 'GRECO'];
        const iA = ordre.indexOf((a.data.lv2 || '').toUpperCase());
        const iB = ordre.indexOf((b.data.lv2 || '').toUpperCase());
        return f * ((iA === -1 ? 999 : iA) - (iB === -1 ? 999 : iB));
      });
      break;

    /* --- OPTION ---------------------------------------------------- */
    case 'option':
      students.sort((a, b) => {
        if (!a.data.opt && !b.data.opt) return 0;
        if (!a.data.opt) return  f;   // ¬´ sans option ¬ª en bas quand asc
        if (!b.data.opt) return -f;
        return f * a.data.opt.localeCompare(b.data.opt);
      });
      break;

    /* --- SCORE COM ---------------------------------------------- */
    case 'score':
      students.sort((a, b) => {
        // Tri par score COM : meilleurs (4=Vert) en haut au premier clic
        const scoreA = a.data.scores.COM || 0;
        const scoreB = b.data.scores.COM || 0;
        return -f * (scoreB - scoreA); // meilleurs en haut en asc
      });
      break;
  }

  /* r√©-injection dans le DOM */
  dropZone.innerHTML = '';
  students.forEach(({ card }) => dropZone.appendChild(card));

  /* m√©morise le dernier tri */
  STATE.sortOrder[classe] = { type: sortType, dir: direction };
}

// ========== FONCTION DE VALIDATION DES MOUVEMENTS ==========
function canMove(eleveId, srcClasse, dstClasse) {
  if (STATE.adminMode || srcClasse === dstClasse) return { ok: true };

  const e = STATE.students[eleveId];
  const dr = STATE.rules[dstClasse] || {};
  const dc = getCurrentClassContent(dstClasse);

  /* üîí FIXE : jamais de d√©placement */
  if (e.mobilite === 'FIXE')
    return { ok:false, reason:`${e.nom} est FIXE dans sa classe` };

  /* üîí CONDI : jamais de d√©placement individuel (conditionn√© par le groupe) */
  if (e.mobilite === 'CONDI')
    return { ok:false, reason:`${e.nom} est CONDI (groupe A${e.asso}) - utilisez le mode Admin` };

  /* üîí PERMUT : BLOQU√â EN DRAG&DROP NORMAL */
  if (e.mobilite === 'PERMUT')
    return { ok:false, reason:`${e.nom} est PERMUT - utilisez le mode SWAP` };

    /* üîí SPEC : m√™me r√®gle que FIXE  (option prioritaire) */
if (e.mobilite === 'SPEC')
  return { ok:false, reason:`${e.nom} est SPEC (option obligatoire)` };

  /* üîí DISSOCIATION : V√©rifier si code D d√©j√† pr√©sent dans la classe cible */
  if (e.disso) {
    // V√©rifier si un autre √©l√®ve avec le m√™me code D est d√©j√† dans la classe cible
    const dissoDejaPresent = dc.some(id => {
      const s = STATE.students[id];
      return s && s.disso === e.disso;
    });
    
    if (dissoDejaPresent) {
      return { ok:false, reason:`Code D${e.disso} d√©j√† pr√©sent dans ${dstClasse} - utilisez le mode SWAP` };
    }
    // Sinon, autoriser le d√©placement (pas de conflit)
  }

  /* CAPACIT√â : on avertit mais on autorise */
  if (dr.capacity && dc.length >= dr.capacity) {
    return {
      ok: true,
      warn: `${dstClasse} d√©passe sa capacit√© (${dr.capacity})`
    };
  }

  /* ASSOCIATION */
  if (e.asso) {
    const grp = STATE.aGroups[`A${e.asso}`] || [];
    const encSrc = grp.filter(id => id !== eleveId)
                      .some(id => document.querySelector(`.student-card[data-id="${id}"]`)
                                   ?.closest('.droppable-zone').dataset.classe === srcClasse);
    if (encSrc)
      return { ok:false, reason:`Groupe A${e.asso} doit bouger ensemble (mode Swap ou Admin)` };
  }

  /* V√âRIFIER LV2 et OPTIONS */
  const checkTag = (tag, label) => {
    const tagUp = String(tag || '').trim().toUpperCase();
    if (!tagUp) return true;

    /* LV2 ESP autoris√© partout */
    if (label === 'LV2' && tagUp === 'ESP') return true;

    /* Aucune r√®gle pour la classe ‚ûú tout interdit */
    if (!dr.quotas || Object.keys(dr.quotas).length === 0) {
      return { ok:false, reason:`${label} ${tagUp} interdit dans ${dstClasse} (aucun quota d√©fini)` };
    }

    /* Tag absent dans les quotas ‚ûú interdit */
    if (!(tagUp in dr.quotas)) {
      return { ok:false, reason:`${label} ${tagUp} interdit dans ${dstClasse}` };
    }

    /* Quota √† 0 ‚ûú interdit */
    if (dr.quotas[tagUp] === 0) {
      return { ok:false, reason:`${label} ${tagUp} interdit dans ${dstClasse} (quota 0)` };
    }

    /* √âl√®ves d√©j√† pr√©sents avec ce tag */
    const currentCnt = dc.filter(id => {
      const s = STATE.students[id];
      return s && (String(s.lv2).toUpperCase() === tagUp ||
                   String(s.opt).toUpperCase() === tagUp);
    }).length;

    if (currentCnt >= dr.quotas[tagUp]) {
      return { ok:false, reason:`Quota ${tagUp} atteint (${dr.quotas[tagUp]})` };
    }

    return true;
  };

  const r1 = checkTag(e.lv2, 'LV2');
  if (r1 !== true) return r1;
  console.log(eleveId, e.opt)
  const r2 = checkTag(e.opt, 'Option');
  if (r2 !== true) return r2;

  return { ok:true };
}

// ========== FONCTION UTILITAIRE POUR R√âCUP√âRER LE CONTENU D'UNE CLASSE ==========
function getCurrentClassContent(classe) {
  const dropZone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
  if (!dropZone) return [];
  
  return Array.from(dropZone.querySelectorAll('.student-card'))
    .map(card => card.dataset.id);
}

// ========== FONCTIONS DE GESTION DES SWAPS ==========
function canSwap(id1, id2) {
  const card1 = document.querySelector(`.student-card[data-id="${id1}"]`);
  const card2 = document.querySelector(`.student-card[data-id="${id2}"]`);
  
  if (!card1 || !card2) return { ok: false, reason: '√âl√®ve introuvable' };
  
  const classe1 = card1.closest('.droppable-zone').dataset.classe;
  const classe2 = card2.closest('.droppable-zone').dataset.classe;
  
  if (classe1 === classe2) return { ok: false, reason: 'M√™me classe' };
  
  const eleve1 = STATE.students[id1];
  const eleve2 = STATE.students[id2];
  
  // Mode admin : tout est permis
  if (STATE.adminMode) return { ok: true };
  
  // ‚úÖ PRIORIT√â 1 : SWAP DE M√äME CONTRAINTE
  // Si les deux √©l√®ves ont les m√™mes contraintes (LV2, OPT, code D), le swap est autoris√©
  // Car cela ne change pas les quotas : on √©change juste deux √©l√®ves identiques
  
  const lv2_1 = (eleve1.lv2 || '').toUpperCase();
  const lv2_2 = (eleve2.lv2 || '').toUpperCase();
  const opt_1 = (eleve1.opt || '').toUpperCase();
  const opt_2 = (eleve2.opt || '').toUpperCase();
  
  // Cas 1 : M√™me code D (dissociation)
  if (eleve1.disso && eleve2.disso && eleve1.disso === eleve2.disso) {
    console.log(`‚úÖ Swap autoris√©: ${eleve1.nom} ‚Üî ${eleve2.nom} (m√™me code D${eleve1.disso})`);
    return { ok: true };
  }
  
  // Cas 2 : M√™me LV2 ET m√™me OPT (ou pas d'OPT)
  const memeLV2 = lv2_1 === lv2_2 || (lv2_1 === 'ESP' && lv2_2 === 'ESP') || (!lv2_1 && !lv2_2);
  const memeOPT = opt_1 === opt_2 || (!opt_1 && !opt_2);
  
  if (memeLV2 && memeOPT) {
    console.log(`‚úÖ Swap autoris√©: ${eleve1.nom} ‚Üî ${eleve2.nom} (m√™mes contraintes: LV2=${lv2_1 || 'aucune'}, OPT=${opt_1 || 'aucune'})`);
    return { ok: true };
  }
  
  // Si pas de m√™mes contraintes, v√©rifier les mobilit√©s
  
  // FIXE et SPEC : jamais d√©pla√ßables en mode Swap (seulement en mode Force)
  if (eleve1.mobilite === 'FIXE' || eleve2.mobilite === 'FIXE') {
    return { ok: false, reason: 'FIXE ne peut pas bouger (utilisez le mode Force)' };
  }
  
  if (eleve1.mobilite === 'SPEC' || eleve2.mobilite === 'SPEC') {
    return { ok: false, reason: 'SPEC ne peut pas bouger (utilisez le mode Force)' };
  }
  
  // CONDI : jamais d√©pla√ßables (conditionn√©s par le groupe)
  if (eleve1.mobilite === 'CONDI' || eleve2.mobilite === 'CONDI') {
    return { ok: false, reason: 'CONDI ne peut pas bouger (groupe ASSO)' };
  }
  
  // PERMUT : v√©rifier compatibilit√©
  if (eleve1.mobilite === 'PERMUT' && eleve2.mobilite === 'PERMUT') {
    const lv1 = (eleve1.lv2 || '').toUpperCase();
    const lv2 = (eleve2.lv2 || '').toUpperCase();
    
    if (lv1 === 'ESP' || lv2 === 'ESP') {
      return { ok: true };
    }
    
    if (lv1 !== lv2) {
      return { ok: false, reason: `PERMUT : LV2 diff√©rentes` };
    }
    
    return { ok: true };
  }
  
  if (eleve1.mobilite === 'PERMUT' || eleve2.mobilite === 'PERMUT') {
    return { ok: false, reason: 'PERMUT ne peut √©changer qu\'avec un autre PERMUT' };
  }
  
  // V√©rifier codes D diff√©rents (un seul a un code D)
  if (eleve1.disso || eleve2.disso) {
    if (eleve1.disso) {
      // V√©rifier si D1 serait dans la m√™me classe qu'un autre D1 apr√®s le swap
      const dejaPresent = getCurrentClassContent(classe2).some(id => {
        const s = STATE.students[id];
        return s && s.disso === eleve1.disso && id !== id2;
      });
      
      if (dejaPresent) {
        return { ok: false, reason: `Code D${eleve1.disso} d√©j√† pr√©sent dans ${classe2}` };
      }
    }
    
    if (eleve2.disso) {
      // V√©rifier si D2 serait dans la m√™me classe qu'un autre D2 apr√®s le swap
      const dejaPresent = getCurrentClassContent(classe1).some(id => {
        const s = STATE.students[id];
        return s && s.disso === eleve2.disso && id !== id1;
      });
      
      if (dejaPresent) {
        return { ok: false, reason: `Code D${eleve2.disso} d√©j√† pr√©sent dans ${classe1}` };
      }
    }
  }
  
  // V√©rifier les quotas LV2 et OPT
  const dr1 = STATE.rules[classe2] || {};
  const dr2 = STATE.rules[classe1] || {};
  
  // V√©rifier LV2 de eleve1 dans classe2
  if (eleve1.lv2 && eleve1.lv2.toUpperCase() !== 'ESP') {
    const lv2Upper = eleve1.lv2.toUpperCase();
    if (!dr1.quotas || dr1.quotas[lv2Upper] === 0) {
      console.log(`‚ùå Swap refus√©: ${eleve1.nom} (${lv2Upper}) interdit dans ${classe2}`);
      return { ok: false, reason: `${lv2Upper} interdit dans ${classe2}` };
    }
  }
  
  // V√©rifier LV2 de eleve2 dans classe1
  if (eleve2.lv2 && eleve2.lv2.toUpperCase() !== 'ESP') {
    const lv2Upper = eleve2.lv2.toUpperCase();
    if (!dr2.quotas || dr2.quotas[lv2Upper] === 0) {
      console.log(`‚ùå Swap refus√©: ${eleve2.nom} (${lv2Upper}) interdit dans ${classe1}`);
      return { ok: false, reason: `${lv2Upper} interdit dans ${classe1}` };
    }
  }
  
  // V√©rifier OPT de eleve1 dans classe2
  if (eleve1.opt && eleve1.opt.trim()) {
    const optUpper = eleve1.opt.toUpperCase();
    if (!dr1.quotas || dr1.quotas[optUpper] === 0) {
      console.log(`‚ùå Swap refus√©: ${eleve1.nom} (OPT ${optUpper}) interdit dans ${classe2}`);
      return { ok: false, reason: `Option ${optUpper} interdite dans ${classe2}` };
    }
  }
  
  // V√©rifier OPT de eleve2 dans classe1
  if (eleve2.opt && eleve2.opt.trim()) {
    const optUpper = eleve2.opt.toUpperCase();
    if (!dr2.quotas || dr2.quotas[optUpper] === 0) {
      console.log(`‚ùå Swap refus√©: ${eleve2.nom} (OPT ${optUpper}) interdit dans ${classe1}`);
      return { ok: false, reason: `Option ${optUpper} interdite dans ${classe1}` };
    }
  }
  
  console.log(`‚úÖ Swap autoris√©: ${eleve1.nom} ‚Üî ${eleve2.nom} (quotas respect√©s)`);
  return { ok: true };
}

function performSwap(id1, id2) {
  const card1 = document.querySelector(`.student-card[data-id="${id1}"]`);
  const card2 = document.querySelector(`.student-card[data-id="${id2}"]`);
  
  if (!card1 || !card2) return;
  
  const zone1 = card1.closest('.droppable-zone');
  const zone2 = card2.closest('.droppable-zone');
  
  if (!zone1 || !zone2) return;
  
  // Animation de swap
  card1.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
  card2.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
  
  // √âchanger les cartes
  zone2.appendChild(card1);
  zone1.appendChild(card2);
  
  // Marquer qu'il y a eu une action utilisateur
  if (typeof markUserAction === 'function') {
    markUserAction();
  } else {
    STATE.has_user_action = true;
  }
  
  // Historique
  const swapAction = {
    type: 'swap',
    id1, id2,
    eleve1Name: STATE.students[id1]?.nom || '√âl√®ve 1',
    eleve2Name: STATE.students[id2]?.nom || '√âl√®ve 2',
    classe1: zone1.dataset.classe,
    classe2: zone2.dataset.classe,
    timestamp: new Date().toISOString()
  };
  STATE.history.push(swapAction);
  STATE.historyTimeline.push(swapAction);
  STATE.future = [];
  updateUndoRedoButtons();
  
  // Mettre √† jour le panneau historique
  updateHistoryPanel();
  
  // ‚úÖ UNE SEULE mise √† jour des colonnes
  updateAllColumnStats();
  
  // ‚úÖ UNE SEULE mise √† jour des stats avanc√©es avec d√©lai
  setTimeout(() => updateAdvancedStats(), 150);
  
  // Feedback temps r√©el
if (window.RealTimeFeedback) {
  window.RealTimeFeedback.updateMetrics();
}
  
  // Sauvegarde
  if (STATE.currentMode === 'CACHE') {
    setTimeout(() => saveImmediateCache(), 200);
  }
  
  const eleve1 = STATE.students[id1];
  const eleve2 = STATE.students[id2];
  toast(`Swap r√©ussi entre ${eleve1.nom} et ${eleve2.nom}`, 'success');
}

function handleCardClick(e) {
  if (!STATE.swapMode) return;
  
  const card = e.currentTarget;
  const eleveId = card.dataset.id;
  const eleve = STATE.students[eleveId];
  
  // Premi√®re s√©lection
  if (!STATE.swapFirst) {
    STATE.swapFirst = eleveId;
    card.classList.add('swap-mode');
    
    let msg = `${eleve.nom} s√©lectionn√©`;
    if (eleve.mobilite === 'PERMUT') msg += ' (PERMUT)';
    else if (eleve.disso) msg += ` (D${eleve.disso})`;
    msg += ' ‚Äì choisissez un √©l√®ve √† √©changer';
    toast(msg, 'info');
    
    // Mettre en √©vidence les autres colonnes
    document.querySelectorAll('.droppable-zone').forEach(zone => {
      if (zone.dataset.classe !== card.closest('.droppable-zone').dataset.classe) {
        zone.classList.add('swap-target');
      }
    });
    return;
  }
  
  // Deuxi√®me s√©lection
  const firstId = STATE.swapFirst;
  const firstCard = document.querySelector(`.student-card[data-id="${firstId}"]`);
  
  // M√™me √©l√®ve : annuler
  if (eleveId === firstId) {
    firstCard.classList.remove('swap-mode');
    document.querySelectorAll('.droppable-zone').forEach(z => z.classList.remove('swap-target'));
    STATE.swapFirst = null;
    return;
  }
  
  // V√©rifier et effectuer le swap
  const check = canSwap(firstId, eleveId);
  if (check.ok) {
    performSwap(firstId, eleveId);
  } else {
    toast(check.reason, 'error');
  }
  
  // Nettoyer l'√©tat
  firstCard.classList.remove('swap-mode');
  document.querySelectorAll('.student-card').forEach(c => c.classList.remove('swap-mode'));
  document.querySelectorAll('.droppable-zone').forEach(z => z.classList.remove('swap-target'));
  STATE.swapFirst = null;
}

// ========== FONCTION HELPER POUR SIMPLIFIER LES NOMS COMPOS√âS ========== 
// VERSION 4.3 - Octobre 2025 - InterfaceV2
// Logique corrig√©e: premier mot = NOM, dernier mot = PR√âNOM
console.log('üîÑ VERSION 4.3 - Fonction simplifierNomComplet corrig√©e (premier/dernier mot)');

function simplifierNomComplet(nom, prenom) {
  // VERSION 4.3 - Logique corrig√©e: premier mot = NOM, dernier mot = PR√âNOM
  if (!nom && !prenom) return '';

  nom = (nom || '').trim().replace(/\s+/g, ' ');
  prenom = (prenom || '').trim().replace(/\s+/g, ' ');

  let finalNom = '';
  let finalPrenom = '';

  // Si on a un pr√©nom s√©par√©, utiliser nom et pr√©nom normalement
  if (prenom) {
    const nomParts = nom.split(/[\s-]+/).filter(Boolean);
    const prenomParts = prenom.split(/[\s-]+/).filter(Boolean);
    finalNom = nomParts[0] || nom;
    finalPrenom = prenomParts[0] || prenom;
  } else if (nom) {
    // Pas de pr√©nom s√©par√© ‚Üí analyser la colonne NOM (qui contient "NOM PRENOM")
    const parts = nom.split(/\s+/).filter(Boolean);
    
    if (parts.length >= 2) {
      // Premier mot = NOM, dernier mot = PR√âNOM
      finalNom = parts[0];
      finalPrenom = parts[parts.length - 1];
    } else {
      // Un seul mot = nom uniquement
      finalNom = parts[0] || nom;
      finalPrenom = '';
    }
  }

  let resultat = `${finalNom} ${finalPrenom}`.trim();

  const MAX_LENGTH = 25;
  if (resultat.length > MAX_LENGTH) {
    const nomPart = finalNom;
    const prenomPart = finalPrenom;

    const availableForPrenom = MAX_LENGTH - nomPart.length - 1;

    if (availableForPrenom > 0) {
      const truncatedPrenom = prenomPart.substring(0, availableForPrenom - 1) + '.';
      resultat = `${nomPart} ${truncatedPrenom}`.trim();
    } else {
      resultat = nomPart.substring(0, MAX_LENGTH - 1) + '.';
    }
  }

  // ‚úÖ Logs de d√©bogage d√©sactiv√©s (trop verbeux)
  // console.log(`DEBUG_SIMPLIFIER: nom="${nom}", prenom="${prenom}"`);
  // console.log(`DEBUG_SIMPLIFIER: finalNom="${finalNom}", finalPrenom="${finalPrenom}"`);
  // console.log(`DEBUG_SIMPLIFIER: resultat="${resultat}"`);

  if (nom !== finalNom || prenom !== finalPrenom || resultat.length > MAX_LENGTH) {
    // D√âSACTIV√â en mode production (log trop verbeux)
    // console.log(`‚úÇÔ∏è InterfaceV2 v4.3 - Nom simplifi√©: "${nom} ${prenom}" ‚Üí "${resultat}" (${resultat.length} car.)`);
  }

  return resultat;
}

// Marquer la version pour √©viter les conflits
simplifierNomComplet.version = '4.3';

// Exposer sur window pour accessibilit√© globale
if (typeof window !== 'undefined') {
  window.simplifierNomComplet = simplifierNomComplet;
  console.log('‚úÖ simplifierNomComplet VERSION 4.3 expos√©e globalement depuis InterfaceV2');
}

// ========== FONCTION DE CR√âATION DES CARTES √âL√àVES ==========
function createStudentCard(eleve) {
  /* --- STOP "CARTE VIDE" : on ignore les enregistrements sans id --- */
  if (!eleve || !eleve.id || !eleve.id.trim()) return null;
  /* ---------------------------------------------------------------- */

  const template = document.querySelector('#tpl-carte-eleve');
  const card = template.content.cloneNode(true).children[0];

  card.dataset.id = eleve.id;
  card.classList.add(`sexe-${eleve.sexe}`);

  // Attributs ARIA pour la carte √©l√®ve
  const nomCompletAria = eleve.prenom ? `${eleve.nom} ${eleve.prenom}` : eleve.nom;
  card.setAttribute('role', 'listitem');
  card.setAttribute('aria-label', nomCompletAria);
  card.setAttribute('aria-grabbed', 'false');

  // ========== MODE SIMPLE : FOND BLANC + POLICE COULEUR SEXE + SOULIGNE ROUGE SI COM=1 ==========
  if (STATE.viewMode === 'simple') {
    card.classList.add('simple-mode');
    card.innerHTML = `<div class="simple-line">
      ${document.body.classList.contains('gender-badges') ? `<span class="badge-sexe sexe-${eleve.sexe}">${eleve.sexe === 'F' ? '‚ôÄ' : '‚ôÇ'}</span>` : ''}
      <span class="student-simple-name"></span>
    </div>`;
    const nameEl = card.querySelector('.student-simple-name');

    // Nom complet simplifi√©
    let nomComplet = simplifierNomComplet(eleve.nom, eleve.prenom);

    // Couleur de police selon sexe
    let couleurTexte = '#333'; // Gris fonc√© par d√©faut
    if (eleve.sexe === 'F') {
      couleurTexte = '#ec4899'; // Rose pour F
    } else if (eleve.sexe === 'M') {
      couleurTexte = '#3b82f6'; // Bleu pour M
    }

    // Soulign√© rouge si score COM = 1
    let soulignement = 'none';
    let couleurSoulignement = '';
    if (eleve.scores && eleve.scores.COM && parseInt(eleve.scores.COM) === 1) {
      soulignement = 'underline';
      couleurSoulignement = '#FF0000'; // Rouge
    }

    // Appliquer les styles
    nameEl.textContent = nomComplet;
    nameEl.style.display = 'block';
    nameEl.style.textAlign = 'center';
    nameEl.style.fontSize = '1.1rem';
    nameEl.style.fontWeight = '600';
    nameEl.style.padding = '8px';
    nameEl.style.color = couleurTexte;
    nameEl.style.textDecoration = soulignement;
    nameEl.style.overflow = 'hidden';
    nameEl.style.textOverflow = 'ellipsis';
    nameEl.style.whiteSpace = 'nowrap';
    nameEl.style.maxWidth = '100%';
    if (soulignement === 'underline') {
      nameEl.style.textDecorationColor = couleurSoulignement;
      nameEl.style.textDecorationThickness = '3px';
      nameEl.style.textUnderlineOffset = '3px';
    }

    card.style.background = '#fff'; // Fond blanc pour tous
    card.style.border = '1px solid rgba(0,0,0,0.1)';
    card.style.borderRadius = '6px';
  } else if (STATE.viewMode === 'essential') {
    // Mode essentiel : nom + badges essentiels (pas d'options ni scores)
    const fullNameElement = card.querySelector('.student-fullname');
    const nomComplet = simplifierNomComplet(eleve.nom, eleve.prenom);
    fullNameElement.textContent = nomComplet;

    // --- NEW CODE FOR GENDER BADGE ---
    if (document.body.classList.contains('gender-badges')) {
      const genderBadge = document.createElement('span');
      genderBadge.classList.add('badge-sexe', `sexe-${eleve.sexe}`);
      genderBadge.textContent = eleve.sexe === 'F' ? '‚ôÄ' : '‚ôÇ';
      // Find the parent of fullNameElement to insert before it
      fullNameElement.parentNode.insertBefore(genderBadge, fullNameElement);
    }
    // --- END NEW CODE ---

    // NOM EN ROUGE si score COM = 1
    if (eleve.scores && eleve.scores.COM && parseInt(eleve.scores.COM) === 1) {
      fullNameElement.style.color = '#FF0000';
      fullNameElement.style.fontWeight = '700';
    }

    // Badges essentiels : LV2, OPT, DISSO, ASSO (PAS DE DISPO)
    const allBadgesContainer = card.querySelector('.all-badges');
    allBadgesContainer.style.justifyContent = 'center';

    let totalBadges = 0;
    if (eleve.mobilite && eleve.mobilite !== 'LIBRE') totalBadges++;
    if (eleve.disso) totalBadges++;
    if (eleve.asso) totalBadges++;
    if (eleve.lv2) totalBadges++;
    const compactMode = totalBadges > 3;

    // Badge Mobilit√©
    if (eleve.mobilite && eleve.mobilite !== 'LIBRE') {
      const badge = document.createElement('span');
      let mobText = eleve.mobilite;
      let mobClass = 'badge-mobilite';
      if (compactMode) {
        const abrevMap = {'CONDI': 'CO', 'FIXE': 'FI', 'PERMUT': 'PER', 'SPEC': 'SP'};
        mobText = abrevMap[eleve.mobilite] || eleve.mobilite;
        mobClass += ' badge-compact';
      }
      badge.className = `mini-badge ${mobClass}`;
      badge.textContent = mobText;
      badge.title = `Mobilit√©: ${eleve.mobilite}`;
      allBadgesContainer.appendChild(badge);
    }

    // Badge Dissociation
    if (eleve.disso) {
      const badge = document.createElement('span');
      badge.className = 'mini-badge badge-disso';
      badge.textContent = eleve.disso.replace(/^D/i, 'D');
      badge.title = `Dissociation: ${eleve.disso}`;
      allBadgesContainer.appendChild(badge);
    }

    // Badge Association
    if (eleve.asso) {
      const badge = document.createElement('span');
      badge.className = 'mini-badge badge-asso';
      badge.textContent = eleve.asso.replace(/^A/i, 'A');
      badge.title = `Association: ${eleve.asso}`;
      allBadgesContainer.appendChild(badge);
    }

    // Badge LV2
    if (eleve.lv2 && eleve.lv2.trim()) {
      const badge = document.createElement('span');
      badge.className = `mini-badge badge-${eleve.lv2.toUpperCase()}`;
      badge.textContent = eleve.lv2.toUpperCase();
      badge.title = `LV2: ${eleve.lv2}`;
      allBadgesContainer.appendChild(badge);
    }

    // Badge OPT
    if (eleve.opt && eleve.opt.trim()) {
      const badge = document.createElement('span');
      badge.className = `mini-badge badge-${eleve.opt.toUpperCase()}`;
      badge.textContent = eleve.opt.toUpperCase();
      badge.title = `Option: ${eleve.opt}`;
      allBadgesContainer.appendChild(badge);
    }

    // Source uniquement (pas de scores)
    card.querySelector('.source-class').textContent = eleve.source || '';
    card.querySelector('.scores').innerHTML = '';
  } else {
    // ========== MODE COMPLETE: NOM + LV2/OPT + BADGES SCORES ==========
    const fullNameElement = card.querySelector('.student-fullname');
    const nomComplet = simplifierNomComplet(eleve.nom, eleve.prenom);
    
    // --- NEW CODE FOR GENDER BADGE ---
    if (document.body.classList.contains('gender-badges')) {
      const genderBadge = document.createElement('span');
      genderBadge.classList.add('badge-sexe', `sexe-${eleve.sexe}`);
      genderBadge.textContent = eleve.sexe === 'F' ? '‚ôÄ' : '‚ôÇ';
      // Find the parent of fullNameElement to insert before it
      fullNameElement.parentNode.insertBefore(genderBadge, fullNameElement);
    }
    // --- END NEW CODE ---

    fullNameElement.textContent = nomComplet;
    fullNameElement.className = 'student-fullname'; // Reset class in case it was modified

    // NOM EN ROUGE si score COM = 1
    if (eleve.scores && eleve.scores.COM && parseInt(eleve.scores.COM) === 1) {
      fullNameElement.style.color = '#FF0000';
      fullNameElement.style.fontWeight = '700';
    }
    
    // Badge DISPO (nom complet)
    const dispoContainer = card.querySelector('.badge-dispo-container');
    if (eleve.dispo && eleve.dispo.trim()) {
      const dispoBadge = document.createElement('span');
      dispoBadge.className = 'badge-dispo';
      const dispoValue = eleve.dispo.toUpperCase().trim();
      dispoBadge.textContent = dispoValue; // Afficher le nom complet
      dispoBadge.title = `Dispositif: ${eleve.dispo}`;
      dispoContainer.appendChild(dispoBadge);
    }

    // ========== LIGNE 2: TOUS LES BADGES (LV2, OPT, DISSO, ASSO) ==========
    const allBadgesContainer = card.querySelector('.all-badges');
    allBadgesContainer.style.justifyContent = 'center';

    // Badge LV2
    if (eleve.lv2 && eleve.lv2.trim()) {
      const badge = document.createElement('span');
      badge.className = `mini-badge badge-${eleve.lv2.toUpperCase()}`;
      badge.textContent = eleve.lv2.toUpperCase();
      badge.title = `LV2: ${eleve.lv2}`;
      allBadgesContainer.appendChild(badge);
    }

    // Badge Option
    if (eleve.opt && eleve.opt.trim()) {
      const badge = document.createElement('span');
      badge.className = `mini-badge badge-${eleve.opt.toUpperCase()}`;
      badge.textContent = eleve.opt.toUpperCase();
      badge.title = `Option: ${eleve.opt}`;
      allBadgesContainer.appendChild(badge);
    }

    // Badge Dissociation
    if (eleve.disso) {
      const badge = document.createElement('span');
      badge.className = 'mini-badge badge-disso';
      badge.textContent = eleve.disso.replace(/^D/i, 'D');
      badge.title = `Dissociation: ${eleve.disso}`;
      allBadgesContainer.appendChild(badge);
    }

    // Badge Association
    if (eleve.asso) {
      const badge = document.createElement('span');
      badge.className = 'mini-badge badge-asso';
      badge.textContent = eleve.asso.replace(/^A/i, 'A');
      badge.title = `Association: ${eleve.asso}`;
      allBadgesContainer.appendChild(badge);
    }
    
    // ========== LIGNE 3: Source + Scores ==========
    card.querySelector('.source-class').textContent = eleve.source || '';
    
    // Badges scores COM/TRA/PART/ABS avec lettres et couleurs
    const scoresContainer = card.querySelector('.scores');
    const scoreMap = [
      { key: 'COM', label: 'Comportement', letter: 'C' },
      { key: 'TRA', label: 'Travail', letter: 'T' },
      { key: 'PART', label: 'Participation', letter: 'P' },
      { key: 'ABS', label: 'Absences', letter: 'A' }
    ];
    scoreMap.forEach(({ key, label, letter }) => {
      const value = eleve.scores[key];
      if (value && value > 0) {
        const pill = document.createElement('div');
        pill.className = `score-pill score-${value}`;
        pill.textContent = letter; // Afficher la LETTRE (C, T, P, A)
        pill.title = `${label}: ${value}/4`;
        scoresContainer.appendChild(pill);
      }
    });
  }
  
  // Event listeners pour drag & drop et swap
  card.addEventListener('dragstart', handleDragStart);
  card.addEventListener('dragend', handleDragEnd);
  card.addEventListener('click', handleCardClick);
  
  // üîí Indication visuelle pour les √©l√®ves FIXE/SPEC/CONDI/PERMUT (le blocage est g√©r√© par le filtre Sortable)
  if (!STATE.adminMode && eleve.mobilite && ['FIXE', 'SPEC', 'CONDI', 'PERMUT'].includes(eleve.mobilite)) {
    card.classList.add('non-draggable');
    card.style.opacity = '0.85';
    card.title = `${eleve.nom} est ${eleve.mobilite} - Utilisez le mode Swap ou le mode Force pour le d√©placer`;
  }
  
  return card;
}

// ========== FONCTION DE CR√âATION DES COLONNES DE CLASSE ==========
function createClassColumn(classe, eleves) {
  // On retire d'embl√©e les enregistrements "vides"
  const clean = eleves.filter(e => e && e.id && e.id.trim());

  const column = document.querySelector('#tpl-classe-col')
                 .content.cloneNode(true).children[0];

  // Attributs ARIA pour la colonne
  const classHeader = column.querySelector('.class-header');
  if (classHeader) {
    classHeader.id = `class-header-${classe}`;
  }
  column.setAttribute('role', 'region');
  column.setAttribute('aria-labelledby', `class-header-${classe}`);

  column.querySelector('.classe-name').textContent = classe;
  column.querySelector('.count').textContent   = clean.length;
  column.querySelector('.count-f').textContent = clean.filter(e => e.sexe === 'F').length;
  column.querySelector('.count-m').textContent = clean.filter(e => e.sexe === 'M').length;

  const dropZone = column.querySelector('.droppable-zone');
  dropZone.dataset.classe = classe;
  dropZone.setAttribute('role', 'list');
  dropZone.setAttribute('aria-label', `Liste des √©l√®ves de ${classe}`);

  // Boutons de tri
  column.querySelectorAll('.sort-btn').forEach(btn => {
    btn.addEventListener('click', e => {
      const sortType = e.currentTarget.dataset.sort;
      const prev     = STATE.sortOrder[classe] || {};
      const dir      = (prev.type === sortType && prev.dir === 'asc') ? 'desc' : 'asc';

      sortColumn(classe, sortType, dir);

      // Feedback visuel
      column.querySelectorAll('.sort-btn').forEach(b => {
        const arrow = b.querySelector('.sort-arrow');
        if (b === e.currentTarget) {
          b.classList.add('active');
          arrow.textContent = dir === 'asc' ? '‚Üë' : '‚Üì';
        } else {
          b.classList.remove('active');
          arrow.textContent = '‚áÖ';
        }
      });
    });
  });

  // Restaurer l'√©tat visuel du tri si existant
  const currentSort = STATE.sortOrder[classe];
  if (currentSort) {
    column.querySelectorAll('.sort-btn').forEach(btn => {
      const arrow = btn.querySelector('.sort-arrow');
      if (btn.dataset.sort === currentSort.type) {
        btn.classList.add('active');
        arrow.textContent = currentSort.dir === 'asc' ? '‚Üë' : '‚Üì';
      }
    });
  }

  // Drag-and-drop
  dropZone.addEventListener('dragover',  handleDragOver);
  dropZone.addEventListener('drop',      handleDrop);
  dropZone.addEventListener('dragleave', handleDragLeave);

  const sortable = new Sortable(dropZone, {
    group: 'students',
    animation: 150,
    ghostClass: 'opacity-50',
    dragClass: 'dragging',
    // üîí Filtre pour bloquer le drag des √©l√®ves FIXE/SPEC/CONDI/PERMUT (sauf en mode admin)
    filter: function(evt, target) {
      if (!target || !target.dataset) {
        console.warn('‚ö†Ô∏è Filtre Sortable: target invalide', target);
        return true; // Bloquer par s√©curit√©
      }
      
      // üî• V√âRIFICATION MODE FORCE
      console.log('üîç Filtre Sortable - STATE.adminMode =', STATE?.adminMode);
      if (STATE.adminMode) {
        console.log('üî• MODE FORCE ACTIF - Drag autoris√© sans v√©rification');
        return false; // En mode admin, tout est draggable
      }
      
      const eleveId = target.dataset.id;
      if (!eleveId) return false; // Pas d'ID, autoriser (ne devrait pas arriver)
      const eleve = STATE.students[eleveId];
      if (eleve && eleve.mobilite && ['FIXE', 'SPEC', 'CONDI', 'PERMUT'].includes(eleve.mobilite)) {
        console.log(`üîí Drag bloqu√© pour ${eleve.nom} (${eleve.mobilite}) - MODE FORCE INACTIF`);
        toast(`${eleve.nom} est ${eleve.mobilite} - Utilisez le mode Swap ou le mode Force`, 'warning');
        return true; // Bloquer le drag
      }
      return false; // Autoriser le drag
    },
    onEnd: handleSortEnd,
    onStart: (evt) => {
      console.log('üñ±Ô∏è Drag started:', evt.item.dataset.id);
      // Stocker l'√©l√©ment en cours de d√©placement
      STATE.draggingElement = evt.item;
      STATE.dragStartZone = evt.from;
    },
    onMove: (evt) => {
      console.log('üñ±Ô∏è Drag move:', evt.dragged.dataset.id, 'from', evt.from.dataset.classe, 'to', evt.to.dataset.classe);
    }
  });
  
  // (SUPPRIM√â : double appel de handleSortEnd - onEnd de SortableJS suffit)
  
  console.log('üîß Sortable cr√©√© pour zone:', dropZone.dataset.classe);

  // Cartes √©l√®ves
  clean.forEach(e => {
    const c = createStudentCard(e);
    if (c) dropZone.appendChild(c);
  });

  // Adaptation dynamique de la taille des noms en vue simplifi√©e
  setTimeout(() => adjustSimpleNamesFontSize(dropZone), 0);
  return column;
}

// ========== HANDLERS DRAG & DROP ==========
function handleDragStart(e) {
  if (STATE.swapMode) return; // Pas de drag en mode swap

  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/plain', e.target.dataset.id);
  // Mettre √† jour aria-grabbed
  e.target.setAttribute('aria-grabbed', 'true');
  e.target.classList.add('dragging');
}

function handleDragEnd(e) {
  e.target.classList.remove('dragging');
  // Remettre aria-grabbed √† false
  e.target.setAttribute('aria-grabbed', 'false');
  document.querySelectorAll('.drag-over, .drop-forbidden').forEach(el => {
    el.classList.remove('drag-over', 'drop-forbidden');
  });
}

function handleDragOver(e) {
  if (STATE.swapMode) return;
  e.preventDefault();
  
  // V√©rifier si le drop est autoris√©
  const draggedId = e.dataTransfer.getData('text/plain') || 
    document.querySelector('.dragging')?.dataset.id;
  
  if (draggedId) {
    const draggedCard = document.querySelector(`.student-card[data-id="${draggedId}"]`);
    if (draggedCard) {
      const srcClasse = draggedCard.closest('.droppable-zone').dataset.classe;
      const dstClasse = e.currentTarget.dataset.classe;
      
      const check = canMove(draggedId, srcClasse, dstClasse);
      
      if (check.ok || STATE.adminMode) {
        e.currentTarget.classList.add('drag-over');
        e.currentTarget.classList.remove('drop-forbidden');
        
        // Pr√©visualiser l'impact du d√©placement
        if (window.RealTimeFeedback && srcClasse !== dstClasse) {
  window.RealTimeFeedback.previewMove(draggedId, dstClasse);
}
      } else {
        e.currentTarget.classList.add('drop-forbidden');
        e.currentTarget.classList.remove('drag-over');
        
        // R√©initialiser les changements si drop interdit
        if (window.RealTimeFeedback) {
  window.RealTimeFeedback.resetChanges();
        }
      }
    }
  }
}

function handleDragLeave(e) {
  if (e.target === e.currentTarget) {
    e.currentTarget.classList.remove('drag-over', 'drop-forbidden');
    
    // R√©initialiser les changements quand on quitte la zone
    if (RealTimeFeedback) {
      RealTimeFeedback.resetChanges();
    }
  }
}

function handleDrop(e) {
  if (STATE.swapMode) return;
  e.preventDefault();
  e.currentTarget.classList.remove('drag-over', 'drop-forbidden');
}

// ========== handleSortEnd (version finale en bas du fichier, suppression de l'ancienne version) ==========
window.handleSortEnd = function(evt) {
  console.log('üéØ handleSortEnd CLEAN');
  
  if (STATE.swapMode) return;

  const eleveId = evt.item.dataset.id;
  const oldClasse = evt.from.dataset.classe;
  const newClasse = evt.to.dataset.classe;

  // Si m√™me classe, juste mise √† jour des colonnes
  if (oldClasse === newClasse) {
    updateAllColumnStats(); // ‚Üê CET APPEL MANQUE PEUT-√äTRE
    if (window.RealTimeFeedback) window.RealTimeFeedback.updateMetrics();
    return;
  }

  // Marquer qu'il y a eu une action utilisateur (d√©placement entre classes)
  if (typeof markUserAction === 'function') {
    markUserAction();
  } else {
    STATE.has_user_action = true;
  }

  // üî• MODE FORCE : Tout est autoris√© sans v√©rification
  if (STATE.adminMode) {
    console.log('üî• MODE FORCE: D√©placement autoris√© sans v√©rification');
  } else {
    // Mode normal : v√©rifier les contraintes
    const check = canMove(eleveId, oldClasse, newClasse);

    if (!check.ok) {
      evt.from.insertBefore(evt.item, evt.from.children[evt.oldIndex] || null);
      toast(check.reason, 'error');
      updateAllColumnStats();
      return;
    }

    if (check.warn) {
      toast(check.warn, 'warning');
    }
  }

  // Historique
  const moveAction = {
    type: 'move', 
    eleveId, 
    eleveName: STATE.students[eleveId]?.nom || '√âl√®ve',
    oldClasse, 
    newClasse,
    oldIndex: evt.oldIndex, 
    newIndex: evt.newIndex,
    timestamp: new Date().toISOString()
  };
  STATE.history.push(moveAction);
  STATE.historyTimeline.push(moveAction);
  STATE.future = [];
  updateUndoRedoButtons();
  
  // Mettre √† jour le panneau historique
  updateHistoryPanel();

  // ‚úÖ UNE SEULE mise √† jour des colonnes
  updateAllColumnStats(); // ‚Üê CET APPEL DOIT √äTRE PR√âSENT
  
  // ‚úÖ UNE SEULE mise √† jour des stats avanc√©es avec d√©lai
  setTimeout(() => updateAdvancedStats(), 150);
  
  // Feedback temps r√©el
  if (RealTimeFeedback) RealTimeFeedback.updateMetrics();
  
  // Sauvegarde
  if (STATE.currentMode === 'CACHE') {
    setTimeout(() => saveImmediateCache(), 200);
  }
};

// ========== FONCTION MANQUANTE - Chargement des donn√©es selon le mode ==========
async function loadDataForMode(mode) {
  showSpinner();
  try {
    // Appel √† la fonction Google Apps Script pour r√©cup√©rer les donn√©es
    const result = await gsRun('getClassesData', mode);
    if (!result || !result.success) {
      console.error('‚ùå Erreur lors du chargement des donn√©es:', result?.error);
      return false;
    }
    // Stocker les donn√©es dans STATE
    STATE.originalData = result.data;
    STATE.rules = result.rules || {};
    STATE.niveau = detectNiveau(result.data);
    // Mettre √† jour l'interface
    const niveauElement = document.getElementById('niveau-detected');
    if (niveauElement) {
      niveauElement.textContent = STATE.niveau;
    }
    // Cr√©er le dictionnaire des √©l√®ves et les groupes
    STATE.students = {};
    STATE.aGroups = {};
    result.data.forEach(group => {
      group.eleves.forEach(eleve => {
        STATE.students[eleve.id] = eleve;
        // Grouper les associations
        if (eleve.asso) {
          const key = `A${eleve.asso}`;
          if (!STATE.aGroups[key]) STATE.aGroups[key] = [];
          STATE.aGroups[key].push(eleve.id);
        }
      });
    });
    // Afficher les colonnes
    renderBoard(result.data);
    return true;
  } catch (error) {
    console.error('üí• Erreur fatale:', error);
    return false;
  } finally {
    hideSpinner();
  }
}

// ========== FONCTION - Affichage des colonnes/classes ==========
function renderBoard(data) {
  const board = document.getElementById('board');
  if (!board) {
    console.error('√âl√©ment #board introuvable');
    return;
  }

  board.innerHTML = '';
  if (!data || data.length === 0) {
    showErrorState('Aucune classe trouv√©e');
    return;
  }

  /* --- tri naturel des intitul√©s "6¬∞1", "6¬∞2", ‚Ä¶ --- */
  const sortedData = data.slice().sort((a, b) => {
    const ma = a.classe.match(/(\d+)¬∞(\d+)/);
    const mb = b.classe.match(/(\d+)¬∞(\d+)/);
    if (ma && mb) {
      const nivA = +ma[1], nivB = +mb[1];
      if (nivA !== nivB) return nivA - nivB;
      return +ma[2] - +mb[2];
    }
    return a.classe.localeCompare(b.classe);
  });

  /* --- cr√©ation des colonnes --- */
  sortedData.forEach(group => {
    const col = createClassColumn(group.classe, group.eleves);
    if (col) board.appendChild(col);
  });

  /* --- ajustements de pr√©sentation --- */
  setTimeout(resizeCards, 100);
  updateAllColumnStats();              // <-- nouvelle ligne : compteurs √† jour !

  if (STATE.viewMode === 'simple') {
    setTimeout(() => {
      document.querySelectorAll('.droppable-zone')
              .forEach(zone => adjustSimpleNamesFontSize(zone));
    }, 120);
  }

  if (window.applyLisibilitePreferences) {
    window.applyLisibilitePreferences();
  }

  /* --- initialisation des graphiques --- */
  setTimeout(() => {
    if (typeof initCharts === 'function') {
      initCharts();
      console.log('üìä Graphiques initialis√©s apr√®s chargement des donn√©es');
    }
  }, 200);
}

// ========== FONCTION MANQUANTE - AFFICHAGE DU BADGE DE MODE ==========
function showModeBadge(mode) {
  const badge = document.getElementById('modeBadge');
  if (badge) {
    // D√©terminer le label et la couleur selon le mode
    let label = 'MODE ' + mode;
    let bgColor = '#3b82f6'; // Bleu par d√©faut

    switch(mode) {
      case 'TEST':
        label = 'üìö TEST (Classes test)';
        bgColor = '#3b82f6'; // Bleu
        break;
      case 'PREVIOUS':
        label = 'üìã PREVIOUS (Ann√©e pass√©e)';
        bgColor = '#8b5cf6'; // Violet
        break;
      case 'FINAL':
        label = '‚úÖ FINAL (Classes finales)';
        bgColor = '#10b981'; // Vert
        break;
      // Anciens modes pour r√©trocompatibilit√©
      case 'CACHE':
        label = 'MODE CACHE';
        bgColor = '#f59e0b'; // Orange
        break;
      case 'INT':
        label = 'MODE INT';
        bgColor = '#10b981'; // Vert
        break;
    }

    badge.textContent = label;
    badge.style.background = bgColor;
    badge.style.color = 'white';
    badge.classList.remove('hidden');
  }
}

// ========== FONCTION - Badge de sauvegarde ==========
function updateSaveBadgeUI() {
  const el = document.getElementById('autosaveBadge');
  if (!el) return;
  if (STATE.last_save_ts) {
    const d = new Date(STATE.last_save_ts);
    el.textContent = `üíæ Sauvegard√© ${d.getHours()}h${String(d.getMinutes()).padStart(2,'0')}`;
  } else {
    el.textContent = `üíæ Jamais`;
  }
}

// ========== FONCTIONS MANQUANTES - Auto-save ==========
function startAutoSave() {
  stopAutoSave(); // ‚Üê On s'assure qu'il n'y en a qu'un
  console.log('üîÑ Auto-save CACHE activ√© (1 minute)');
  autoSaveInterval = setInterval(async () => {
    // Appeler window.saveImmediateCache qui g√®re d√©j√† la v√©rification has_user_action
    if (typeof window.saveImmediateCache === 'function') {
      await window.saveImmediateCache();
    }
  }, 60000); // Toutes les 1 minute
}

function stopAutoSave() {
  if (autoSaveInterval !== null) { // ‚Üê V√©rifie l'existence
    clearInterval(autoSaveInterval);
    autoSaveInterval = null;
    console.log('‚èπÔ∏è Auto-save arr√™t√©');
  }
}

// ========== FONCTION MANQUANTE - V√©rifier le cache ==========
async function checkCache() {
  const restoreBlock = document.getElementById('restoreCacheBlock');
  const lastDate = document.getElementById('lastCacheDate');

  // 1. V√©rifier d'abord le localStorage
  const cached = localStorage.getItem('cache-data');
  if (cached) {
    try {
      const data = JSON.parse(cached);
      if (restoreBlock) restoreBlock.classList.remove('hidden');
      if (lastDate) {
        lastDate.textContent = new Date(data.date).toLocaleString('fr-FR');
      }
      return; // On a trouv√© des donn√©es dans le localStorage
    } catch (e) {
      console.error('Cache localStorage invalide:', e);
    }
  }

  // 2. Si pas de localStorage, v√©rifier le backend (PropertiesService)
  try {
    console.log('üîç V√©rification de la sauvegarde automatique depuis le backend...');
    const backendCache = await gsRun('getLastCacheInfo');

    if (backendCache && backendCache.exists && backendCache.date) {
      console.log('‚úÖ Sauvegarde automatique trouv√©e dans le backend:', backendCache);
      if (restoreBlock) restoreBlock.classList.remove('hidden');
      if (lastDate) {
        const date = new Date(backendCache.date);
        lastDate.textContent = date.toLocaleString('fr-FR');
      }
    } else {
      console.log('‚ÑπÔ∏è Aucune sauvegarde automatique trouv√©e');
      if (restoreBlock) restoreBlock.classList.add('hidden');
    }
  } catch (error) {
    console.error('‚ùå Erreur lors de la v√©rification du cache backend:', error);
  }
}

// ========== FONCTION MANQUANTE - Restaurer le cache ==========
async function restoreCache() {
  const cached = localStorage.getItem('cache-data');
  if (!cached) return;
  try {
    const data = JSON.parse(cached);
    localStorage.setItem('mode-selection', data.mode);
    await initRepartitionApp();
    // Appliquer la disposition sauvegard√©e
    if (data.disposition) {
      Object.entries(data.disposition).forEach(([classe, ids]) => {
        const zone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
        if (zone) {
          ids.forEach(id => {
            const card = document.querySelector(`.student-card[data-id="${id}"]`);
            if (card) zone.appendChild(card);
          });
        }
      });
    }
    updateAllColumnStats();
    toast('Cache restaur√© avec succ√®s', 'success');
  } catch (e) {
    console.error('Erreur restauration cache:', e);
    toast('Erreur lors de la restauration', 'error');
  }
}

// =======================================================
// VARIABLES GLOBALES
// =======================================================
let autoSaveInterval = null;

// D√âPLACER STATE ICI ! ET L'EXPOSER SUR WINDOW
window.STATE = {
    viewMode: 'complete',
    students: {},
    rules: {},
    aGroups: {},
    history: [],
    historyTimeline: [], // Ajout√© pour le panneau historique
    future: [],
    swapMode: false,
    swapFirst: null,
    adminMode: false,
    searchTerm: '',
    darkMode: false,
    zoomMode: false,
    fullscreenStats: false,
    anchoredStats: false,
    currentMode: null,
    originalData: null,
    niveau: '',
    sortOrder: {},
    lastSaveError: false,
    draggingElement: null,
    dragStartZone: null,
    has_user_action: false,
    last_save_timestamp: null
};

// Alias pour compatibilit√© avec le code existant
const STATE = window.STATE;

// Variables pour les graphiques (les d√©placer aussi)
window.chartCommunication = null;
window.chartDistribution = null;
window.chartLV2 = null;
window.chartOptions = null;

// ============================================
// ARCHITECTURE MODULAIRE
// ============================================
/**
 * Architecture modulaire de l'application InterfaceV2
 *
 * Cette section organise le code JavaScript en modules logiques pour am√©liorer
 * l'organisation et la maintenabilit√© du code (12561 lignes).
 *
 * DOCUMENTATION COMPL√àTE : Voir ARCHITECTURE_MODULAIRE.md
 *
 * MODULES DISPONIBLES :
 * - App.state       : √âtat global de l'application (alias de STATE)
 * - App.UI          : Cr√©ation et manipulation des √©l√©ments UI
 * - App.DragDrop    : Gestion du drag and drop
 * - App.Views       : Gestion des diff√©rentes vues (simple, complete, swap, dark mode)
 * - App.History     : Historique et undo/redo
 * - App.Stats       : Statistiques et m√©triques
 * - App.Constraints : Validation des contraintes
 * - App.Data        : Import/Export et sauvegarde
 * - App.Search      : Recherche et filtres
 * - App.Utils       : Fonctions utilitaires
 * - App.Init        : Initialisation de l'application
 *
 * COMPATIBILIT√â :
 * Des fonctions wrapper globales sont disponibles pour assurer la compatibilit√©
 * avec le code existant. Voir section "FONCTIONS WRAPPER POUR COMPATIBILIT√â" ci-dessous.
 *
 * UTILISATION :
 * // Nouveau code (recommand√©)
 * App.UI.toast('Message', 'success');
 *
 * // Code legacy (toujours support√© via wrappers)
 * toast('Message', 'success');
 *
 * MIGRATION EN COURS :
 * ‚úÖ App.UI          - toast, updateColumnStats, showSpinner, etc.
 * ‚úÖ App.History     - undo, redo, updateUndoRedoButtons
 * ‚úÖ App.Stats       - updateAdvancedStats
 * ‚úÖ App.Data        - exportDisposition, saveImmediateCache
 * ‚úÖ App.Utils       - isRealClass
 * ‚è≥ App.Views       - √Ä migrer : toggleViewMode, toggleSwapMode, etc.
 * ‚è≥ App.DragDrop    - √Ä migrer : handleDragStart, handleDrop, etc.
 * ‚è≥ App.Constraints - √Ä migrer : canMove, canSwap
 * ‚è≥ App.Search      - √Ä migrer : searchStudents, filterByTag
 * ‚è≥ App.Init        - √Ä migrer : setupEventListeners, initApp
 */

const App = {
  // ============================================
  // √âTAT GLOBAL (r√©f√©rence vers STATE)
  // ============================================
  get state() {
    return STATE;
  },

  // ============================================
  // MODULE UI - Cr√©ation et manipulation des √©l√©ments
  // ============================================
  UI: {
    /**
     * Affiche une notification toast
     * @param {string} message - Message √† afficher
     * @param {string} type - Type de notification (info, success, error, warning)
     */
    toast(message, type = 'info') {
      const icons = {
        info: 'fa-info-circle',
        success: 'fa-check-circle',
        error: 'fa-exclamation-circle',
        warning: 'fa-exclamation-triangle'
      };

      const isSwapError = type === 'error';
      const toast = document.createElement('div');

      if (isSwapError) {
        toast.className = `toast ${type} fade-in`;
        toast.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          z-index: 9999;
          font-size: 1.5rem;
          padding: 24px 40px;
          box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
          border-radius: 12px;
          background: #dc2626;
          color: white;
          border: none;
          font-weight: 600;
          min-width: 400px;
          text-align: center;
        `;
      } else {
        toast.className = `toast ${type} fixed bottom-4 right-4 z-50 fade-in`;
      }

      toast.innerHTML = `
        <i class="fas ${icons[type]} ${isSwapError ? 'text-2xl mr-3' : 'text-lg'}"></i>
        <span>${message}</span>
      `;

      document.body.appendChild(toast);

      const duration = isSwapError ? 4000 : 3000;

      setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transition = 'opacity 0.3s ease-out';
        setTimeout(() => toast.remove(), 300);
      }, duration);
    },

    /**
     * Met √† jour les statistiques d'une colonne de classe
     * @param {HTMLElement} column - √âl√©ment DOM de la colonne
     * @param {Array} eleves - Liste des √©l√®ves
     */
    updateColumnStats(column, eleves) {
      if (!column) return;

      const count   = eleves.length;
      const countF  = eleves.filter(e => e.sexe === 'F').length;
      const countM  = eleves.filter(e => e.sexe === 'M').length;

      column.querySelector('.count').textContent    = count;
      column.querySelector('.count-f').textContent  = countF;
      column.querySelector('.count-m').textContent  = countM;

      const scoreCats = ['C', 'T', 'P', 'A'];
      const counters  = { C:[0,0,0,0], T:[0,0,0,0], P:[0,0,0,0], A:[0,0,0,0] };

      eleves.forEach(e => {
        scoreCats.forEach(cat => {
          const v = +e.scores?.[cat] || 0;
          if (v >= 1 && v <= 4) counters[cat][v-1]++;
        });
      });

      scoreCats.forEach(cat => {
        counters[cat].forEach((val, i) => {
          const el = column.querySelector(`.count-${cat.toLowerCase()}${i+1}`);
          if (el) el.textContent = val;
        });
      });
    },

    /**
     * Met √† jour les statistiques de toutes les colonnes
     */
    updateAllColumnStats() {
      console.log('üìä App.UI.updateAllColumnStats - version modulaire');

      document.querySelectorAll('.class-column').forEach(column => {
        const className = column.querySelector('.classe-name').textContent;
        if (!App.Utils.isRealClass(className)) return;

        const dropZone = column.querySelector('.droppable-zone');
        const cards = Array.from(dropZone.querySelectorAll('.student-card'));
        const eleves = cards.map(card => STATE.students[card.dataset.id]).filter(Boolean);

        App.UI.updateColumnStats(column, eleves);
      });
    },

    /**
     * Ajuste la taille de police des noms en vue simplifi√©e
     * @param {HTMLElement} dropZone - Zone de d√©p√¥t
     */
    adjustSimpleNamesFontSize(dropZone) {
      if (!STATE || STATE.viewMode !== 'simple') return;
      const cards = Array.from(dropZone.querySelectorAll('.student-card'));
      if (cards.length === 0) return;

      let zoneHeight = dropZone.clientHeight || dropZone.offsetHeight || 0;
      if (!zoneHeight) {
        const parent = dropZone.closest('.class-column');
        if (parent) zoneHeight = parent.clientHeight || parent.offsetHeight || 0;
      }
      if (!zoneHeight) return;

      const availableHeight = zoneHeight - 30;
      const minFont = 16;
      const maxFont = 32;
      let fontSize = Math.floor(availableHeight / cards.length) - 2;

      if (isNaN(fontSize) || fontSize < minFont) fontSize = minFont;
      if (fontSize > maxFont) fontSize = maxFont;

      cards.forEach(card => {
        const nameEl = card.querySelector('.student-simple-name');
        const lineEl = card.querySelector('.simple-line');
        if (nameEl) {
          nameEl.style.fontSize = fontSize + 'px';
          nameEl.style.lineHeight = (fontSize + 2) + 'px';
        }
        if (lineEl) {
          lineEl.style.height = (fontSize + 6) + 'px';
        }
      });
    },

    /**
     * Affiche/masque le spinner de chargement
     */
    showSpinner() {
      document.getElementById('loadingSpinner')?.classList.remove('hidden');
    },

    hideSpinner() {
      document.getElementById('loadingSpinner')?.classList.add('hidden');
    },

    /**
     * Ajoute un nouvel √©l√®ve √† une classe
     * Fonction publique appel√©e par le module NewStudentModule
     * @param {Object} newStudent - Objet √©l√®ve au format {id, nom, prenom, sexe, lv2, opt, scores, ...}
     * @param {string} classId - ID de la classe (ex: "6¬∞1")
     */
    addStudentToClass(newStudent, classId) {
      console.log(`[App.UI.addStudentToClass] Ajout de ${newStudent.nom} ${newStudent.prenom} dans ${classId}`);

      if (!newStudent || !newStudent.id || !classId) {
        console.error('[App.UI.addStudentToClass] Donn√©es invalides');
        return false;
      }

      // 1. Ajouter √† STATE.students
      if (!STATE.students) STATE.students = {};
      STATE.students[newStudent.id] = newStudent;

      // 2. Ajouter √† STATE.classes
      if (!STATE.classes[classId]) {
        STATE.classes[classId] = { eleves: [] };
      }
      STATE.classes[classId].eleves.push(newStudent);

      // 3. Ajouter au DOM (cr√©er la carte et l'ins√©rer dans la zone de d√©p√¥t)
      const dropZone = document.querySelector(`.droppable-zone[data-classe="${classId}"]`);
      if (dropZone && typeof createStudentCard === 'function') {
        const card = createStudentCard(newStudent);
        if (card) {
          dropZone.appendChild(card);
          console.log(`[App.UI.addStudentToClass] Carte DOM cr√©√©e et ins√©r√©e`);
        }
      }

      // 4. Ajouter √† STATE.aGroups si association
      if (newStudent.asso) {
        const key = `A${newStudent.asso}`;
        if (!STATE.aGroups) STATE.aGroups = {};
        if (!STATE.aGroups[key]) STATE.aGroups[key] = [];
        if (!STATE.aGroups[key].includes(newStudent.id)) {
          STATE.aGroups[key].push(newStudent.id);
        }
      }

      // 5. Enregistrer dans l'historique
      if (!STATE.history) STATE.history = [];
      STATE.history.push({
        type: 'add',
        eleveId: newStudent.id,
        eleveName: `${newStudent.nom} ${newStudent.prenom}`,
        classe: classId,
        timestamp: new Date().toISOString()
      });

      // 6. Mettre √† jour les stats
      App.UI.updateAllColumnStats();

      // 7. Mettre √† jour les stats avanc√©es
      if (typeof updateAdvancedStats === 'function') {
        setTimeout(() => updateAdvancedStats(), 150);
      }

      // 8. Marquer comme modifi√© pour auto-save
      STATE.has_user_action = true;

      // 9. Sauvegarde imm√©diate si mode CACHE
      if (STATE.currentMode === 'CACHE' && typeof App.Data?.saveImmediateCache === 'function') {
        setTimeout(() => App.Data.saveImmediateCache(), 200);
      }

      console.log(`[App.UI.addStudentToClass] ‚úÖ √âl√®ve ajout√© avec succ√®s`);
      return true;
    }
  },

  // ============================================
  // MODULE DRAG & DROP
  // ============================================
  DragDrop: {
    // Ces fonctions seront migr√©es depuis le code existant
    // Pour l'instant, on laisse des placeholders qui appelleront les fonctions globales
  },

  // ============================================
  // MODULE VIEWS - Gestion des vues
  // ============================================
  Views: {
    // Placeholders pour les fonctions de vue
  },

  // ============================================
  // MODULE HISTORY - Historique et undo/redo
  // ============================================
  History: {
    /**
     * Met √† jour l'√©tat des boutons undo/redo
     */
    updateUndoRedoButtons() {
      const btnUndo = document.getElementById('btnUndo');
      const btnRedo = document.getElementById('btnRedo');

      if (btnUndo) btnUndo.disabled = STATE.history.length === 0;
      if (btnRedo) btnRedo.disabled = STATE.future.length === 0;
    },

    /**
     * Annule la derni√®re action
     */
    undo() {
      if (STATE.history.length === 0) return;

      const action = STATE.history.pop();
      STATE.future.push(action);

      // Retirer aussi de historyTimeline
      if (STATE.historyTimeline.length > 0) {
        STATE.historyTimeline.pop();
      }

      if (action.type === 'move') {
        const card = document.querySelector(`.student-card[data-id="${action.eleveId}"]`);
        const oldZone = document.querySelector(`.droppable-zone[data-classe="${action.oldClasse}"]`);

        if (card && oldZone) {
          // Ins√©rer √† l'ancienne position si possible
          if (action.oldIndex < oldZone.children.length) {
            oldZone.insertBefore(card, oldZone.children[action.oldIndex]);
          } else {
            oldZone.appendChild(card);
          }
        }
      } else if (action.type === 'swap') {
        if (typeof performSwap === 'function') {
          performSwap(action.id2, action.id1); // Swap inverse
          STATE.history.pop(); // Enlever le swap ajout√© par performSwap
        }
      }

      App.History.updateUndoRedoButtons();
      App.UI.updateAllColumnStats();

      // Mettre √† jour le panneau historique
      if (typeof updateHistoryPanel === 'function') {
        updateHistoryPanel();
      }

      // Mise √† jour intelligente des statistiques
      setTimeout(() => App.Stats.updateAdvancedStats(), 150);

      // Sauvegarde apr√®s undo
      if (STATE.currentMode === 'CACHE') {
        App.Data.saveImmediateCache();
      }
    },

    /**
     * Refait la derni√®re action annul√©e
     */
    redo() {
      if (STATE.future.length === 0) return;

      const action = STATE.future.pop();

      if (action.type === 'move') {
        const card = document.querySelector(`.student-card[data-id="${action.eleveId}"]`);
        const newZone = document.querySelector(`.droppable-zone[data-classe="${action.newClasse}"]`);

        if (card && newZone) {
          if (action.newIndex < newZone.children.length) {
            newZone.insertBefore(card, newZone.children[action.newIndex]);
          } else {
            newZone.appendChild(card);
          }
        }
        STATE.history.push(action);
        // Ajouter aussi √† historyTimeline pour le panneau historique
        STATE.historyTimeline.push(action);
      } else if (action.type === 'swap') {
        if (typeof performSwap === 'function') {
          performSwap(action.id1, action.id2);
        }
      }

      App.History.updateUndoRedoButtons();
      App.UI.updateAllColumnStats();

      // Mettre √† jour le panneau historique
      if (typeof updateHistoryPanel === 'function') {
        updateHistoryPanel();
      }

      // Mise √† jour intelligente des statistiques
      setTimeout(() => App.Stats.updateAdvancedStats(), 150);

      // Sauvegarde apr√®s redo
      if (STATE.currentMode === 'CACHE') {
        App.Data.saveImmediateCache();
      }
    }
  },

  // ============================================
  // MODULE STATS - Statistiques
  // ============================================
  Stats: {
    /**
     * Met √† jour les statistiques avanc√©es
     */
    updateAdvancedStats() {
      console.log('üìä App.Stats.updateAdvancedStats',
                  'chartsReady=', window.areChartsReady?.(),
                  'typeof updateCharts =', typeof updateCharts);

      const panel = document.getElementById('statsPanel');
      if (!panel || panel.classList.contains('translate-x-full')) {
        console.log('üìä Panneau ferm√©, skip mise √† jour');
        return;
      }

      if (typeof updateNewMetrics === 'function') {
        console.log('üî¢ updateNewMetrics lanc√©');
        updateNewMetrics();
      }

      console.log('üìä Appel de updateCharts()...');
      if (typeof updateCharts === 'function') {
        updateCharts();
      }
      console.log('üìä updateCharts() termin√©');

      if (typeof updateLV2Details === 'function') {
        updateLV2Details();
      }
    }
  },

  // ============================================
  // MODULE CONSTRAINTS - Validation
  // ============================================
  Constraints: {
    // Placeholders pour les fonctions de contraintes
  },

  // ============================================
  // MODULE DATA - Import/Export
  // ============================================
  Data: {
    /**
     * Exporte la disposition actuelle
     * @returns {Object} Disposition des classes
     */
    exportDisposition() {
      const result = {};
      document.querySelectorAll('.class-column').forEach(column => {
        const classe = column.querySelector('.classe-name').textContent;
        const ids = Array.from(column.querySelectorAll('.student-card')).map(card => card.dataset.id);
        result[classe] = ids;
      });
      return result;
    },

    /**
     * Sauvegarde imm√©diate dans le cache
     */
    async saveImmediateCache() {
      try {
        // 1. Ne rien faire si l'utilisateur n'a rien boug√©
        if (!STATE.has_user_action) {
          console.debug('‚è≠Ô∏è Auto-save saut√© (aucune action)');
          return;
        }

        const disposition = App.Data.exportDisposition();
        const cacheData = {
          date: new Date().toISOString(),
          disposition: disposition,
          mode: STATE.currentMode
        };

        // Sauvegarde locale
        localStorage.setItem('cache-data', JSON.stringify(cacheData));

        if (typeof gsRun === 'function') {
          try {
            const result = await gsRun('saveCacheData', cacheData);

            if (result && result.success) {
              console.log('üíæ Sauvegarde automatique CACHE r√©ussie');

              // 2. Apr√®s succ√®s ‚Üí on remet le flag √† false,
              //    on horodate, on met √† jour le badge
              STATE.has_user_action = false;
              STATE.last_save_ts = Date.now();

              if (typeof updateSaveBadge === 'function') {
                updateSaveBadge(true);
              }
            } else {
              console.warn('‚ö†Ô∏è Sauvegarde CACHE √©chou√©e:', result?.error);
              if (typeof updateSaveBadge === 'function') {
                updateSaveBadge(false);
              }
            }
          } catch (error) {
            console.error('‚ùå Erreur sauvegarde CACHE:', error);
            if (typeof updateSaveBadge === 'function') {
              updateSaveBadge(false);
            }
          }
        }
      } catch (error) {
        console.error('‚ùå Erreur dans saveImmediateCache:', error);
      }
    }
  },

  // ============================================
  // MODULE SEARCH - Recherche et filtres
  // ============================================
  Search: {
    // Placeholders pour les fonctions de recherche
  },

  // ============================================
  // MODULE UTILS - Utilitaires
  // ============================================
  Utils: {
    /**
     * V√©rifie si un nom de classe est une vraie classe (pas un groupe)
     * @param {string} className - Nom de la classe
     * @returns {boolean}
     */
    isRealClass(className) {
      const groupPatterns = [
        /^level_/i,
        /^grp_/i,
        /^groupe_/i,
        /^group_/i,
        /_Groupe\d*$/i,
        /^ESP_/i,
        /^ITA_/i,
        /^ALL_/i,
        /^LATIN_/i,
        /^MATH_/i,
        /^FR_/i,
        /^Niveau/i
      ];

      for (const pattern of groupPatterns) {
        if (pattern.test(className)) {
          return false;
        }
      }

      const classPattern = /^\d+¬∞\d+$/;
      return classPattern.test(className);
    }
  },

  // ============================================
  // MODULE INIT - Initialisation
  // ============================================
  Init: {
    // Placeholders pour l'initialisation
  }
};

// ============================================
// FONCTIONS WRAPPER POUR COMPATIBILIT√â
// ============================================
/**
 * Ces fonctions wrapper assurent la compatibilit√© avec les event handlers HTML existants
 * et le code legacy. Elles d√©l√®guent simplement vers les modules appropri√©s.
 */

// Wrapper pour toast
function toast(message, type = 'info') {
  return App.UI.toast(message, type);
}

// Wrapper pour updateColumnStats
function updateColumnStats(column, eleves) {
  return App.UI.updateColumnStats(column, eleves);
}

// Wrapper pour updateAllColumnStats
function updateAllColumnStats() {
  return App.UI.updateAllColumnStats();
}

// Wrapper pour adjustSimpleNamesFontSize
function adjustSimpleNamesFontSize(dropZone) {
  return App.UI.adjustSimpleNamesFontSize(dropZone);
}

// Wrapper pour isRealClass
function isRealClass(className) {
  return App.Utils.isRealClass(className);
}

// Wrapper pour exportDisposition
function exportDisposition() {
  return App.Data.exportDisposition();
}

// Wrapper pour saveImmediateCache
async function saveImmediateCache() {
  return App.Data.saveImmediateCache();
}

// Wrapper pour updateUndoRedoButtons
function updateUndoRedoButtons() {
  return App.History.updateUndoRedoButtons();
}

// Wrapper pour updateAdvancedStats
function updateAdvancedStats() {
  return App.Stats.updateAdvancedStats();
}

// Wrapper pour undo
function undo() {
  return App.History.undo();
}

// Wrapper pour redo
function redo() {
  return App.History.redo();
}

// Wrapper pour showSpinner/hideSpinner
function showSpinner() {
  return App.UI.showSpinner();
}

function hideSpinner() {
  return App.UI.hideSpinner();
}

// Wrapper pour addStudentToClass (appel√© par le module NewStudentModule)
function addStudentToClass(newStudent, classId) {
  return App.UI.addStudentToClass(newStudent, classId);
}

// =======================================================
// FONCTIONS GLOBALES (Legacy - √Ä migrer progressivement)
// =======================================================
// showSpinner() et hideSpinner() migr√©s vers App.UI






// ========== AJUSTEMENT TAILLE DES CARTES ==========
function resizeCards(){
  document.querySelectorAll('.student-card').forEach(card=>{
    const w = card.offsetWidth;
    // Toujours retirer toutes les classes
    card.classList.remove('card-sm','card-md','card-lg');
    // Puis ajouter la classe appropri√©e
    if     (w > 320) card.classList.add('card-lg');
    else if(w > 240) card.classList.add('card-md');
    else             card.classList.add('card-sm');
  });
}






// ========== FONCTION D'OUVERTURE DU MODAL DE D√âMARRAGE ==========
// Fonction d√©j√† d√©finie plus haut

// =======================================================
// INITIALISATION QUAND LE DOM EST PR√äT
// =======================================================
window.addEventListener('DOMContentLoaded', (event) => {
  console.log("DOM pr√™t. Tous les scripts peuvent s'ex√©cuter.");

  // V√©rifier si une sauvegarde CACHE existe
  checkCache();
  
  // Appliquer les pr√©f√©rences de lisibilit√© sauvegard√©es
  setTimeout(() => {
    if (window.applyLisibilitePreferences) {
      window.applyLisibilitePreferences();
    }
  }, 500);

  // GESTION DU MODAL DE D√âMARRAGE
  const startupModal = document.getElementById('startupModal');
  const closeStartupModalBtn = document.getElementById('closeStartupModal');

  if (closeStartupModalBtn && startupModal) {
    closeStartupModalBtn.addEventListener('click', () => {
      startupModal.classList.add('hidden');
    });

    // ‚ùå SUPPRIM√â : Gestionnaire dupliqu√© qui causait la double demande de mot de passe
    // La protection par mot de passe est g√©r√©e plus bas (ligne ~4287)
  }

  // =======================================================
  // 1. GESTION DES OPTIONS DE LISIBILIT√â - ANCIEN PANNEAU PLEIN √âCRAN (D√âSACTIV√â)
  // =======================================================
  // ‚ö†Ô∏è CE BLOC EST COMPL√àTEMENT D√âSACTIV√â
  // L'ancien panneau de lisibilit√© plein √©cran (#lisibilite-panel) a √©t√© supprim√© du HTML
  // La gestion de la lisibilit√© est maintenant dans le menu dropdown "R√©gler" (#dropdownRegler)
  // Voir le bloc "1.5 GESTION DU MENU R√âGLER (DROPDOWN)" plus bas
  /*
  (function() {
    const toggleBtn = document.getElementById('btnLisibilite');
    const panel = document.getElementById('lisibilite-panel');
    const closeBtn = document.getElementById('close-lisibilite-panel');
    const resetBtn = document.getElementById('reset-lisibilite');
    const fullscreenBtn = document.getElementById('fullscreen-mode');

    // On v√©rifie que les √©l√©ments critiques existent avant de continuer
    if (!toggleBtn || !panel || !closeBtn) {
        console.warn('Certains √©l√©ments du panneau de lisibilit√© sont introuvables. Fonctionnalit√© d√©sactiv√©e.');
        return;
    }
  
  // √âtat des options de lisibilit√©
  let lisibiliteState = {
    size: 'medium',
    style: 'normal',
    contrast: 'normal',
    symbols: 'colors',
    showPrenoms: true,
    showClasse: true,
    showScores: true
  };
  
  // Charger les pr√©f√©rences sauvegard√©es
  function loadPreferences() {
    const saved = localStorage.getItem('lisibilite-preferences');
    if (saved) {
      lisibiliteState = { ...lisibiliteState, ...JSON.parse(saved) };
      applyPreferences();
    }
  }
  
  // Sauvegarder les pr√©f√©rences
  function savePreferences() {
    localStorage.setItem('lisibilite-preferences', JSON.stringify(lisibiliteState));
  }
  
  // Appliquer les pr√©f√©rences aux noms (vue normale ET simplifi√©e)
  function applyPreferences() {
    // Vue normale
    const names = document.querySelectorAll('.student-fullname');
    names.forEach(name => {
      name.classList.remove('size-small', 'size-medium', 'size-large', 'size-xlarge');
      name.classList.remove('style-normal', 'style-bold', 'style-highlight', 'style-outline');
      name.classList.add(`size-${lisibiliteState.size}`);
      name.classList.add(`style-${lisibiliteState.style}`);
      name.style.color = '';
      name.style.background = '';
      name.style.fontWeight = '';
      // Contraste √©lev√©/max : forcer noir/blanc, sinon laisser couleur par d√©faut
      if (lisibiliteState.contrast === 'high' || lisibiliteState.contrast === 'max') {
        name.style.color = '#000';
        name.style.textShadow = lisibiliteState.contrast === 'max'
          ? '2px 2px 0 #fff, -2px -2px 0 #fff, 2px -2px 0 #fff, -2px 2px 0 #fff'
          : '1px 1px 0 #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff';
        name.style.fontWeight = '900';
      } else {
        name.style.color = '';
        name.style.textShadow = '';
      }
      // Style highlight/outline
      if (lisibiliteState.style === 'highlight') {
        name.style.background = '#fef3c7';
      }
      if (lisibiliteState.style === 'outline') {
        name.style.border = '2px solid #3b82f6';
        name.style.borderRadius = '3px';
      } else {
        name.style.border = '';
        name.style.borderRadius = '';
      }
      // Symboles/genres
      const card = name.closest('.student-card');
      if (card) {
        card.classList.remove('symbols-colors', 'symbols-symbols', 'symbols-both');
        card.classList.add(`symbols-${lisibiliteState.symbols}`);
        // Fond blanc forc√© si symboles ou contraste, sinon couleur par d√©faut
        if (lisibiliteState.symbols !== 'colors' || lisibiliteState.contrast !== 'normal') {
          card.style.background = '#fff';
          card.style.borderColor = '#bbb';
        } else {
          card.style.background = '';
          card.style.borderColor = '';
        }
      }
    });
    // Vue simplifi√©e
    const simpleNames = document.querySelectorAll('.student-simple-name');
    simpleNames.forEach(name => {
      name.style.fontSize =
        lisibiliteState.size === 'small' ? '0.75rem' :
        lisibiliteState.size === 'medium' ? '0.95rem' :
        lisibiliteState.size === 'large' ? '1.15rem' :
        '1.35rem';
      name.style.fontWeight = lisibiliteState.style === 'bold' ? '700' :
        lisibiliteState.style === 'highlight' ? '700' :
        lisibiliteState.style === 'outline' ? '700' :
        '600';
      name.style.background = lisibiliteState.style === 'highlight' ? '#fef3c7' : '';
      name.style.border = lisibiliteState.style === 'outline' ? '2px solid #3b82f6' : '';
      name.style.borderRadius = lisibiliteState.style === 'outline' ? '3px' : '';
      // En mode simplifi√©, toujours fond blanc et police noire
      name.style.color = '#000';
      name.style.textShadow = '';
      name.style.fontWeight = '900';
      const card = name.closest('.student-card');
      if (card) {
        card.classList.remove('symbols-colors', 'symbols-symbols', 'symbols-both');
        card.classList.add(`symbols-${lisibiliteState.symbols}`);
        card.style.background = '#fff';
        card.style.borderColor = '#bbb';
      }
    });
    // Appliquer le contraste au body
    document.body.classList.remove('contrast-high', 'contrast-max');
    if (lisibiliteState.contrast !== 'normal') {
      document.body.classList.add(`contrast-${lisibiliteState.contrast}`);
    }
    // Appliquer les symboles aux cartes (vue normale)
    const cards = document.querySelectorAll('.student-card');
    cards.forEach(card => {
      card.classList.remove('symbols-colors', 'symbols-symbols', 'symbols-both');
      card.classList.add(`symbols-${lisibiliteState.symbols}`);
      // Fond blanc forc√© si symboles ou contraste, sinon couleur par d√©faut
      if (lisibiliteState.symbols !== 'colors' || lisibiliteState.contrast !== 'normal') {
        card.style.background = '#fff';
        card.style.borderColor = '#bbb';
      } else {
        card.style.background = '';
        card.style.borderColor = '';
      }
    });

    // G√©rer l'affichage des pr√©noms (nom seul si d√©coch√©e)
    const allNames = document.querySelectorAll('.student-fullname, .student-simple-name');
    allNames.forEach(nameEl => {
      const card = nameEl.closest('.student-card');
      if (!card || !card.dataset.id) return;

      const eleve = STATE.students[card.dataset.id];
      if (!eleve) return;

      if (lisibiliteState.showPrenoms) {
        // Afficher nom + pr√©nom SIMPLIFI√â VERSION 4.0
        nameEl.textContent = simplifierNomComplet(eleve.nom, eleve.prenom);
      } else {
        // Afficher nom uniquement
        nameEl.textContent = eleve.nom;
      }
    });

    // G√©rer l'affichage de la classe d'origine
    const sourceElements = document.querySelectorAll('.source-class');
    sourceElements.forEach(el => {
      el.style.display = lisibiliteState.showClasse ? '' : 'none';
    });

    // G√©rer l'affichage des badges de scores
    const scoresElements = document.querySelectorAll('.scores');
    scoresElements.forEach(el => {
      el.style.display = lisibiliteState.showScores ? '' : 'none';
    });

    updateActiveButtons();
    updateCheckboxes();
  }
  
  // Mettre √† jour les boutons actifs
  function updateActiveButtons() {
    document.querySelectorAll('.btn-lisibilite').forEach(btn => {
      btn.classList.remove('active');
    });
    
    document.querySelectorAll(`[data-size="${lisibiliteState.size}"]`).forEach(btn => btn.classList.add('active'));
    document.querySelectorAll(`[data-style="${lisibiliteState.style}"]`).forEach(btn => btn.classList.add('active'));
    document.querySelectorAll(`[data-contrast="${lisibiliteState.contrast}"]`).forEach(btn => btn.classList.add('active'));
    document.querySelectorAll(`[data-symbols="${lisibiliteState.symbols}"]`).forEach(btn => btn.classList.add('active'));
  }

  // Mettre √† jour les checkboxes
  function updateCheckboxes() {
    const prenomsCheckbox = document.getElementById('toggle-prenoms');
    const classeCheckbox = document.getElementById('toggle-classe');
    const scoresCheckbox = document.getElementById('toggle-scores');

    if (prenomsCheckbox) prenomsCheckbox.checked = lisibiliteState.showPrenoms;
    if (classeCheckbox) classeCheckbox.checked = lisibiliteState.showClasse;
    if (scoresCheckbox) scoresCheckbox.checked = lisibiliteState.showScores;
  }

  // Gestion des clics sur les boutons d'options
  document.addEventListener('click', (e) => {
    if (e.target.classList.contains('btn-lisibilite')) {
      const type = e.target.dataset.size || e.target.dataset.style || e.target.dataset.contrast || e.target.dataset.symbols;
      const category = e.target.dataset.size ? 'size' : e.target.dataset.style ? 'style' : e.target.dataset.contrast ? 'contrast' : 'symbols';
      
      lisibiliteState[category] = type;
      applyPreferences();
      savePreferences();
    }
  });

  // Gestion des checkboxes pour affichage
  const prenomsCheckbox = document.getElementById('toggle-prenoms');
  const classeCheckbox = document.getElementById('toggle-classe');
  const scoresCheckbox = document.getElementById('toggle-scores');

  if (prenomsCheckbox) {
    prenomsCheckbox.addEventListener('change', (e) => {
      lisibiliteState.showPrenoms = e.target.checked;
      applyPreferences();
      savePreferences();
    });
  }

  if (classeCheckbox) {
    classeCheckbox.addEventListener('change', (e) => {
      lisibiliteState.showClasse = e.target.checked;
      applyPreferences();
      savePreferences();
    });
  }

  if (scoresCheckbox) {
    scoresCheckbox.addEventListener('change', (e) => {
      lisibiliteState.showScores = e.target.checked;
      applyPreferences();
      savePreferences();
    });
  }

  // Gestion de l'ouverture/fermeture du panneau
  if (toggleBtn && panel && closeBtn) {
    toggleBtn.addEventListener('click', () => {
      panel.classList.remove('-translate-y-full');
      panel.classList.add('translate-y-0');
    });
    closeBtn.addEventListener('click', () => {
      panel.classList.remove('translate-y-0');
      panel.classList.add('-translate-y-full');
    });
  }
  
  // R√©initialiser les options
  if (resetBtn) {
    resetBtn.addEventListener('click', () => {
      lisibiliteState = {
        size: 'medium',
        style: 'normal',
        contrast: 'normal',
        symbols: 'colors',
        showPrenoms: true,
        showClasse: true,
        showScores: true
      };
      applyPreferences();
      savePreferences();
    });
  }
  
  // Mode plein √©cran
  if (fullscreenBtn) {
    fullscreenBtn.addEventListener('click', async () => {
      try {
        if (document.fullscreenElement) {
          await document.exitFullscreen();
        } else {
          await document.documentElement.requestFullscreen();
        }
      } catch (error) {
        console.error('Erreur mode plein √©cran:', error);
        toast('Erreur mode plein √©cran. V√©rifiez les permissions du navigateur.', 'error');
      }
    });
    
    // Gestion des √©v√©nements fullscreen pour mettre √† jour le bouton
    document.addEventListener('fullscreenchange', () => {
      if (document.fullscreenElement) {
        fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i> Quitter plein √©cran';
        document.body.classList.add('fullscreen-mode');
      } else {
        fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i> Mode plein √©cran';
        document.body.classList.remove('fullscreen-mode');
      }
    });
  }
  
  // Charger les pr√©f√©rences au d√©marrage
  loadPreferences();
  
  // Appliquer les pr√©f√©rences quand de nouveaux √©l√®ves sont charg√©s
  const originalRenderBoard = window.renderBoard;
  if (originalRenderBoard) {
    window.renderBoard = function(...args) {
      const result = originalRenderBoard.apply(this, args);
      setTimeout(applyPreferences, 100); // Appliquer apr√®s le rendu
      return result;
    };
  }

  // Appliquer les pr√©f√©rences apr√®s chaque bascule de vue
  window.applyLisibilitePreferences = applyPreferences;
  })();
  */
  // FIN DU BLOC ANCIEN PANNEAU DE LISIBILIT√â (D√âSACTIV√â)

  // =======================================================
  // 1.5 GESTION DU MENU R√âGLER (DROPDOWN) - ANCIEN BLOC D√âSACTIV√â
  // =======================================================
  // ‚ö†Ô∏è CE BLOC EST D√âSACTIV√â - La gestion du menu R√©gler est maintenant
  // dans le bloc "1.5 GESTION DU MENU R√âGLER (DROPDOWN)" plus bas
  // avec animations et fermeture s√©lective des autres dropdowns
  /*
  (function() {
    const btnRegler = document.getElementById('btnRegler');
    const dropdown = document.getElementById('dropdownRegler');
    
    if (!btnRegler || !dropdown) {
      console.warn('Menu R√©gler non trouv√©');
      return;
    }
    
    // Toggle dropdown avec positionnement dynamique
    btnRegler.addEventListener('click', (e) => {
      e.stopPropagation();
      
      // Positionner le dropdown sous le bouton
      const rect = btnRegler.getBoundingClientRect();
      dropdown.style.top = `${rect.bottom + 8}px`;
      dropdown.style.left = `${rect.left}px`;
      
      dropdown.classList.toggle('hidden');
    });
    
    // Emp√™cher la fermeture au clic interne
    dropdown.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    
    // Fermer au clic ext√©rieur
    document.addEventListener('click', (e) => {
      if (!dropdown.contains(e.target) && e.target !== btnRegler) {
        dropdown.classList.add('hidden');
      }
    });
    
    // Fermer avec la touche √âchap (accessibilit√© clavier)
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && !dropdown.classList.contains('hidden')) {
        dropdown.classList.add('hidden');
        console.log('‚å®Ô∏è Menu R√©gler ferm√© via √âchap');
      }
    });
    
    // Fonction toggle section accord√©on
    window.toggleSection = function(sectionId) {
      const section = document.getElementById(sectionId);
      const icon = document.getElementById(sectionId + 'Icon');
      
      if (section && icon) {
        section.classList.toggle('hidden');
        icon.classList.toggle('rotate-180');
      }
    };
    
    // Gestion des radio buttons avec style visuel
    const radioLabels = dropdown.querySelectorAll('label[data-size], label[data-style], label[data-contrast], label[data-gender]');
    radioLabels.forEach(label => {
      label.addEventListener('click', function() {
        const input = this.querySelector('input[type="radio"]');
        if (!input) return;
        
        const name = input.name;
        
        // Retirer le style actif de tous les labels du m√™me groupe
        dropdown.querySelectorAll(`input[name="${name}"]`).forEach(radio => {
          const parentLabel = radio.closest('label');
          if (parentLabel) {
            parentLabel.classList.remove('bg-blue-50', 'border-blue-500');
            const span = parentLabel.querySelector('span');
            if (span) span.classList.remove('text-blue-700');
          }
        });
        
        // Ajouter le style actif √† celui-ci
        this.classList.add('bg-blue-50', 'border-blue-500');
        const span = this.querySelector('span');
        if (span) span.classList.add('text-blue-700');
        
        // Cocher le radio
        input.checked = true;
        
        // Appliquer les changements
        applyReglerSettings();
      });
    });
    
    // Fonction pour appliquer les pr√©f√©rences de lisibilit√©
    window.applyLisibilitePreferences = function() {
      const saved = localStorage.getItem('lisibilite-preferences');
      if (!saved) return;
      
      const prefs = JSON.parse(saved);
      
      // Appliquer la taille des noms
      document.querySelectorAll('.student-card').forEach(card => {
        card.classList.remove('font-size-small', 'font-size-medium', 'font-size-large', 'font-size-xlarge');
        card.classList.add(`font-size-${prefs.size || 'medium'}`);
      });
      
      // Appliquer le style
      document.querySelectorAll('.student-card').forEach(card => {
        card.classList.remove('font-style-normal', 'font-style-bold', 'font-style-highlight', 'font-style-outline');
        card.classList.add(`font-style-${prefs.style || 'normal'}`);
      });
      
      // Appliquer le contraste
      document.body.classList.remove('contrast-normal', 'contrast-high', 'contrast-max');
      document.body.classList.add(`contrast-${prefs.contrast || 'normal'}`);
      
      // Appliquer l'affichage des genres
      document.querySelectorAll('.student-card').forEach(card => {
        card.classList.remove('gender-colors', 'gender-symbols', 'gender-both');
        card.classList.add(`gender-${prefs.symbols || 'colors'}`);
      });
      
      // Afficher/masquer les pr√©noms
      document.querySelectorAll('.student-card .student-fullname').forEach(el => {
        el.style.display = prefs.showPrenoms ? '' : 'none';
      });
      
      // Afficher/masquer la classe d'origine
      document.querySelectorAll('.student-card .source-class').forEach(el => {
        el.style.display = prefs.showClasse ? '' : 'none';
      });
      
      // Afficher/masquer les scores
      document.querySelectorAll('.student-card .scores').forEach(el => {
        el.style.display = prefs.showScores ? '' : 'none';
      });
    };
    
    // Appliquer les r√©glages - UTILISE LA FONCTION EXISTANTE
    function applyReglerSettings() {
      // R√©cup√©rer les valeurs
      const fontSize = dropdown.querySelector('input[name="fontSize"]:checked')?.value || 'medium';
      const fontStyle = dropdown.querySelector('input[name="fontStyle"]:checked')?.value || 'normal';
      const contrast = dropdown.querySelector('input[name="contrast"]:checked')?.value || 'normal';
      const genderDisplay = dropdown.querySelector('input[name="genderDisplay"]:checked')?.value || 'colors';
      const showPrenoms = document.getElementById('showPrenoms')?.checked ?? true;
      const showClasse = document.getElementById('showClasseOrigine')?.checked ?? true;
      const showScores = document.getElementById('showScores')?.checked ?? true;
      
      // Sauvegarder les pr√©f√©rences
      const lisibiliteState = {
        size: fontSize,
        style: fontStyle,
        contrast: contrast,
        symbols: genderDisplay,
        showPrenoms: showPrenoms,
        showClasse: showClasse,
        showScores: showScores
      };
      localStorage.setItem('lisibilite-preferences', JSON.stringify(lisibiliteState));
      
      // Appliquer via la fonction existante
      if (window.applyLisibilitePreferences) {
        window.applyLisibilitePreferences();
      }
    }
    
    // Connecter les checkboxes Afficher
    ['showPrenoms', 'showClasseOrigine', 'showScores'].forEach(id => {
      const checkbox = document.getElementById(id);
      if (checkbox) {
        checkbox.addEventListener('change', applyReglerSettings);
      }
    });
    
    // Pr√©r√©glages
    document.getElementById('presetProjection')?.addEventListener('click', () => {
      // Mode Projection : M, Gras, Symbole, Fond blanc
      setRadioValue('fontSize', 'medium');
      setRadioValue('fontStyle', 'bold');
      setRadioValue('genderDisplay', 'symbols');
      const whiteBackground = document.getElementById('whiteBackground');
      if (whiteBackground) {
        whiteBackground.checked = true;
        whiteBackground.dispatchEvent(new Event('change'));
      }
      applyReglerSettings();
      toast('üìΩÔ∏è Mode Projection activ√©', 'success');
    });
    
    document.getElementById('presetImpression')?.addEventListener('click', () => {
      // Mode Impression : S, Normal, Couleurs
      setRadioValue('fontSize', 'small');
      setRadioValue('fontStyle', 'normal');
      setRadioValue('contrast', 'normal');
      setRadioValue('genderDisplay', 'colors');
      const whiteBackground = document.getElementById('whiteBackground');
      if (whiteBackground) {
        whiteBackground.checked = false;
        whiteBackground.dispatchEvent(new Event('change'));
      }
      applyReglerSettings();
      toast('üñ®Ô∏è Mode Impression activ√©', 'success');
    });
    
    document.getElementById('presetAccessibilite')?.addEventListener('click', () => {
      // Mode Accessibilit√© : XL, Gras, Contraste Max, Symboles
      setRadioValue('fontSize', 'xlarge');
      setRadioValue('fontStyle', 'bold');
      setRadioValue('contrast', 'max');
      setRadioValue('genderDisplay', 'both');
      applyReglerSettings();
      toast('‚ôø Mode Accessibilit√© activ√©', 'success');
    });
    
    // R√©initialiser
    document.getElementById('btnResetReglages')?.addEventListener('click', () => {
      setRadioValue('fontSize', 'medium');
      setRadioValue('fontStyle', 'normal');
      setRadioValue('contrast', 'normal');
      setRadioValue('genderDisplay', 'colors');
      
      const showGenderBadges = document.getElementById('showGenderBadges');
      if (showGenderBadges) {
        showGenderBadges.checked = false;
        showGenderBadges.dispatchEvent(new Event('change'));
      }
      
      const whiteBackground = document.getElementById('whiteBackground');
      if (whiteBackground) {
        whiteBackground.checked = false;
        whiteBackground.dispatchEvent(new Event('change'));
      }
      
      document.getElementById('showPrenoms').checked = true;
      document.getElementById('showClasseOrigine').checked = true;
      document.getElementById('showScores').checked = true;
      
      applyReglerSettings();
      toast('üîÑ R√©glages r√©initialis√©s', 'info');
    });
    
    // Plein √©cran
    document.getElementById('btnPleinEcran')?.addEventListener('click', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
        toast('‚õ∂ Mode plein √©cran activ√©', 'info');
      } else {
        document.exitFullscreen();
        toast('‚õ∂ Mode plein √©cran d√©sactiv√©', 'info');
      }
    });
    
    // Mode sombre
    document.getElementById('btnModeSombre')?.addEventListener('click', (e) => {
      e.stopPropagation();
      document.body.classList.toggle('dark-mode');
      const isDark = document.body.classList.contains('dark-mode');
      localStorage.setItem('darkMode', isDark);
      toast(isDark ? 'üåô Mode sombre activ√©' : '‚òÄÔ∏è Mode clair activ√©', 'info');
    });
    
    // Zoom cartes
    document.getElementById('btnZoomCartes')?.addEventListener('click', () => {
      const cards = document.querySelectorAll('.student-card');
      const isZoomed = cards[0]?.style.transform === 'scale(1.1)';
      cards.forEach(card => {
        card.style.transform = isZoomed ? '' : 'scale(1.1)';
        card.style.transition = 'transform 0.2s';
      });
      toast(isZoomed ? 'üîç Zoom d√©sactiv√©' : 'üîç Zoom activ√©', 'info');
    });
    
    // Helper pour d√©finir un radio
    function setRadioValue(name, value) {
      const radio = dropdown.querySelector(`input[name="${name}"][value="${value}"]`);
      if (radio) {
        radio.checked = true;
        const label = radio.closest('label');
        if (label) {
          // Retirer actif des autres
          dropdown.querySelectorAll(`input[name="${name}"]`).forEach(r => {
            const l = r.closest('label');
            if (l) {
              l.classList.remove('bg-blue-50', 'border-blue-500');
              const s = l.querySelector('span');
              if (s) s.classList.remove('text-blue-700');
            }
          });
          // Ajouter actif √† celui-ci
          label.classList.add('bg-blue-50', 'border-blue-500');
          const span = label.querySelector('span');
          if (span) span.classList.add('text-blue-700');
        }
      }
    }
    
    // Charger les pr√©f√©rences au d√©marrage
    const saved = localStorage.getItem('lisibilite-preferences');
    if (saved) {
      const prefs = JSON.parse(saved);
      setRadioValue('fontSize', prefs.size || 'medium');
      setRadioValue('fontStyle', prefs.style || 'normal');
      setRadioValue('contrast', prefs.contrast || 'normal');
      setRadioValue('genderDisplay', prefs.symbols || 'colors');
    }
    
    // Charger mode sombre (d√©sactiv√© par d√©faut)
    // Le mode sombre ne doit s'activer que si explicitement demand√©
    // if (localStorage.getItem('darkMode') === 'true') {
    //   document.body.classList.add('dark-mode');
    // }
    
    console.log('‚úÖ Menu R√©gler (dropdown) initialis√©');
  })();
  */

  // =======================================================
  // 1.4.5 FONCTION GLOBALE POUR ANIMATIONS DES DROPDOWNS
  // =======================================================
  window.toggleDropdown = function(dropdown, button) {
    if (!dropdown) return;
    
    const isHidden = dropdown.classList.contains('hidden');
    
    if (isHidden) {
      // Ouvrir avec animation
      dropdown.classList.remove('hidden');
      // Force reflow
      void dropdown.offsetWidth;
      requestAnimationFrame(() => {
        dropdown.classList.add('show');
      });
    } else {
      // Fermer avec animation
      dropdown.classList.remove('show');
      setTimeout(() => {
        dropdown.classList.add('hidden');
      }, 150); // Correspond √† la dur√©e de transition CSS
    }
  };
  
  window.closeAllDropdowns = function() {
    const dropdowns = document.querySelectorAll('.dropdown-menu');
    dropdowns.forEach(dropdown => {
      dropdown.classList.remove('show');
      setTimeout(() => {
        dropdown.classList.add('hidden');
      }, 150);
    });
  };

  // =======================================================
  // 1.5 GESTION DU MENU R√âGLER (DROPDOWN)
  // =======================================================
  (function() {
    const btnRegler = document.getElementById('btnRegler');
    const dropdown = document.getElementById('dropdownRegler');
    
    if (!btnRegler || !dropdown) {
      console.warn('Menu R√©gler non trouv√©');
      return;
    }
    
    // Toggle dropdown avec positionnement dynamique et animation
    btnRegler.addEventListener('click', (e) => {
      e.stopPropagation();
      
      // Fermer tous les autres dropdowns (sauf celui-ci)
      document.querySelectorAll('.dropdown-menu').forEach(dd => {
        if (dd !== dropdown && !dd.classList.contains('hidden')) {
          dd.classList.remove('show');
          setTimeout(() => dd.classList.add('hidden'), 150);
        }
      });
      
      // Positionner le dropdown sous le bouton
      const rect = btnRegler.getBoundingClientRect();
      dropdown.style.top = `${rect.bottom + 8}px`;
      dropdown.style.left = `${rect.left}px`;
      
      // Toggle avec animation
      toggleDropdown(dropdown, btnRegler);
    });
    
    // Emp√™cher la fermeture au clic interne
    dropdown.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    
    // Fermer au clic ext√©rieur
    document.addEventListener('click', (e) => {
      if (!dropdown.contains(e.target) && e.target !== btnRegler) {
        dropdown.classList.remove('show');
        setTimeout(() => dropdown.classList.add('hidden'), 150);
      }
    });
    
    // === C√ÇBLAGE DES BOUTONS ===
    
    // 1. Mode Permutation (toggle)
    const btnSwapMainMenu = document.getElementById('btnSwapMainMenu');
    const swapModeIndicator = document.getElementById('swapModeIndicator');
    
    if (btnSwapMainMenu) {
      btnSwapMainMenu.addEventListener('click', () => {
        // Appeler la fonction existante de swap
        if (window.toggleSwapMode) {
          window.toggleSwapMode();
        } else {
          // Fallback si la fonction n'existe pas encore
          STATE.swapMode = !STATE.swapMode;
          swapModeIndicator.textContent = STATE.swapMode ? 'ON' : 'OFF';
          swapModeIndicator.classList.toggle('bg-green-500', STATE.swapMode);
          swapModeIndicator.classList.toggle('text-white', STATE.swapMode);
          swapModeIndicator.classList.toggle('bg-gray-200', !STATE.swapMode);
          swapModeIndicator.classList.toggle('text-gray-600', !STATE.swapMode);
          
          document.body.classList.toggle('swap-mode', STATE.swapMode);
          toast(STATE.swapMode ? '‚ÜîÔ∏è Mode Permutation activ√©' : '‚ÜîÔ∏è Mode Permutation d√©sactiv√©', 'info');
        }
      });
    }
    
    // 2. Annuler (Undo)
    const btnUndoMenu = document.getElementById('btnUndoMenu');
    const btnUndo = document.getElementById('btnUndo'); // Ancien bouton dans Param√®tres
    
    if (btnUndoMenu) {
      btnUndoMenu.addEventListener('click', () => {
        console.log('üîÑ Bouton Annuler cliqu√©, history.length=', STATE.history?.length);
        if (window.undo) {
          window.undo();
        } else if (App && App.History && App.History.undo) {
          App.History.undo();
        } else {
          toast('‚ö†Ô∏è Fonction Annuler non disponible', 'warning');
        }
      });
      
      // Synchroniser l'√©tat disabled avec l'ancien bouton OU directement avec STATE
      if (btnUndo) {
        const observer = new MutationObserver(() => {
          btnUndoMenu.disabled = btnUndo.disabled;
        });
        observer.observe(btnUndo, { attributes: true, attributeFilter: ['disabled'] });
      } else {
        // Mise √† jour directe si l'ancien bouton n'existe pas
        setInterval(() => {
          if (STATE && STATE.history) {
            btnUndoMenu.disabled = STATE.history.length === 0;
          }
        }, 500);
      }
    }
    
    // 3. R√©tablir (Redo)
    const btnRedoMenu = document.getElementById('btnRedoMenu');
    const btnRedo = document.getElementById('btnRedo'); // Ancien bouton dans Param√®tres
    
    if (btnRedoMenu) {
      btnRedoMenu.addEventListener('click', () => {
        console.log('üîÑ Bouton R√©tablir cliqu√©, future.length=', STATE.future?.length);
        if (window.redo) {
          window.redo();
        } else if (App && App.History && App.History.redo) {
          App.History.redo();
        } else {
          toast('‚ö†Ô∏è Fonction R√©tablir non disponible', 'warning');
        }
      });
      
      // Synchroniser l'√©tat disabled avec l'ancien bouton OU directement avec STATE
      if (btnRedo) {
        const observer = new MutationObserver(() => {
          btnRedoMenu.disabled = btnRedo.disabled;
        });
        observer.observe(btnRedo, { attributes: true, attributeFilter: ['disabled'] });
      } else {
        // Mise √† jour directe si l'ancien bouton n'existe pas
        setInterval(() => {
          if (STATE && STATE.future) {
            btnRedoMenu.disabled = STATE.future.length === 0;
          }
        }, 500);
      }
    }
    
    // 4. Historique
    const btnHistoryMenu = document.getElementById('btnHistoryMenu');
    
    if (btnHistoryMenu) {
      btnHistoryMenu.addEventListener('click', () => {
        if (window.toggleHistoryPanel) {
          window.toggleHistoryPanel();
        } else {
          toast('üìú Panneau Historique ouvert', 'info');
        }
        dropdown.classList.add('hidden'); // Fermer le menu
      });
    }
    
    // 5. Sources (ouvre le modal de d√©marrage)
    const btnSourcesMenu = document.getElementById('btnSourcesMenu');
    
    if (btnSourcesMenu) {
      btnSourcesMenu.addEventListener('click', () => {
        if (window.openStartupModal) {
          window.openStartupModal({ force: true });
        } else {
          toast('‚ö†Ô∏è Modal Sources non disponible', 'warning');
        }
        dropdown.classList.add('hidden'); // Fermer le menu
      });
    }
    
    // === C√ÇBLAGE DES R√âGLAGES DE LISIBILIT√â ===
    
    // Fonction pour appliquer les r√©glages
    function applyReglerSettings() {
      const fontSize = dropdown.querySelector('input[name="fontSize"]:checked')?.value || 'medium';
      const fontStyle = dropdown.querySelector('input[name="fontStyle"]:checked')?.value || 'normal';
      const contrast = dropdown.querySelector('input[name="contrast"]:checked')?.value || 'normal';
      const genderDisplay = dropdown.querySelector('input[name="genderDisplay"]:checked')?.value || 'colors';
      const showPrenoms = document.getElementById('showPrenoms')?.checked ?? true;
      const showClasse = document.getElementById('showClasseOrigine')?.checked ?? true;
      const showScores = document.getElementById('showScores')?.checked ?? true;
      
      const lisibiliteState = {
        size: fontSize,
        style: fontStyle,
        contrast: contrast,
        symbols: genderDisplay,
        showPrenoms: showPrenoms,
        showClasse: showClasse,
        showScores: showScores
      };
      localStorage.setItem('lisibilite-preferences', JSON.stringify(lisibiliteState));
      
      if (window.applyLisibilitePreferences) {
        window.applyLisibilitePreferences();
      }
    }
    
    // Connecter les checkboxes
    ['showPrenoms', 'showClasseOrigine', 'showScores'].forEach(id => {
      const checkbox = document.getElementById(id);
      if (checkbox) {
        checkbox.addEventListener('change', applyReglerSettings);
      }
    });
    
    // Connecter les radios pour appliquer en temps r√©el
    dropdown.querySelectorAll('input[type="radio"]').forEach(radio => {
      radio.addEventListener('change', () => {
        applyReglerSettings();
      });
    });
    
    // Pr√©r√©glages
    document.getElementById('presetProjection')?.addEventListener('click', () => {
      setRadioValue('fontSize', 'medium');
      setRadioValue('fontStyle', 'bold');
      setRadioValue('genderDisplay', 'symbols');
      const whiteBackground = document.getElementById('whiteBackground');
      if (whiteBackground) {
        whiteBackground.checked = true;
        whiteBackground.dispatchEvent(new Event('change'));
      }
      applyReglerSettings();
      toast('üìΩÔ∏è Mode Projection activ√©', 'success');
    });
    
    document.getElementById('presetImpression')?.addEventListener('click', () => {
      setRadioValue('fontSize', 'small');
      setRadioValue('fontStyle', 'normal');
      setRadioValue('contrast', 'normal');
      setRadioValue('genderDisplay', 'colors');
      const whiteBackground = document.getElementById('whiteBackground');
      if (whiteBackground) {
        whiteBackground.checked = false;
        whiteBackground.dispatchEvent(new Event('change'));
      }
      applyReglerSettings();
      toast('üñ®Ô∏è Mode Impression activ√©', 'success');
    });
    
    document.getElementById('presetAccessibilite')?.addEventListener('click', () => {
      setRadioValue('fontSize', 'xlarge');
      setRadioValue('fontStyle', 'bold');
      setRadioValue('contrast', 'max');
      setRadioValue('genderDisplay', 'both');
      applyReglerSettings();
      toast('‚ôø Mode Accessibilit√© activ√©', 'success');
    });
    
    // R√©initialiser
    document.getElementById('btnResetReglages')?.addEventListener('click', () => {
      setRadioValue('fontSize', 'medium');
      setRadioValue('fontStyle', 'normal');
      setRadioValue('contrast', 'normal');
      setRadioValue('genderDisplay', 'colors');
      
      const showGenderBadges = document.getElementById('showGenderBadges');
      if (showGenderBadges) {
        showGenderBadges.checked = false;
        showGenderBadges.dispatchEvent(new Event('change'));
      }
      
      const whiteBackground = document.getElementById('whiteBackground');
      if (whiteBackground) {
        whiteBackground.checked = false;
        whiteBackground.dispatchEvent(new Event('change'));
      }
      
      document.getElementById('showPrenoms').checked = true;
      document.getElementById('showClasseOrigine').checked = true;
      document.getElementById('showScores').checked = true;
      
      applyReglerSettings();
      toast('üîÑ R√©glages r√©initialis√©s', 'info');
    });
    
    // Plein √©cran
    document.getElementById('btnPleinEcran')?.addEventListener('click', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
        toast('‚õ∂ Mode plein √©cran activ√©', 'info');
      } else {
        document.exitFullscreen();
        toast('‚õ∂ Mode plein √©cran d√©sactiv√©', 'info');
      }
    });
    
    // Mode sombre
    document.getElementById('btnModeSombre')?.addEventListener('click', (e) => {
      e.stopPropagation();
      document.body.classList.toggle('dark-mode');
      const isDark = document.body.classList.contains('dark-mode');
      localStorage.setItem('darkMode', isDark);
      toast(isDark ? 'üåô Mode sombre activ√©' : '‚òÄÔ∏è Mode clair activ√©', 'info');
    });
    
    // Zoom cartes
    document.getElementById('btnZoomCartes')?.addEventListener('click', () => {
      const cards = document.querySelectorAll('.student-card');
      const isZoomed = cards[0]?.style.transform === 'scale(1.1)';
      cards.forEach(card => {
        card.style.transform = isZoomed ? '' : 'scale(1.1)';
        card.style.transition = 'transform 0.2s';
      });
      toast(isZoomed ? 'üîç Zoom d√©sactiv√©' : 'üîç Zoom activ√©', 'info');
    });
    
    // Helper pour d√©finir un radio
    function setRadioValue(name, value) {
      const radio = dropdown.querySelector(`input[name="${name}"][value="${value}"]`);
      if (radio) {
        radio.checked = true;
        const label = radio.closest('label');
        if (label) {
          dropdown.querySelectorAll(`input[name="${name}"]`).forEach(r => {
            const l = r.closest('label');
            if (l) {
              l.classList.remove('bg-blue-50', 'border-blue-500', 'dark:bg-blue-900/30');
              const s = l.querySelector('span');
              if (s) s.classList.remove('text-blue-700');
            }
          });
          label.classList.add('bg-blue-50', 'border-blue-500', 'dark:bg-blue-900/30');
          const span = label.querySelector('span');
          if (span) span.classList.add('text-blue-700');
        }
      }
    }
    
    // Charger les pr√©f√©rences au d√©marrage
    const saved = localStorage.getItem('lisibilite-preferences');
    if (saved) {
      const prefs = JSON.parse(saved);
      setRadioValue('fontSize', prefs.size || 'medium');
      setRadioValue('fontStyle', prefs.style || 'normal');
      setRadioValue('contrast', prefs.contrast || 'normal');
      setRadioValue('genderDisplay', prefs.symbols || 'colors');
    }
    
    console.log('‚úÖ Menu R√©gler (dropdown) initialis√©');
  })();
  // =======================================================
  // FONCTION GLOBALE POUR APPLIQUER LES PR√âF√âRENCES DE LISIBILIT√â
  // =======================================================
  window.applyLisibilitePreferences = function() {
    const saved = localStorage.getItem('lisibilite-preferences');
    if (!saved) return;

    const prefs = JSON.parse(saved);

    // Appliquer la taille des noms
    const studentCards = document.querySelectorAll('.student-card');
    studentCards.forEach(card => {
      // Supprimer toutes les classes de taille
      card.classList.remove('font-size-small', 'font-size-medium', 'font-size-large', 'font-size-xlarge');
      // Ajouter la nouvelle classe
      if (prefs.size) {
        card.classList.add(`font-size-${prefs.size}`);
      }
    });

    // Appliquer le style des noms
    studentCards.forEach(card => {
      // Supprimer toutes les classes de style
      card.classList.remove('font-style-normal', 'font-style-bold', 'font-style-highlight', 'font-style-outline');
      // Ajouter la nouvelle classe
      if (prefs.style) {
        card.classList.add(`font-style-${prefs.style}`);
      }
    });

    // Appliquer le contraste au body
    document.body.classList.remove('contrast-normal', 'contrast-high', 'contrast-max');
    if (prefs.contrast) {
      document.body.classList.add(`contrast-${prefs.contrast}`);
    }

    // Appliquer l'affichage des genres
    studentCards.forEach(card => {
      card.classList.remove('gender-colors', 'gender-symbols', 'gender-both');
      if (prefs.symbols) {
        card.classList.add(`gender-${prefs.symbols}`);
      }

    });
    // Appliquer l'affichage/masquage des pr√©noms
    if (prefs.showPrenoms !== undefined) {
      const allNames = document.querySelectorAll('.student-fullname, .student-simple-name');
      allNames.forEach(nameEl => {
        const card = nameEl.closest('.student-card');
        if (!card || !card.dataset.id) return;

        const eleve = STATE && STATE.students ? STATE.students[card.dataset.id] : null;
        if (!eleve) return;

        if (prefs.showPrenoms) {
          // Afficher nom + pr√©nom
          if (typeof simplifierNomComplet === 'function') {
            nameEl.textContent = simplifierNomComplet(eleve.nom, eleve.prenom);
          } else {
            nameEl.textContent = eleve.prenom ? eleve.nom + ' ' + eleve.prenom : eleve.nom;
          }
        } else {
          // Afficher nom uniquement
          nameEl.textContent = eleve.nom;
        }
      });
    }

    // Appliquer l'affichage/masquage de la classe d'origine
    if (prefs.showClasse !== undefined) {
      const sourceElements = document.querySelectorAll('.source-class');
      sourceElements.forEach(el => {
        el.style.display = prefs.showClasse ? '' : 'none';
      });
    }

    // Appliquer l'affichage/masquage des scores
    if (prefs.showScores !== undefined) {
      const scoresElements = document.querySelectorAll('.scores');
      scoresElements.forEach(el => {
        el.style.display = prefs.showScores ? '' : 'none';
      });
    }
  };
  
  // Appliquer les pr√©f√©rences sauvegard√©es au d√©marrage
  if (typeof window.applyLisibilitePreferences === 'function') {
    setTimeout(() => window.applyLisibilitePreferences(), 200);
  }


  // =======================================================
  // 1.6.5 FONCTIONS CENTRALIS√âES POUR LE PANNEAU STATS
  // =======================================================
  window.openStatsPanel = function() {
    const statsPanel = document.getElementById('statsPanel');
    const floatClose = document.getElementById('statsFloatingClose');

    if (!statsPanel) return;

    // Animation synchronis√©e
    requestAnimationFrame(() => {
      // 1. D√©finir la largeur du panneau AVANT de l'afficher
      const panelWidth = 600; // Largeur par d√©faut
      document.documentElement.style.setProperty('--stats-width', panelWidth + 'px');

      // 2. Ajouter la classe pour pr√©parer la grille
      document.body.classList.add('stats-open');

      // 3. Afficher le panneau avec animation
      setTimeout(() => {
        statsPanel.classList.remove('translate-x-full');

        // Afficher le bouton flottant
        if (floatClose) {
          floatClose.classList.remove('hidden');
        }

        // Initialiser les graphiques si pas encore fait
        if (typeof chartCommunication === 'undefined' || !chartCommunication) {
          if (typeof initCharts === 'function') {
            initCharts();
          }
        }

        if (typeof updateCharts === 'function') {
          updateCharts();
        }

        console.log('üìä Panneau stats ouvert');
      }, 50);
    });
  };

  window.closeStatsPanel = function() {
    const statsPanel = document.getElementById('statsPanel');
    const floatClose = document.getElementById('statsFloatingClose');

    if (!statsPanel) return;

    // Slide out
    statsPanel.classList.add('translate-x-full');
    document.body.classList.remove('stats-open');

    // Masquer le bouton flottant
    if (floatClose) {
      floatClose.classList.add('hidden');
    }

    console.log('üìä Panneau stats ferm√©');
  };

  // =======================================================
  // 1.6 GESTION DU MENU √âDITER (DROPDOWN)
  // =======================================================
  (function() {
    const btnEditer = document.getElementById('btnEditer');
    const dropdown = document.getElementById('dropdownEditer');
    
    if (!btnEditer || !dropdown) {
      console.warn('Menu √âditer non trouv√©');
      return;
    }
    
    // Toggle dropdown avec positionnement dynamique et animation
    btnEditer.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      // Fermer tous les autres dropdowns (sauf celui-ci)
      document.querySelectorAll('.dropdown-menu').forEach(dd => {
        if (dd !== dropdown && !dd.classList.contains('hidden')) {
          dd.classList.remove('show');
          setTimeout(() => dd.classList.add('hidden'), 150);
        }
      });
      
      // Positionner le dropdown sous le bouton
      const rect = btnEditer.getBoundingClientRect();
      dropdown.style.top = `${rect.bottom + 8}px`;
      dropdown.style.left = `${rect.left}px`;
      
      // Toggle avec animation
      if (window.toggleDropdown) {
        toggleDropdown(dropdown, btnEditer);
      } else {
        dropdown.classList.toggle('hidden');
      }
    });
    
    // Emp√™cher la fermeture au clic interne
    dropdown.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    
    // Fermer au clic ext√©rieur
    document.addEventListener('click', (e) => {
      if (!dropdown.contains(e.target) && e.target !== btnEditer) {
        dropdown.classList.remove('show');
        setTimeout(() => dropdown.classList.add('hidden'), 150);
      }
    });
    
    console.log('‚úÖ Menu √âditer (dropdown) initialis√©');
  })();

  // =======================================================
  // 1.7 GESTION DU MENU COMPARER (DROPDOWN)
  // =======================================================
  (function() {
    const btnComparer = document.getElementById('btnComparer');
    const dropdown = document.getElementById('dropdownComparer');
    
    if (!btnComparer || !dropdown) {
      console.warn('Menu Comparer non trouv√©');
      return;
    }
    
    // Toggle dropdown avec positionnement dynamique
    btnComparer.addEventListener('click', (e) => {
      e.stopPropagation();
      
      const statsPanel = document.getElementById('statsPanel');
      const rect = btnComparer.getBoundingClientRect();
      
      // 1. Si les stats sont OUVERTES ‚Üí on les FERME (panic button)
      if (statsPanel && !statsPanel.classList.contains('translate-x-full')) {
        closeStatsPanel();
        
        // Refermer le petit dropdown si besoin
        dropdown.classList.add('hidden');
        
        // Accessibilit√© propre
        btnComparer.setAttribute('aria-expanded', 'false');
        
        console.log('üìä Stats ferm√©es via bouton Comparer (panic button)');
        return;
      }
      
      // 2. Sinon : comportement normal ‚Üí toggle du menu Comparer
      dropdown.style.top = `${rect.bottom + 8}px`;
      dropdown.style.left = `${rect.left}px`;
      dropdown.classList.toggle('hidden');
      
      btnComparer.setAttribute(
        'aria-expanded',
        dropdown.classList.contains('hidden') ? 'false' : 'true'
      );
    });
    
    // Emp√™cher la fermeture au clic interne
    dropdown.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    
    // Fermer au clic ext√©rieur
    document.addEventListener('click', (e) => {
      if (!dropdown.contains(e.target) && e.target !== btnComparer) {
        dropdown.classList.add('hidden');
      }
    });
    
    // === C√ÇBLAGE DES BOUTONS ===
    
    // 1. Statistiques (ouvre le panneau stats en accord√©on)
    const btnStatsMenu = document.getElementById('btnStatsMenu');
    
    if (btnStatsMenu) {
      btnStatsMenu.addEventListener('click', () => {
        const panel = document.getElementById('statsPanel');
        
        if (!panel) {
          toast('‚ö†Ô∏è Panneau statistiques non disponible', 'warning');
          return;
        }
        
        // Fermer le menu
        dropdown.classList.add('hidden');
        
        // Utiliser la fonction centralis√©e
        openStatsPanel();
        
        // Mettre √† jour aria-expanded
        btnComparer.setAttribute('aria-expanded', 'true');
        
        toast('üìä Panneau statistiques ouvert', 'info');
      });
    }
    
    // 2. Tableaux de bord analytiques
    const btnAnalyticsMenu = document.getElementById('btnAnalyticsMenu');
    
    if (btnAnalyticsMenu) {
      btnAnalyticsMenu.addEventListener('click', () => {
        if (window.openAnalyticsDashboard) {
          window.openAnalyticsDashboard();
        } else {
          toast('‚ö†Ô∏è Tableaux de bord analytiques non disponibles', 'warning');
        }
        dropdown.classList.add('hidden'); // Fermer le menu
      });
    }
    
  })();

  // =======================================================
  // 1.7.5 BRANCHEMENT DU BOUTON FLOTTANT STATS + GESTION √âCHAP
  // =======================================================
  (function() {
    // Brancher le bouton flottant "Fermer ‚úï"
    const statsFloatingClose = document.getElementById('statsFloatingClose');
    if (statsFloatingClose) {
      statsFloatingClose.addEventListener('click', () => {
        closeStatsPanel();
      });
    }

    // Fonction globale pour toggle la densit√© du header
    window.toggleHeaderDensity = function() {
      document.body.classList.toggle('header-xl');
      
      // Sauvegarder la pr√©f√©rence
      if (document.body.classList.contains('header-xl')) {
        localStorage.setItem('headerDensity', 'xl');
        console.log('üñ•Ô∏è Mode confort activ√© (header XL)');
      } else {
        localStorage.setItem('headerDensity', 'compact');
        console.log('üìΩÔ∏è Mode compact activ√© (r√©union/vid√©oprojecteur)');
      }
    };
    
    // Charger la pr√©f√©rence sauvegard√©e au d√©marrage
    const savedDensity = localStorage.getItem('headerDensity');
    if (savedDensity === 'xl') {
      document.body.classList.add('header-xl');
    }
    
    // Raccourci clavier Alt+D pour toggle la densit√©
    document.addEventListener('keydown', (e) => {
      if (e.altKey && (e.key === 'd' || e.key === 'D')) {
        e.preventDefault();
        toggleHeaderDensity();
      }
    });

    // Gestion globale de la touche √âchap
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const reglerMenu = document.getElementById('dropdownRegler');
        const comparerMenu = document.getElementById('dropdownComparer');
        const editerMenu = document.getElementById('dropdownEditer');
        const statsPanel = document.getElementById('statsPanel');

        // Fermer le menu R√©gler
        if (reglerMenu && !reglerMenu.classList.contains('hidden')) {
          reglerMenu.classList.add('hidden');
          const btnRegler = document.getElementById('btnRegler');
          if (btnRegler) {
            btnRegler.setAttribute('aria-expanded', 'false');
          }
          console.log('‚å®Ô∏è Menu R√©gler ferm√© via √âchap');
        }

        // Fermer le menu Comparer (le petit dropdown Comparer)
        if (comparerMenu && !comparerMenu.classList.contains('hidden')) {
          comparerMenu.classList.add('hidden');
          const btnComparer = document.getElementById('btnComparer');
          if (btnComparer) {
            btnComparer.setAttribute('aria-expanded', 'false');
          }
          console.log('‚å®Ô∏è Menu Comparer ferm√© via √âchap');
        }

        // Fermer le menu √âditer
        if (editerMenu && !editerMenu.classList.contains('hidden')) {
          editerMenu.classList.add('hidden');
          const btnEditer = document.getElementById('btnEditer');
          if (btnEditer) {
            btnEditer.setAttribute('aria-expanded', 'false');
          }
          console.log('‚å®Ô∏è Menu √âditer ferm√© via √âchap');
        }

        // Fermer le panneau stats
        if (statsPanel && !statsPanel.classList.contains('translate-x-full')) {
          closeStatsPanel();
          console.log('‚å®Ô∏è Panneau stats ferm√© via √âchap');
        }
      }
    });
  })();

  // =======================================================
  // 1.8 GESTION DU MENU ADMIN - PATCH UNIQUE ANTI-CONFLITS
  // =======================================================
  (function AdminMenuFix(){
    if (window.__ADMIN_FIX_APPLIED__) {
      console.warn('‚ö†Ô∏è AdminMenuFix d√©j√† appliqu√©, skip');
      return; 
    }
    window.__ADMIN_FIX_APPLIED__ = true;
    
    // BLOQUER COMPL√àTEMENT toggleAdminMode legacy
    window.toggleAdminMode = function() {
      console.error('‚ùå toggleAdminMode() est D√âSACTIV√âE - Le menu Admin est g√©r√© par AdminMenuFix');
      if (window.toast) toast('‚ùå Fonction d√©sactiv√©e - Utilisez le menu Admin', 'error');
    };
    console.log('üîí toggleAdminMode() legacy BLOQU√âE globalement');

    // 1) D√©duplication stricte des #dropdownAdmin (root du menu)
    const admins = Array.from(document.querySelectorAll('#dropdownAdmin'));
    if (admins.length === 0) return; // rien √† faire si pas de menu trouv√©
    const adminRoot = admins[0];
    admins.slice(1).forEach(n => n.remove()); // supprime tous les doublons
    if (!adminRoot.hasAttribute('data-menu-root')) adminRoot.setAttribute('data-menu-root','');

    // 2) R√©cup√©rer les √©l√©ments SCOP√âS DANS CE ROOT (√©vite les collisions d'ID)
    const q    = sel => adminRoot.querySelector(sel);
    const btnAdmin = document.getElementById('btnAdmin'); // le bouton header a un id unique
    const lockMsg  = q('#adminLockMessage');
    const content  = q('#adminContent');
    const btnUnlock = q('#btnUnlockAdmin');
    let   btnLock   = q('#btnLockAdmin'); // peut ne pas exister
    const status    = document.getElementById('adminStatusIndicator'); // optionnel

    // 3) √âtat initial (TOUJOURS verrouill√© par d√©faut)
    // IMPORTANT: On ignore localStorage.adminUnlocked ET adminForceMode au d√©marrage pour forcer le verrouillage
    // L'admin doit d√©verrouiller manuellement √† chaque session (s√©curit√©)
    let isAdminUnlocked = false; // TOUJOURS verrouill√© au d√©marrage
    
    // Nettoyer localStorage au d√©marrage (s√©curit√© maximale)
    localStorage.removeItem('adminUnlocked');
    localStorage.removeItem('adminForceMode');
    if (window.STATE) window.STATE.adminMode = false;
    console.log('üîí localStorage nettoy√© au d√©marrage (s√©curit√© maximale)');

    function paintLockedUI() {
      lockMsg && lockMsg.classList.remove('hidden');
      content && content.classList.add('hidden');
      status  && (status.textContent = 'OFF', status.classList.remove('text-white','font-bold'));
      if (btnAdmin) {
        btnAdmin.classList.remove('bg-green-700','hover:bg-green-800');
        btnAdmin.classList.add('bg-red-600','text-white','hover:bg-red-700');
      }
      console.log('üîí Admin verrouill√© - √©tat OFF (par d√©faut)');
    }

    function paintUnlockedUI() {
      lockMsg && lockMsg.classList.add('hidden');
      content && content.classList.remove('hidden');
      status  && (status.textContent = 'ON', status.classList.add('text-white','font-bold'));
      if (btnAdmin) {
        btnAdmin.classList.remove('bg-red-600','hover:bg-red-700');
        btnAdmin.classList.add('bg-green-700','text-white','hover:bg-green-800');
      }
      console.log('‚úÖ Admin d√©verrouill√© - √©tat ON');
    }

    function applyState() {
      (isAdminUnlocked ? paintUnlockedUI : paintLockedUI)();
    }
    applyState();
    
    // GARANTIR que le menu est FERM√â au d√©marrage
    adminRoot.classList.add('hidden', 'opacity-0', 'scale-95');
    console.log('üîí Menu Admin ferm√© par d√©faut');
    
    // Fonctions d'animation fluide
    function openMenu() {
      adminRoot.classList.remove('hidden');
      // Force reflow pour que la transition fonctionne
      void adminRoot.offsetWidth;
      requestAnimationFrame(() => {
        adminRoot.classList.remove('opacity-0', 'scale-95');
        adminRoot.classList.add('opacity-100', 'scale-100');
      });
    }
    
    function closeMenu() {
      adminRoot.classList.remove('opacity-100', 'scale-100');
      adminRoot.classList.add('opacity-0', 'scale-95');
      // Attendre la fin de l'animation avant de cacher
      setTimeout(() => {
        adminRoot.classList.add('hidden');
      }, 200); // Correspond √† duration-200
    }

    // 4) Positionnement + toggle du dropdown Admin (ouvre toujours le m√™me root)
    if (btnAdmin) {
      btnAdmin.addEventListener('click', (e) => {
        e.stopPropagation();
        const rect = btnAdmin.getBoundingClientRect();
        adminRoot.style.top  = `${rect.bottom + 8}px`;
        adminRoot.style.left = `${rect.right - 320}px`;
        adminRoot.style.right = 'auto';
        
        // Toggle avec animation
        const isHidden = adminRoot.classList.contains('hidden');
        if (isHidden) {
          openMenu();
        } else {
          closeMenu();
        }
      });
    }
    // Fermer au clic ext√©rieur
    document.addEventListener('click', (e) => {
      if (!adminRoot.contains(e.target) && e.target !== btnAdmin) {
        if (!adminRoot.classList.contains('hidden')) {
          closeMenu();
        }
      }
    });
    adminRoot.addEventListener('click', e => e.stopPropagation());

    // 5) D√©verrouillage par mot de passe avec champ √©l√©gant (pas de prompt!)
    const passwordInput = q('#adminPasswordInput');
    const passwordError = q('#adminPasswordError');
    const btnToggleVisibility = q('#btnTogglePasswordVisibility');
    
    // Toggle visibilit√© du mot de passe
    if (btnToggleVisibility && passwordInput) {
      btnToggleVisibility.addEventListener('click', () => {
        const isPassword = passwordInput.type === 'password';
        passwordInput.type = isPassword ? 'text' : 'password';
        const icon = btnToggleVisibility.querySelector('i');
        icon.className = isPassword ? 'fas fa-eye-slash' : 'fas fa-eye';
      });
    }
    
    // Fonction de v√©rification du mot de passe
    async function checkPassword(pwd) {
      // Essayer d'abord avec le mot de passe du serveur (_CONFIG B3)
      if (typeof google !== 'undefined' && google.script && google.script.run && google.script.run.getAdminPasswordFromConfig) {
        return new Promise((resolve) => {
          google.script.run
            .withSuccessHandler(function(configPassword){
              resolve(pwd === configPassword || (window.CONFIG && pwd === CONFIG.adminPassword));
            })
            .withFailureHandler(function(err){
              console.error('getAdminPasswordFromConfig KO:', err);
              // Fallback sur CONFIG.adminPassword
              resolve(window.CONFIG && pwd === CONFIG.adminPassword);
            })
            .getAdminPasswordFromConfig();
        });
      }
      // Fallback direct
      return window.CONFIG && pwd === CONFIG.adminPassword;
    }
    
    // Fonction de d√©verrouillage
    async function unlockFlow() {
      const pwd = passwordInput ? passwordInput.value.trim() : '';
      
      if (!pwd) {
        passwordError && (passwordError.textContent = 'Veuillez entrer un mot de passe');
        passwordError && passwordError.classList.remove('hidden');
        passwordInput && passwordInput.classList.add('border-red-500');
        return;
      }
      
      const isValid = await checkPassword(pwd);
      
      if (isValid) {
        isAdminUnlocked = true;
        localStorage.setItem('adminUnlocked','true');
        applyState();
        closeMenu(); // Fermer le menu avec animation apr√®s d√©verrouillage
        window.toast && toast('üîì Mode Admin activ√©','success');
        // Effacer le champ
        passwordInput && (passwordInput.value = '');
        passwordError && passwordError.classList.add('hidden');
        passwordInput && passwordInput.classList.remove('border-red-500');
      } else {
        passwordError && (passwordError.textContent = 'Mot de passe incorrect');
        passwordError && passwordError.classList.remove('hidden');
        passwordInput && passwordInput.classList.add('border-red-500');
        passwordInput && passwordInput.select(); // S√©lectionner le texte pour faciliter la correction
      }
    }

    // Clic sur le bouton D√©verrouiller
    btnUnlock && btnUnlock.addEventListener('click', (e)=>{
      e.preventDefault();
      unlockFlow();
    });
    
    // Appuyer sur Entr√©e dans le champ
    passwordInput && passwordInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        unlockFlow();
      }
    });
    
    // Effacer l'erreur quand on tape
    passwordInput && passwordInput.addEventListener('input', () => {
      passwordError && passwordError.classList.add('hidden');
      passwordInput.classList.remove('border-red-500');
    });

    // 6) Bouton "Verrouiller" coh√©rent (cr√©√© si absent)
    if (!btnLock) {
      btnLock = document.createElement('button');
      btnLock.id = 'btnLockAdmin';
      btnLock.className = 'w-full px-4 py-2 my-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors';
      btnLock.innerHTML = '<i class="fas fa-lock mr-2"></i> Verrouiller le menu Admin';
      content && content.appendChild(btnLock);
    }
    btnLock.addEventListener('click', ()=>{
      localStorage.removeItem('adminUnlocked');
      localStorage.removeItem('adminForceMode');
      if (window.STATE) window.STATE.adminMode = false;
      if (!forceMode) isAdminUnlocked = false; // si forceMode=true, on reste ON
      applyState();
      adminRoot.classList.add('hidden');
      window.toast && toast('üîí Mode Admin verrouill√©','info');
    });

    // 7) Garantir l'accord√©on (FILTRER / AIDE) dans CE menu (scop√©)
    window.toggleSection = window.toggleSection || function(key, el){
      const root = el?.closest('[data-menu-root]') || document;
      const section = root.querySelector(`[data-section-id="${key}"]`);
      const body = section?.querySelector('.section-body') || section || root.getElementById && root.getElementById(key+'Section');
      const icon = section?.querySelector('.section-icon') || el?.querySelector('.fa-chevron-down');
      if (!body) return;
      body.classList.toggle('hidden');
      icon && icon.classList.toggle('rotate-180');
    };

    // 8) C√¢blage des boutons Admin (scop√© dans adminRoot)
    const wireButton = (id, handler) => {
      const btn = q(`#${id}`);
      btn && btn.addEventListener('click', () => {
        handler();
        adminRoot.classList.add('hidden');
      });
    };

    wireButton('btnSourcesAdmin', () => window.openStartupModal && openStartupModal({ force: true }));
    wireButton('btnOptimizationAdmin', () => {
      if (typeof OptimizationPanel !== 'undefined' && OptimizationPanel.open) {
        OptimizationPanel.open();
      } else if (window.openOptimizationPanel) {
        window.openOptimizationPanel();
      } else {
        console.warn('OptimizationPanel non disponible');
        window.toast && toast('Module d\'optimisation non charg√©', 'warning');
      }
    });
    wireButton('menuDarkModeAdmin', () => window.toggleDarkMode && toggleDarkMode());
    wireButton('menuZoomAdmin', () => {
      const cards = document.querySelectorAll('.student-card');
      const isZoomed = cards[0]?.style.transform === 'scale(1.1)';
      cards.forEach(card => card.style.transform = isZoomed ? 'scale(1)' : 'scale(1.1)');
      window.toast && toast(isZoomed ? 'Zoom d√©sactiv√©' : 'Zoom activ√©', 'info');
    });
    wireButton('menuFullscreenAdmin', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    });
    wireButton('menuImportScoresAdmin', () => window.openImportScoresModal && openImportScoresModal());
    wireButton('btnExportAdmin', () => window.exportData && exportData());
    wireButton('menuRulesAdmin', () => window.openRulesModal && openRulesModal());

    // 9) Mode Force Admin (toggle)
    const toggleForce = q('#toggleAdminForceMode');
    if (toggleForce) {
      // TOUJOURS d√©sactiv√© au d√©marrage (s√©curit√©)
      toggleForce.checked = false;
      if (window.STATE) window.STATE.adminMode = false;
      console.log('üîí Mode Force d√©sactiv√© au d√©marrage (s√©curit√©)');
      
      toggleForce.addEventListener('change', () => {
        const isOn = toggleForce.checked;
        console.log('üîÑ Toggle Mode Force chang√©:', isOn);
        console.log('   window.STATE existe?', !!window.STATE);
        console.log('   STATE existe?', typeof STATE !== 'undefined');
        
        if (window.STATE) {
          window.STATE.adminMode = isOn;
          console.log('   ‚úÖ window.STATE.adminMode =', window.STATE.adminMode);
        } else {
          console.error('   ‚ùå window.STATE n\'existe pas!');
        }
        
        localStorage.setItem('adminForceMode', isOn);
        
        if (isOn) {
          window.toast && toast('‚ö†Ô∏è Mode Force activ√© - Toutes les contraintes sont ignor√©es', 'warning');
          console.log('üîì Mode Admin Force: ON - D√©placements libres (FIXE, PERMUT, CONDI ignor√©s)');
          console.log('   STATE.adminMode =', STATE?.adminMode);
        } else {
          window.toast && toast('‚úÖ Mode Force d√©sactiv√© - Contraintes respect√©es', 'success');
          console.log('üîí Mode Admin Force: OFF - Contraintes actives');
          console.log('   STATE.adminMode =', STATE?.adminMode);
        }
        
        // üîÑ Rafra√Æchir l'affichage pour mettre √† jour les attributs draggable des cartes
        console.log('üîÑ Rafra√Æchissement de l\'affichage pour le mode Force...');
        if (typeof renderColumns === 'function') {
          renderColumns();
          console.log('   ‚úÖ renderColumns() appel√©');
        } else {
          console.error('   ‚ùå renderColumns n\'existe pas!');
        }
      });
    }

  })();

  // =======================================================
  // 2. LOGIQUE PRINCIPALE DE L'APPLICATION
  // =======================================================
  
  // TOUT votre code principal va ici, de "const CONFIG = ..." jusqu'√† la fin
  const CONFIG = {
    adminPassword: 'admin123',
    animation: {
      duration: 150
    }
  };
  
  // ========== GESTIONNAIRE D'ERREURS ==========
  window.addEventListener('error', (e) => {
    console.error('Erreur captur√©e:', e.message);
    e.preventDefault();
  });

  /* ---------- helper : √©l√®ve vraiment valide --------- */
  function isValidStudent(e) {
    return e                     // objet pr√©sent
        && e.id && e.id.trim()   // id non-vide
        && e.nom && e.nom.trim();/* au moins un NOM non-vide  */
  }
  
 
  
  
  // ========== MISE √Ä JOUR DES STATISTIQUES ==========
  // Fonctions d√©j√† d√©finies plus haut
  

  
  // Fonction pour d√©placer automatiquement un groupe A
  function moveGroupA(eleveId, srcClasse, dstClasse) {
    const eleve = STATE.students[eleveId];
    if (!eleve.asso) return;
    
    const group = STATE.aGroups[`A${eleve.asso}`] || [];
    const movedMembers = [];
    
    // D√©placer tous les membres du groupe qui sont dans srcClasse
    group.forEach(memberId => {
      const memberCard = document.querySelector(`.student-card[data-id="${memberId}"]`);
      if (!memberCard) return;
      
      const memberClasse = memberCard.closest('.droppable-zone').dataset.classe;
      if (memberClasse === srcClasse) {
        const dstZone = document.querySelector(`.droppable-zone[data-classe="${dstClasse}"]`);
        if (dstZone) {
          dstZone.appendChild(memberCard);
          movedMembers.push(STATE.students[memberId].nom);
        }
      }
    });
    
    if (movedMembers.length > 1) {
      toast(`Groupe A${eleve.asso} d√©plac√© : ${movedMembers.join(', ')}`, 'info');
    }
  }
  
  // ========== GESTION DES SWAPS - REMPLACEMENT COMPLET ==========
  // Remplacez TOUTE la section de gestion des swaps par ce code
  
  // Fonction pour v√©rifier si un swap est possible
  
  
  
  // Fonction pour g√©rer le clic sur une carte
  
  
  // Fonction pour activer/d√©sactiver le mode swap
  function toggleSwapMode() {
    STATE.swapMode = !STATE.swapMode;
    STATE.swapFirst = null;

    const btnSwapMain = document.getElementById('btnSwapMain');
    const sortables = document.querySelectorAll('.droppable-zone');

    if (STATE.swapMode) {
      if (btnSwapMain) {
        btnSwapMain.classList.add('active', 'btn-primary');
        btnSwapMain.classList.remove('btn-secondary');
        btnSwapMain.setAttribute('aria-pressed', 'true');
      }
      toast('üîÑ Mode SWAP activ√© - Cliquez sur deux √©l√®ves pour les √©changer', 'info');

      // D√©sactiver le drag & drop
      sortables.forEach(zone => {
        const sortable = Sortable.get(zone);
        if (sortable) sortable.option('disabled', true);
      });
    } else {
      if (btnSwapMain) {
        btnSwapMain.classList.remove('active', 'btn-primary');
        btnSwapMain.classList.add('btn-secondary');
        btnSwapMain.setAttribute('aria-pressed', 'false');
      }

      // R√©activer le drag & drop
      sortables.forEach(zone => {
        const sortable = Sortable.get(zone);
        if (sortable) sortable.option('disabled', false);
      });

      // Nettoyer les s√©lections
      document.querySelectorAll('.student-card').forEach(card => {
        card.classList.remove('swap-mode');
      });
      document.querySelectorAll('.droppable-zone').forEach(zone => {
        zone.classList.remove('swap-target');
      });

      toast('Mode normal r√©tabli', 'info');
    }
  }
  
  // S'assurer que performSwapAndClose est bien d√©fini pour la modal
  window.performSwapAndClose = function(id1, id2) {
    performSwap(id1, id2);
    
  }
  
  // ========== SUGGESTIONS DE SWAPS ==========
  function findSwapSuggestions() {
    const suggestions = [];
    const classes = Object.keys(STATE.rules);
    
    // Analyser chaque paire de classes
    for (let i = 0; i < classes.length; i++) {
      for (let j = i + 1; j < classes.length; j++) {
        const classe1 = classes[i];
        const classe2 = classes[j];
        
        const students1 = getCurrentClassContent(classe1).map(id => STATE.students[id]);
        const students2 = getCurrentClassContent(classe2).map(id => STATE.students[id]);
        
        // Chercher des swaps √©quilibrants
        students1.forEach(s1 => {
          students2.forEach(s2 => {
            // V√©rifier si le swap est possible
            const check = canSwap(s1.id, s2.id);
            if (!check.ok) return;
            
            // Calculer l'am√©lioration (exemple : √©quilibrage des sexes)
            const countF1 = students1.filter(s => s.sexe === 'F').length;
            const countM1 = students1.filter(s => s.sexe === 'M').length;
            const countF2 = students2.filter(s => s.sexe === 'F').length;
            const countM2 = students2.filter(s => s.sexe === 'M').length;
            
            const diffBefore = Math.abs(countF1 - countM1) + Math.abs(countF2 - countM2);
            
            const newCountF1 = countF1 + (s2.sexe === 'F' ? 1 : 0) - (s1.sexe === 'F' ? 1 : 0);
            const newCountM1 = countM1 + (s2.sexe === 'M' ? 1 : 0) - (s1.sexe === 'M' ? 1 : 0);
            const newCountF2 = countF2 + (s1.sexe === 'F' ? 1 : 0) - (s2.sexe === 'F' ? 1 : 0);
            const newCountM2 = countM2 + (s1.sexe === 'M' ? 1 : 0) - (s2.sexe === 'M' ? 1 : 0);
            
            const diffAfter = Math.abs(newCountF1 - newCountM1) + Math.abs(newCountF2 - newCountM2);
            
            if (diffAfter < diffBefore) {
              suggestions.push({
                student1: s1,
                student2: s2,
                classe1,
                classe2,
                improvement: diffBefore - diffAfter,
                reason: '√âquilibrage des sexes'
              });
            }
          });
        });
      }
    }
    
    // Trier par am√©lioration d√©croissante
    suggestions.sort((a, b) => b.improvement - a.improvement);
    
    return suggestions.slice(0, 10); // Top 10
  }
  
   
 
  
  // ========== GESTION UNDO/REDO ==========
// Fonctions d√©j√† d√©finies plus haut
  
  // ========== MODE ADMIN - SUPPRIM√â ==========
  // La fonction toggleAdminMode() legacy a √©t√© COMPL√àTEMENT SUPPRIM√âE
  // Le menu Admin est g√©r√© UNIQUEMENT par AdminMenuFix (ligne 3070)
  // Toute tentative d'appeler toggleAdminMode() sera bloqu√©e par AdminMenuFix
  
  // ========== RECHERCHE ==========
  function setupSearch() {
    const searchInput = document.getElementById('search');
    
    if (!searchInput) return;
    
    searchInput.addEventListener('input', (e) => {
      const term = e.target.value.toLowerCase();
      STATE.searchTerm = term;
      
      document.querySelectorAll('.student-card').forEach(card => {
        const nameEl = card.querySelector('.student-fullname, .student-simple-name');
        if (!nameEl) return;
        
        const fullName = nameEl.textContent.toLowerCase();
        const match = !term || fullName.includes(term);
        
        card.style.display = match ? '' : 'none';
        card.classList.toggle('search-highlight', match && term);
      });
    });
  }
  


// ========== FONCTIONS DE GESTION DES MODES ==========
function openStartupModal(opts = {}) {
  const modal = document.getElementById('startupModal');
  const modalContent = document.getElementById('startupModalContent');
  if (!modal) return;

  // Si le tableau de r√©partition est d√©j√† affich√©, ne rien faire
  const board = document.getElementById('board');
  if (board && board.innerHTML.trim() !== '' && !(opts && opts.force)) {
    return;
  }

  // Afficher le modal avec animation fluide
  modal.classList.remove('hidden');
  
  // Animation d'entr√©e
  requestAnimationFrame(() => {
    modal.classList.remove('opacity-0');
    modal.classList.add('opacity-100');
    
    if (modalContent) {
      modalContent.classList.remove('scale-95', 'opacity-0');
      modalContent.classList.add('scale-100', 'opacity-100');
    }
  });
  
  checkCache(); // V√©rifier et afficher la derni√®re sauvegarde automatique
}



// ========== FONCTIONS DE GESTION DES VUES ==========
function toggleViewMode() {
  // Cycle: complete ‚Üí essential ‚Üí simple ‚Üí complete
  const modes = ['complete', 'essential', 'simple'];
  const currentIndex = modes.indexOf(STATE.viewMode);
  const nextIndex = (currentIndex + 1) % modes.length;
  STATE.viewMode = modes[nextIndex];

  localStorage.setItem('viewMode', STATE.viewMode);

  // Mettre √† jour les classes body
  document.body.classList.remove('simple-view', 'essential-view');
  if (STATE.viewMode === 'simple') {
    document.body.classList.add('simple-view');
  } else if (STATE.viewMode === 'essential') {
    document.body.classList.add('essential-view');
  }

  // Mettre √† jour le texte du bouton et aria-pressed
  const btn = document.getElementById('btnSimpleView');
  const textSpan = document.getElementById('viewModeText');
  if (btn && textSpan) {
    const modeLabels = {
      'complete': 'Essentielle',
      'essential': 'Simple',
      'simple': 'Compl√®te'
    };
    textSpan.textContent = modeLabels[STATE.viewMode];
    // Mettre √† jour aria-pressed (true si mode diff√©rent de complete)
    btn.setAttribute('aria-pressed', STATE.viewMode !== 'complete');
  }

  // Recr√©er toutes les cartes pour appliquer la nouvelle vue
  document.querySelectorAll('.droppable-zone').forEach(zone => {
    const ids = Array.from(zone.querySelectorAll('.student-card')).map(c => c.dataset.id);
    zone.innerHTML = '';
    ids.forEach(id => {
      if (STATE.students && STATE.students[id]) {
        const card = createStudentCard(STATE.students[id]);
        if (card) zone.appendChild(card);
      }
    });
    setTimeout(() => adjustSimpleNamesFontSize(zone), 0);
  });
  if (window.applyLisibilitePreferences) {
    window.applyLisibilitePreferences();
  }
}

// Fonction adjustSimpleNamesFontSize d√©j√† d√©finie plus haut
  
  // ========== EXPORT DE LA DISPOSITION ==========
// Fonction d√©j√† d√©finie plus haut
  
  // ========== EXPORT EXCEL ==========
  window.exportExcel = function() {
    const wb = XLSX.utils.book_new();
    
    // Feuille de r√©partition
    const data = [];
    document.querySelectorAll('.class-column').forEach(column => {
      const classe = column.querySelector('.classe-name').textContent;
      const cards = Array.from(column.querySelectorAll('.student-card'));
      
      cards.forEach(card => {
        const eleve = STATE.students[card.dataset.id];
        data.push({
          Classe: classe,
          Nom: eleve.nom,
          Pr√©nom: eleve.prenom,
          Sexe: eleve.sexe,
          LV2: eleve.lv2,
          Option: eleve.opt,
          Dissociation: eleve.disso ? `D${eleve.disso}` : '',
          Association: eleve.asso ? `A${eleve.asso}` : '',
          'Score COM': eleve.scores.COM,
          'Score TRA': eleve.scores.TRA,
          'Score PART': eleve.scores.PART,
          'Score ABS': eleve.scores.ABS,
          'Classe origine': eleve.source,
          Mobilit√©: eleve.mobilite
        });
      });
    });
    
    const ws = XLSX.utils.json_to_sheet(data);
    XLSX.utils.book_append_sheet(wb, ws, "R√©partition");
    
    // Feuille de statistiques
    const stats = [];
    document.querySelectorAll('.class-column').forEach(column => {
      const classe = column.querySelector('.classe-name').textContent;
      const count = column.querySelector('.count').textContent;
      const countF = column.querySelector('.count-f').textContent;
      const countM = column.querySelector('.count-m').textContent;
      
      stats.push({
        Classe: classe,
        'Total √©l√®ves': count,
        Filles: countF,
        Gar√ßons: countM,
        'Ratio F/M': `${Math.round(countF/count*100)}% / ${Math.round(countM/count*100)}%`
      });
    });
    
    const wsStats = XLSX.utils.json_to_sheet(stats);
    XLSX.utils.book_append_sheet(wb, wsStats, "Statistiques");
    
    // T√©l√©charger
    const niveau = STATE.niveau.replace('¬∞', 'e') || 'classes';
    XLSX.writeFile(wb, `repartition_${niveau}_${new Date().toISOString().split('T')[0]}.xlsx`);
    
    toast('Export Excel g√©n√©r√© avec succ√®s', 'success');
    closeExportModal();
  }
  
  // ========== EXPORT PDF ==========
  window.exportPDF = async function() {
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF('p', 'mm', 'a4');
    
    // Titre
    pdf.setFontSize(20);
    pdf.text(`R√©partition des Classes - ${STATE.niveau}`, 105, 20, { align: 'center' });
    
    // Date
    pdf.setFontSize(12);
    pdf.text(new Date().toLocaleDateString('fr-FR'), 105, 30, { align: 'center' });
    
    let yPos = 50;
    
    // Pour chaque classe
    document.querySelectorAll('.class-column').forEach((column, index) => {
      if (yPos > 250) {
        pdf.addPage();
        yPos = 20;
      }
      
      const classe = column.querySelector('.classe-name').textContent;
      const count = column.querySelector('.count').textContent;
      const countF = column.querySelector('.count-f').textContent;
      const countM = column.querySelector('.count-m').textContent;
      
      // Titre de la classe
      pdf.setFontSize(16);
      pdf.setTextColor(91, 33, 182); // Primary color
      pdf.text(classe, 20, yPos);
      
      // Stats
      pdf.setFontSize(10);
      pdf.setTextColor(0, 0, 0);
      pdf.text(`Total: ${count} √©l√®ves (${countF} filles, ${countM} gar√ßons)`, 60, yPos);
      
      yPos += 10;
      
      // Liste des √©l√®ves
      const cards = Array.from(column.querySelectorAll('.student-card'));
      cards.forEach((card, i) => {
        if (yPos > 270) {
          pdf.addPage();
          yPos = 20;
        }
        
        const eleve = STATE.students[card.dataset.id];
        const text = `${i + 1}. ${eleve.nom} ${eleve.prenom} - ${eleve.lv2}${eleve.opt ? '/' + eleve.opt : ''}`;
        pdf.text(text, 25, yPos);
        yPos += 5;
      });
      
      yPos += 10;
    }); // ‚Üê Fin de la boucle sur les colonnes

    // Ajouter les graphiques si le panel stats est ouvert
    if (!document.getElementById('statsPanel').classList.contains('translate-x-full')) {
      pdf.addPage();
      pdf.setFontSize(16);
      pdf.text('Statistiques', 105, 20, { align: 'center' });

      // Capturer les graphiques
      const canvas1 = document.getElementById('chartStacked');
      if (canvas1) {
        const imgData1 = canvas1.toDataURL('image/png');
        pdf.addImage(imgData1, 'PNG', 20, 40, 170, 80);
      }

      const canvas2 = document.getElementById('chartDetailed');
      if (canvas2) {
        const imgData2 = canvas2.toDataURL('image/png');
        pdf.addImage(imgData2, 'PNG', 20, 130, 170, 80);
      }
    }

    const niveau = STATE.niveau.replace('¬∞', 'e') || 'classes';
    pdf.save(`repartition_${niveau}_${new Date().toISOString().split('T')[0]}.pdf`);

    toast('Export PDF g√©n√©r√© avec succ√®s', 'success');
    closeExportModal();
  } // ‚Üê Fin correcte de la fonction exportPDF
  
  // ========== COMPARAISON AVANT/APR√àS ==========
  window.showComparison = function() {
    if (!STATE.originalData) {
      toast('Aucune donn√©e de comparaison disponible', 'warning');
      return;a
    }
    
    // Cr√©er une modal de comparaison
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-content" style="max-width: 1200px;">
        <div class="modal-header">
          <h2 class="text-xl font-bold">Comparaison avant/apr√®s r√©partition</h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <div class="comparison-container">
            <div class="comparison-side">
              <h3>√âtat initial</h3>
              <div id="comparisonBefore"></div>
            </div>
            <div class="comparison-side">
              <h3>√âtat actuel</h3>
              <div id="comparisonAfter"></div>
            </div>
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Remplir les donn√©es
    const beforeContainer = modal.querySelector('#comparisonBefore');
    const afterContainer = modal.querySelector('#comparisonAfter');
    
    // √âtat initial
    STATE.originalData.forEach(group => {
      const div = document.createElement('div');
      div.className = 'mb-4';
      div.innerHTML = `
        <h4 class="font-bold">${group.classe}</h4>
        <p>Total: ${group.eleves.length} √©l√®ves</p>
        <p>F/M: ${group.eleves.filter(e => e.sexe === 'F').length}/${group.eleves.filter(e => e.sexe === 'M').length}</p>
      `;
      beforeContainer.appendChild(div);
    });
    
    // √âtat actuel
    document.querySelectorAll('.class-column').forEach(column => {
      const classe = column.querySelector('.classe-name').textContent;
      const count = column.querySelector('.count').textContent;
      const countF = column.querySelector('.count-f').textContent;
      const countM = column.querySelector('.count-m').textContent;
      
      const div = document.createElement('div');
      div.className = 'mb-4';
      div.innerHTML = `
        <h4 class="font-bold">${classe}</h4>
        <p>Total: ${count} √©l√®ves</p>
        <p>F/M: ${countF}/${countM}</p>
      `;
      afterContainer.appendChild(div);
    });
    
    closeExportModal();
  }
  
  // ========== MODAL EXPORT ==========
  window.closeExportModal = function() {
    document.getElementById('exportModal').classList.add('hidden');
    document.getElementById('overlay').classList.add('hidden');
    document.getElementById('overlay').classList.remove('active');
  }
  
  // ========== √âDITION DES R√àGLES ==========
  function openRulesModal() {
    const container = document.getElementById('rulesContainer');
    container.innerHTML = '';
    
    // Pour chaque classe
    Object.keys(STATE.rules).forEach(classe => {
      const rule = STATE.rules[classe];
      
      const div = document.createElement('div');
      div.className = 'mb-6 p-4 border rounded-lg';
      div.innerHTML = `
        <h3 class="font-bold text-lg mb-3">${classe}</h3>
        <div class="grid grid-cols-2 gap-4">
          <div class="form-group">
            <label class="form-label">Capacit√© maximale</label>
            <input type="number" class="form-control" 
              data-classe="${classe}" 
              data-field="capacity" 
              value="${rule.capacity || 28}" 
              min="1" max="35">
          </div>
          <div class="form-group">
            <label class="form-label">Quotas (format: OPT=nombre)</label>
            <textarea class="form-control" 
              data-classe="${classe}" 
              data-field="quotas" 
              rows="3">${Object.entries(rule.quotas || {}).map(([k, v]) => `${k}=${v}`).join(', ')}</textarea>
          </div>
        </div>
      `;
      
      container.appendChild(div);
    });
    
    document.getElementById('rulesModal').classList.remove('hidden');
    document.getElementById('overlay').classList.remove('hidden');
    document.getElementById('overlay').classList.add('active');
  }
  
  window.closeRulesModal = function() {
    document.getElementById('rulesModal').classList.add('hidden');
    document.getElementById('overlay').classList.add('hidden');
    document.getElementById('overlay').classList.remove('active');
  }
  
  window.saveRules = async function() {
    const newRules = {};
    
    // Collecter les nouvelles r√®gles
    document.querySelectorAll('#rulesContainer input, #rulesContainer textarea').forEach(input => {
      const classe = input.dataset.classe;
      const field = input.dataset.field;
      
      if (!newRules[classe]) {
        newRules[classe] = { capacity: 28, quotas: {} };
      }
      
      if (field === 'capacity') {
        newRules[classe].capacity = parseInt(input.value) || 28;
      } else if (field === 'quotas') {
        // Parser les quotas
        const quotasStr = input.value;
        quotasStr.split(',').forEach(pair => {
          const [opt, val] = pair.split('=').map(s => s.trim());
          if (opt && val) {
            newRules[classe].quotas[opt.toUpperCase()] = parseInt(val) || 0;
          }
        });
      }
    });
    
    // Mettre √† jour l'√©tat
    STATE.rules = newRules;
    
    // Sauvegarder en backend
    try {
      const result = await gsRun('updateStructureRules', newRules);
      if (result.success) {
        toast('R√®gles mises √† jour avec succ√®s', 'success');
        closeRulesModal();
      } else {
        toast('Erreur lors de la mise √† jour des r√®gles', 'error');
      }
    } catch (error) {
      console.error('Erreur:', error);
      toast('Erreur lors de la mise √† jour des r√®gles', 'error');
    }
  }
  
  // ========== MISE √Ä JOUR INTELLIGENTE DU PANEAU DES STATISTIQUES ==========
// (ANCIENNE VERSION SUPPRIM√âE - REMPLAC√âE PAR LA VERSION PROT√âG√âE)

// ========== GRAPHIQUES ==========
function initCharts() {
    console.log('üé® Initialisation des graphiques...');
    const statsContent = document.getElementById('statsContent');
    
    // HTML COMPLET avec tous les graphiques existants + nouveaux
    statsContent.innerHTML = `
      <div class="mb-2">
        <div class="flex gap-2 mb-2">
          <button onclick="switchChart('COM')" class="px-3 py-1 text-xs rounded font-semibold bg-green-500 text-white" id="btnCOM">COM</button>
          <button onclick="switchChart('TRA')" class="px-3 py-1 text-xs rounded font-semibold bg-gray-300" id="btnTRA">TRA</button>
          <button onclick="switchChart('PART')" class="px-3 py-1 text-xs rounded font-semibold bg-gray-300" id="btnPART">PART</button>
          <button onclick="switchChart('ABS')" class="px-3 py-1 text-xs rounded font-semibold bg-gray-300" id="btnABS">ABS</button>
        </div>
      </div>
      
      <div class="chart-container" style="padding: 10px; margin-bottom: 10px;">
        <h3 class="chart-title text-sm">Distribution - <span id="scoreType">Comportement</span></h3>
        <canvas id="chartStacked" style="max-height: 150px;"></canvas>
      </div>
      
      <div class="chart-container" style="padding: 10px; margin-bottom: 10px;">
        <h3 class="chart-title text-sm">Moyennes par classe</h3>
        <canvas id="chartDetailed" style="max-height: 150px;"></canvas>
      </div>
      
      <div class="grid grid-cols-2 gap-2">
        <div class="chart-container" style="padding: 10px;">
          <h3 class="chart-title text-sm">R√©partition LV2</h3>
          <canvas id="chartLV2" style="max-height: 120px;"></canvas>
        </div>
        
        <div class="chart-container" style="padding: 10px;">
          <h3 class="chart-title text-sm">Options</h3>
          <canvas id="chartOptions" style="max-height: 120px;"></canvas>
        </div>
      </div>
      
      <div class="chart-container" style="padding: 10px; margin-top: 10px;">
        <h3 class="chart-title text-sm">Statistiques globales</h3>
        <div id="globalStats" class="text-xs"></div>
      </div>
      
      <!-- ========== NOUVEAUX AJOUTS EN BAS ========== -->
      
      <!-- M√©triques globales -->
  <div class="grid grid-cols-4 gap-3 mb-4 mt-4">
    <div class="stats-metric">
      <div class="metric-value" id="totalStudentsMetric">0</div>
      <div class="metric-label">√âl√®ves</div>
    </div>
    <div class="stats-metric">
      <div class="metric-value" id="genderBalanceMetric">50% F</div>
      <div class="metric-label">Ratio Filles</div>
    </div>
    <div class="stats-metric">
      <div class="metric-value" id="avgClassSizeMetric">0</div>
      <div class="metric-label">Moy/Classe</div>
    </div>
    <div class="stats-metric">
      <div class="metric-value" id="conformityScoreMetric">‚úÖ OK</div>
      <div class="metric-label">Probl√®mes</div>
    </div>
  </div>
      
      <!-- Nouveau graphique LV2 d√©taill√© -->
      <div class="chart-container" style="padding: 10px; margin-bottom: 10px;">
        <h3 class="chart-title text-sm">
          <i class="fas fa-language text-purple-500"></i>
          R√©partition LV2 par Classe
        </h3>
        <canvas id="chartLV2Details" style="max-height: 180px;"></canvas>
      </div>
    `;
    
    // Chart 1 : Distribution empil√©e par classe
    const ctx1 = document.getElementById('chartStacked').getContext('2d');
    chartCommunication = new Chart(ctx1, {
      type: 'bar',
      data: {
        labels: [],
        datasets: [
          { label: '1', data: [], backgroundColor: '#dc2626', stack: 'Stack 0' },
          { label: '2', data: [], backgroundColor: '#fbbf24', stack: 'Stack 0' },
          { label: '3', data: [], backgroundColor: '#22c55e', stack: 'Stack 0' },
          { label: '4', data: [], backgroundColor: '#15803d', stack: 'Stack 0' }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: { 
            stacked: true,
            ticks: { font: { size: 10 } }
          },
          y: { 
            stacked: true,
            beginAtZero: true,
            ticks: { font: { size: 10 } }
          }
        },
        plugins: {
          legend: { 
            display: true,
            position: 'right',
            labels: { 
              boxWidth: 12,
              font: { size: 10 }
            }
          },
          tooltip: {
            callbacks: {
              label: function(context) {
                return `Score ${context.datasetIndex + 1}: ${context.parsed.y}`;
              }
            }
          }
        }
      }
    });
    
    // Chart 2 : Distribution par crit√®res
    const ctx2 = document.getElementById('chartDetailed').getContext('2d');
    chartDistribution = new Chart(ctx2, {
      type: 'bar',
      data: {
        labels: [],
        datasets: [
          { label: 'COM', data: [], backgroundColor: '#10b981' },
          { label: 'TRA', data: [], backgroundColor: '#3b82f6' },
          { label: 'PART', data: [], backgroundColor: '#f59e0b' },
          { label: 'ABS', data: [], backgroundColor: '#ef4444' }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: { ticks: { font: { size: 10 } } },
          y: { 
            beginAtZero: true,
            max: 4,
            ticks: { font: { size: 10 } }
          }
        },
        plugins: {
          legend: { 
            position: 'bottom',
            labels: { 
              boxWidth: 10,
              font: { size: 10 }
            }
          }
        }
      }
    });
    
    // Chart 3 : Distribution LV2
    const ctx3 = document.getElementById('chartLV2').getContext('2d');
    chartLV2 = new Chart(ctx3, {
      type: 'doughnut',
      data: {
        labels: [],
        datasets: [{
          data: [],
          backgroundColor: ['#dc2626', '#059669', '#2563eb', '#7c3aed', '#d97706']
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { 
            position: 'bottom',
            labels: { 
              boxWidth: 10,
              font: { size: 10 }
            }
          }
        }
      }
    });
    
    // Chart 4 : Distribution Options
    const ctx4 = document.getElementById('chartOptions').getContext('2d');
    chartOptions = new Chart(ctx4, {
      type: 'bar',
      data: {
        labels: [],
        datasets: [{
          label: '√âl√®ves',
          data: [],
          backgroundColor: '#8b5cf6'
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        indexAxis: 'y',
        scales: {
          x: { 
            beginAtZero: true,
            ticks: { font: { size: 10 } }
          },
          y: { ticks: { font: { size: 10 } } }
        },
        plugins: {
          legend: { display: false }
        }
      }
    });
    
    // ========== NOUVEAU GRAPHIQUE LV2 D√âTAILL√â ==========
    window.chartLV2Details = null;
    const ctx5 = document.getElementById('chartLV2Details');
    if (ctx5) {
      window.chartLV2Details = new Chart(ctx5.getContext('2d'), {
        type: 'bar',
        data: {
          labels: [],
          datasets: []
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { 
              stacked: true,
              ticks: { font: { size: 10 } }
            },
            y: { 
              stacked: true,
              beginAtZero: true,
              ticks: { font: { size: 10 } }
            }
          },
          plugins: {
            legend: { 
              position: 'bottom',
              labels: { 
                boxWidth: 12,
                font: { size: 10 }
              }
            }
          }
        }
      });
    }
    
    // Initialiser avec COM
    updateCharts('COM');
    console.log('‚úÖ Graphiques initialis√©s avec succ√®s');
  }
  
  // Variable locale pour le type de score actuel (comme dans la version qui fonctionne)
  let currentScoreType = 'COM';
  

  
  // Fonction pour changer de graphique
  window.switchChart = function(type) {
    currentScoreType = type;
    
    // Mettre √† jour les boutons
    ['COM', 'TRA', 'PART', 'ABS'].forEach(t => {
      const btn = document.getElementById(`btn${t}`);
      if (t === type) {
        btn.classList.remove('bg-gray-300');
        btn.classList.add('bg-green-500', 'text-white');
      } else {
        btn.classList.remove('bg-green-500', 'text-white');
        btn.classList.add('bg-gray-300');
      }
    });
    
    // Mettre √† jour le titre
    const titles = {
      'COM': 'Comportement',
      'TRA': 'Travail',
      'PART': 'Participation',
      'ABS': 'Absent√©isme'
    };
    document.getElementById('scoreType').textContent = titles[type];
    
    // Mettre √† jour les graphiques
    updateCharts(type);
  }
  
  function updateCharts(scoreType = null) {
    console.log('üö® updateCharts D√âBUT - scoreType:', scoreType);
    try {
      console.log('üìä updateCharts appel√©e avec scoreType:', scoreType);
      if (!scoreType) scoreType = currentScoreType;
      console.log('üìä ScoreType final:', scoreType);
    
    // Collecter les donn√©es par classe
    const dataByClass = {};
    const classes = [];
    const lv2Count = {};
    const optionCount = {};
    
    document.querySelectorAll('.class-column').forEach(column => {
      const classe = column.querySelector('.classe-name').textContent;
      classes.push(classe);
      
      // IMPORTANT: R√©cup√©rer les cartes ACTUELLES de cette colonne
      const cards = Array.from(column.querySelectorAll('.student-card'));
      
      dataByClass[classe] = {
        total: cards.length,
        scores: { 
          COM: [0,0,0,0], 
          TRA: [0,0,0,0], 
          PART: [0,0,0,0],
          ABS: [0,0,0,0]
        },
        averages: { COM: 0, TRA: 0, PART: 0, ABS: 0 }
      };
      
      // Calculer les scores pour chaque √©l√®ve ACTUELLEMENT dans cette classe
      cards.forEach(card => {
        const eleve = STATE.students[card.dataset.id];
        if (!eleve) return;
        
        // Compter les scores pour le graphique empil√©
        const scoreMap = {
          'COM': eleve.scores.COM,
          'TRA': eleve.scores.TRA,
          'PART': eleve.scores.PART,
          'ABS': eleve.scores.ABS
        };
        
        const score = scoreMap[scoreType];
        if (score > 0) {
          dataByClass[classe].scores[scoreType][score - 1]++;
        }

        // Calculer les moyennes pour tous les crit√®res
        if (eleve.scores.COM > 0) dataByClass[classe].averages.COM += eleve.scores.COM;
        if (eleve.scores.TRA > 0) dataByClass[classe].averages.TRA += eleve.scores.TRA;
        if (eleve.scores.PART > 0) dataByClass[classe].averages.PART += eleve.scores.PART;
        if (eleve.scores.ABS > 0) dataByClass[classe].averages.ABS += eleve.scores.ABS;
        
        // Compter LV2 et options
        if (eleve.lv2) {
          lv2Count[eleve.lv2] = (lv2Count[eleve.lv2] || 0) + 1;
        }
        if (eleve.opt) {
          optionCount[eleve.opt] = (optionCount[eleve.opt] || 0) + 1;
        }
      });
      
      // Calculer les moyennes
      const total = cards.length || 1;
      dataByClass[classe].averages.COM /= total;
      dataByClass[classe].averages.TRA /= total;
      dataByClass[classe].averages.PART /= total;
      dataByClass[classe].averages.ABS /= total;
    });
    
    // V√©rifier que les graphiques existent
    if (!chartCommunication || !chartDistribution || !chartLV2 || !chartOptions) {
      console.warn('Graphiques non initialis√©s');
      return;
    }
    
    // Mettre √† jour Chart 1 (Distribution empil√©e)
    const sortedClasses = classes.sort();
    chartCommunication.data.labels = sortedClasses;
    
    // Mettre √† jour Chart 1 (Distribution empil√©e)
    chartCommunication.data.labels = sortedClasses;
    
    // Mettre √† jour les datasets pour le score s√©lectionn√©
    for (let i = 0; i < 4; i++) {
      chartCommunication.data.datasets[i].data = sortedClasses.map(c => 
        dataByClass[c].scores[scoreType][i]
      );
    }
    
    // V√©rification de coh√©rence des longueurs
    console.assert(
      sortedClasses.length === chartCommunication.data.datasets[0].data.length,
      'üí• Incoh√©rence longueurs', sortedClasses.length, chartCommunication.data.datasets[0].data.length
    );
    
    // Mettre √† jour Chart 2 (Moyennes par crit√®re)
    chartDistribution.data.labels = sortedClasses;
    chartDistribution.data.datasets[0].data = sortedClasses.map(c => 
      Math.round(dataByClass[c].averages.COM * 100) / 100
    );
    chartDistribution.data.datasets[1].data = sortedClasses.map(c => 
      Math.round(dataByClass[c].averages.TRA * 100) / 100
    );
    chartDistribution.data.datasets[2].data = sortedClasses.map(c => 
      Math.round(dataByClass[c].averages.PART * 100) / 100
    );
    chartDistribution.data.datasets[3].data = sortedClasses.map(c => 
      Math.round(dataByClass[c].averages.ABS * 100) / 100
    );
    
    // Mettre √† jour Chart 3 (LV2)
    chartLV2.data.labels = Object.keys(lv2Count);
    chartLV2.data.datasets[0].data = Object.values(lv2Count);
    
    // Mettre √† jour Chart 4 (Options)
    chartOptions.data.labels = Object.keys(optionCount);
    chartOptions.data.datasets[0].data = Object.values(optionCount);
    
    // Statistiques globales
    let globalTotals = { eleves: 0, filles: 0, garcons: 0 };
    let globalScores = { COM: 0, TRA: 0, PART: 0, ABS: 0 };
    let scoreCounts = { COM: 0, TRA: 0, PART: 0, ABS: 0 };
    
    // Parcourir TOUTES les cartes actuellement affich√©es
    document.querySelectorAll('.student-card').forEach(card => {
      const eleve = STATE.students[card.dataset.id];
      if (eleve) {
        globalTotals.eleves++;
        if (eleve.sexe === 'F') globalTotals.filles++;
        else globalTotals.garcons++;

        if (eleve.scores.COM > 0) { globalScores.COM += eleve.scores.COM; scoreCounts.COM++; }
        if (eleve.scores.TRA > 0) { globalScores.TRA += eleve.scores.TRA; scoreCounts.TRA++; }
        if (eleve.scores.PART > 0) { globalScores.PART += eleve.scores.PART; scoreCounts.PART++; }
        if (eleve.scores.ABS > 0) { globalScores.ABS += eleve.scores.ABS; scoreCounts.ABS++; }
      }
    });
    
    const globalStatsHtml = `
      <p><strong>Total √©l√®ves :</strong> ${globalTotals.eleves}</p>
      <p><strong>R√©partition :</strong> ${globalTotals.filles} filles (${Math.round(globalTotals.filles/globalTotals.eleves*100)}%) / ${globalTotals.garcons} gar√ßons (${Math.round(globalTotals.garcons/globalTotals.eleves*100)}%)</p>
      <p class="mt-2"><strong>Moyennes globales :</strong></p>
      <ul>
        <li>Comportement : ${scoreCounts.COM > 0 ? (globalScores.COM / scoreCounts.COM).toFixed(2) : 'N/A'}</li>
        <li>Travail : ${scoreCounts.TRA > 0 ? (globalScores.TRA / scoreCounts.TRA).toFixed(2) : 'N/A'}</li>
        <li>Participation : ${scoreCounts.PART > 0 ? (globalScores.PART / scoreCounts.PART).toFixed(2) : 'N/A'}</li>
        <li>Absences : ${scoreCounts.ABS > 0 ? (globalScores.ABS / scoreCounts.ABS).toFixed(2) : 'N/A'}</li>
      </ul>
    `;
    
    const globalStatsElement = document.getElementById('globalStats');
    if (globalStatsElement) {
      globalStatsElement.innerHTML = globalStatsHtml;
    }
    
    chartCommunication.update();
    chartDistribution.update();
    chartLV2.update();
    chartOptions.update();
    
    // Mettre √† jour les autres m√©triques
    updateNewMetrics();
    updateLV2Details();
    
    console.log('üìä Mise √† jour des graphiques termin√©e');
  } catch (error) {
    console.error('‚ùå Erreur dans updateCharts:', error);
  }
  console.log('üö® updateCharts FIN');
}

// --- PATCH unicit√© updateCharts ---------------------------------
if (typeof window.updateChartsRiche === 'undefined') {
  window.updateChartsRiche = updateCharts;   // on m√©morise la vraie
}
window.updateCharts = window.updateChartsRiche; // on √©crase l'ancienne
// ----------------------------------------------------------------

// Attacher updateCharts √† window
window.updateCharts = updateCharts;
  
  // CORRECTION PROBL√àME 5 : MODE SOMBRE
  function toggleDarkMode() {
    STATE.darkMode = !STATE.darkMode;
    document.body.classList.toggle('dark-mode');
    
    // Mettre √† jour l'ic√¥ne du bouton si pr√©sent
    const btnDarkMode = document.getElementById('btnDarkMode');
    if (btnDarkMode) {
      const icon = btnDarkMode.querySelector('i');
      if (icon) {
        icon.className = STATE.darkMode ? 'fas fa-sun' : 'fas fa-moon';
      }
    }
    
    // Mettre √† jour le bouton flottant si pr√©sent
    const darkModeToggle = document.getElementById('darkModeToggle');
    if (darkModeToggle) {
      const icon = darkModeToggle.querySelector('i');
      if (icon) {
        if (STATE.darkMode) {
          icon.className = 'fas fa-sun text-xl';
          darkModeToggle.className = 'fixed bottom-4 right-4 w-14 h-14 rounded-full bg-gradient-to-br from-yellow-400 to-orange-500 text-white shadow-2xl hover:scale-110 transition-all duration-300 flex items-center justify-center z-[99999]';
        } else {
          icon.className = 'fas fa-moon text-xl';
          darkModeToggle.className = 'fixed bottom-4 right-4 w-14 h-14 rounded-full bg-gradient-to-br from-purple-600 to-indigo-600 text-white shadow-2xl hover:scale-110 transition-all duration-300 flex items-center justify-center z-[99999]';
        }
      }
    }
    
    // Sauvegarder la pr√©f√©rence
    try {
      localStorage.setItem('darkMode', STATE.darkMode);
    } catch (e) {
      console.log('localStorage non disponible');
    }
    
    // Message avec raccourci clavier
    const message = STATE.darkMode 
      ? 'üåô Mode sombre activ√© (Touche D ou clic sur le bouton flottant)' 
      : '‚òÄÔ∏è Mode clair activ√© (Touche D ou clic sur le bouton flottant)';
    toast(message, 'info');
  }
  
  // Exposer globalement
  window.toggleDarkMode = toggleDarkMode;
  window.setDarkMode = setDarkMode;
  
  // CORRECTION PROBL√àME 6 : MODE ZOOM
  function toggleZoom() {
    STATE.zoomMode = !STATE.zoomMode;
    document.body.classList.toggle('zoom-cards');
    
    const btnZoom = document.getElementById('btnZoom');
    if (STATE.zoomMode) {
      btnZoom.innerHTML = '<i class="fas fa-search-minus"></i>';
      toast('Mode zoom activ√©', 'info');
    } else {
      btnZoom.innerHTML = '<i class="fas fa-search-plus"></i>';
      toast('Mode zoom d√©sactiv√©', 'info');
    }
  }
  
  // ========== PLEIN √âCRAN STATS ==========
  window.toggleFullscreenStats = function() {
    STATE.fullscreenStats = !STATE.fullscreenStats;
    const statsPanel = document.getElementById('statsPanel');
    
    if (STATE.fullscreenStats) {
      document.body.classList.add('fullscreen-stats');
      statsPanel.classList.remove('translate-x-full');
      
      // Optionnel : demander le plein √©cran natif
      if (statsPanel.requestFullscreen) {
        statsPanel.requestFullscreen();
      }
      
      const btnFullscreen = document.getElementById('btnFullscreen');
      if (btnFullscreen) btnFullscreen.innerHTML = '<i class="fas fa-compress"></i>';
    } else {
      document.body.classList.remove('fullscreen-stats');
      
      // Optionnel : sortir du plein √©cran natif
      if (document.fullscreenElement) {
        document.exitFullscreen();
      }
      
      const btnFullscreen = document.getElementById('btnFullscreen');
      if (btnFullscreen) btnFullscreen.innerHTML = '<i class="fas fa-expand"></i>';
    }
    
    // Forcer la mise √† jour des graphiques
    setTimeout(() => {
      if (chartCommunication) chartCommunication.resize();
      if (chartDistribution) chartDistribution.resize();
      if (chartLV2) chartLV2.resize();
      if (chartOptions) chartOptions.resize();
    }, 300);
  }
  
  // ========== MODE ANCR√â ==========
  function toggleAnchoredStats() {
    STATE.anchoredStats = !STATE.anchoredStats;
    const statsPanel = document.getElementById('statsPanel');
    
    if (STATE.anchoredStats) {
      statsPanel.classList.add('anchored');
      document.getElementById('btnAnchor').classList.add('active');
      toast('Panel statistiques ancr√©', 'info');
    } else {
      statsPanel.classList.remove('anchored');
      document.getElementById('btnAnchor').classList.remove('active');
      toast('Panel statistiques flottant', 'info');
    }
  }
  
  // ========== RACCOURCIS CLAVIER ==========
  function setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      // Ignorer si on est dans un input
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      
      // Ctrl+Z : Annuler
      if (e.ctrlKey && e.key === 'z') {
        e.preventDefault();
        undo();
      }
      
      // Ctrl+Y : Refaire
      if (e.ctrlKey && e.key === 'y') {
        e.preventDefault();
        redo();
      }
      
      // S : Mode swap
      if (e.key === 's' && !e.ctrlKey && !e.altKey) {
        e.preventDefault();
        toggleSwapMode();
      }
      
      // T : Statistiques
      if (e.key === 't' && !e.ctrlKey && !e.altKey) {
        e.preventDefault();
        document.getElementById('btnStats').click();
      }
      
      // D : Mode sombre (RACCOURCI PRIORITAIRE)
      if (e.key === 'd' || e.key === 'D') {
        if (!e.ctrlKey && !e.altKey) {
          e.preventDefault();
          toggleDarkMode();
          console.log('üåì Raccourci clavier D : Mode sombre bascul√©');
        }
      }
      
      // F : Plein √©cran stats (si panel ouvert)
      if (e.key === 'f' && !e.ctrlKey && !e.altKey) {
        if (!document.getElementById('statsPanel').classList.contains('translate-x-full')) {
          e.preventDefault();
          toggleFullscreenStats();
        }
      }
      
      // Ctrl+F : Recherche
      if (e.ctrlKey && e.key === 'f') {
        e.preventDefault();
        document.getElementById('search').focus();
      }
      
      // ? : Aide
      if (e.key === '?' || (e.shiftKey && e.key === '/')) {
        e.preventDefault();
        toggleKeyboardHelp();
      }
      
      // M : Ouvrir le modal de s√©lection de mode
      if (e.key === 'm' && !e.ctrlKey && !e.altKey) {
        e.preventDefault();
        openStartupModal();
      }
      
      // √âchap : Fermer les modals
      if (e.key === 'Escape') {
        // Fermer stats si ouvert
        if (!document.getElementById('statsPanel').classList.contains('translate-x-full')) {
          const panel = document.getElementById('statsPanel');
          panel.classList.add('translate-x-full');
          
          setTimeout(() => {
            document.body.classList.remove('stats-open');
          }, 300);
        }
        
        // Fermer autres modals
        document.querySelectorAll('.modal:not(.hidden)').forEach(modal => {
          modal.classList.add('hidden');
        });
        
        document.getElementById('overlay').classList.add('hidden');
        document.getElementById('overlay').classList.remove('active');
      }
    });
  }
  
  // CORRECTION PROBL√àME 7 : RACCOURCIS CLAVIER
  function toggleKeyboardHelp() {
    const help = document.getElementById('keyboardShortcuts');
    help.classList.toggle('hidden');
    
    if (!help.classList.contains('hidden')) {
      toast('Raccourcis clavier affich√©s', 'info');
    }
  }
  
  // ========== MAPPAGE DES BOUTONS ==========
  function setupEventListeners() {
    // S√©curiser tous les addEventListener avec des v√©rifications
    const btnRefresh = document.getElementById('btnRefresh');
    const btnSwap = document.getElementById('btnSwap');
    const btnUndo = document.getElementById('btnUndo');
    const btnRedo = document.getElementById('btnRedo');
    const btnAdmin = document.getElementById('btnAdmin');
    const btnSimpleView = document.getElementById('btnSimpleView');
    const btnStats = document.getElementById('btnStats');
    const btnExport = document.getElementById('btnExport');
    const btnSaveWIP = document.getElementById('btnSaveWIP');
    const btnFinalize = document.getElementById('btnFinalize');
    const btnEditRules = document.getElementById('btnEditRules');
    const btnDarkMode = document.getElementById('btnDarkMode');
    const btnZoom = document.getElementById('btnZoom');
    const btnHelp = document.getElementById('btnHelp');
    const closeStats = document.getElementById('closeStats');
    const btnFullscreen = document.getElementById('btnFullscreenMode');
    const btnAnchor = document.getElementById('btnAnchor');

    // Bouton rafra√Æchir
    if (btnRefresh) btnRefresh.addEventListener('click', attemptRefresh);

    // Bouton SWAP dans le header
    const btnSwapMain = document.getElementById('btnSwapMain');
    if (btnSwapMain) btnSwapMain.addEventListener('click', toggleSwapMode);

    // NOUVELLE FONCTION DE SAUVEGARDE AVEC PROGRESSION
    window.lancerSauvegardeAvecProgression = async function lancerSauvegardeAvecProgression(saveFunctionName, buttonElement, options = {}) {
      const { title = 'SAUVEGARDE EN COURS...', successMessage = 'Sauvegarde r√©ussie', progressive = true, forcedMode = null } = options;

      if (!window.saveProgressManager) {
        console.error('SaveProgressManager non trouv√© !');
        toast('Erreur : composant de progression manquant.', 'error');
        return;
      }

      // D√©sactiver le bouton
      if (buttonElement) buttonElement.disabled = true;

      // D√©marrer la barre de progression
      window.saveProgressManager.start();
      const header = document.querySelector('#saveProgressBar .save-progress-header span');
      if(header) header.textContent = title;

      try {
        // √âtape 1: Pr√©paration (10%)
        window.saveProgressManager.updateProgress(10, 'step1');
        const disposition = exportDisposition();

        if (!disposition || Object.keys(disposition).length === 0) {
          throw new Error('Aucune classe √† sauvegarder');
        }

        window.saveProgressManager.updateProgress(20, 'step2');
        await new Promise(resolve => setTimeout(resolve, 200));

        // ‚úÖ SAUVEGARDE PROGRESSIVE CLASSE PAR CLASSE (√©vite les timeouts)
        if (progressive && saveFunctionName === 'saveElevesCache') {
          const classes = Object.keys(disposition);
          const totalClasses = classes.length;
          let successCount = 0;
          const errors = [];

          console.log(`üì¶ Sauvegarde progressive de ${totalClasses} classe(s)...`);

          for (let i = 0; i < totalClasses; i++) {
            const classe = classes[i];
            const classMap = { [classe]: disposition[classe] };

            // Mettre √† jour la progression (20% √† 90%)
            const progress = 20 + ((i / totalClasses) * 70);
            window.saveProgressManager.updateProgress(progress, 'step3');

            // Mise √† jour du titre avec le nom de la classe en cours
            if(header) header.innerHTML = `<i class="fas fa-save mr-2"></i>${title} - ${classe} (${i+1}/${totalClasses})`;

            try {
              // ‚úÖ Sauvegarder UNE classe √† la fois
              const result = await gsRun(saveFunctionName, classMap, STATE.currentMode);

              if (!result || !result.success) {
                errors.push(`‚ùå ${classe}: ${result?.message || 'Erreur inconnue'}`);
                console.error(`‚ùå √âchec sauvegarde ${classe}:`, result);
              } else {
                successCount++;
                console.log(`‚úÖ ${classe} sauvegard√©e (${successCount}/${totalClasses})`);
              }
            } catch (err) {
              errors.push(`‚ùå ${classe}: ${err.message}`);
              console.error(`‚ùå Exception sauvegarde ${classe}:`, err);
            }

            // Petit d√©lai pour √©viter les timeouts cons√©cutifs
            await new Promise(resolve => setTimeout(resolve, 100));
          }

          // Finalisation (100%)
          window.saveProgressManager.updateProgress(100, 'step4');

          if (successCount === totalClasses) {
            window.saveProgressManager.complete(true);
            toast(`‚úÖ ${successCount} classe(s) sauvegard√©e(s) avec succ√®s !`, 'success');
          } else if (successCount > 0) {
            window.saveProgressManager.complete(true);
            toast(`‚ö†Ô∏è ${successCount}/${totalClasses} classe(s) sauvegard√©e(s). Erreurs: ${errors.join(', ')}`, 'warning');
            console.warn('Erreurs de sauvegarde:', errors);
          } else {
            throw new Error('Aucune classe sauvegard√©e: ' + errors.join(', '));
          }

        } else {
          // ‚úÖ SAUVEGARDE CLASSIQUE (pour finalizeClasses et autres)
          window.saveProgressManager.updateProgress(50, 'step2');
          await new Promise(resolve => setTimeout(resolve, 300));

          window.saveProgressManager.updateProgress(75, 'step3');
          
          // Utiliser le mode forc√© si fourni, sinon STATE.currentMode
          const modeToUse = forcedMode || STATE.currentMode;
          console.log(`üìä Sauvegarde ${saveFunctionName} avec mode: ${modeToUse}`);
          
          const result = await gsRun(saveFunctionName, disposition, modeToUse);

          if (!result || !result.success) {
            throw new Error(result?.message || 'Une erreur est survenue sur le serveur.');
          }

          window.saveProgressManager.updateProgress(100, 'step4');
          window.saveProgressManager.complete(true);
          toast(result.message || successMessage, 'success');
        }

      } catch (error) {
        console.error('Erreur lors de la sauvegarde avec progression:', error);
        toast(error.message, 'error');
        window.saveProgressManager.complete(false);
      } finally {
        // R√©activer le bouton
        if (buttonElement) buttonElement.disabled = false;
      }
    }

    // Bouton BROUILLON - Sauvegarde manuelle sur CACHE
    if (btnSaveWIP) btnSaveWIP.addEventListener('click', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      lancerSauvegardeAvecProgression('saveElevesCache', e.currentTarget, {
        title: 'Sauvegarde Brouillon (CACHE)...',
        successMessage: 'Brouillon sauvegard√© avec succ√®s !'
      });
    });


    if (btnUndo) btnUndo.addEventListener('click', undo);
    if (btnRedo) btnRedo.addEventListener('click', redo);
    // btnAdmin g√©r√© dans la section 1.8 GESTION DU MENU ADMIN

    // Dropdown s√©lecteur de vue
    const viewModeSelect = document.getElementById('viewModeSelect');
    if (viewModeSelect) {
      // Initialiser la valeur du select selon le mode actuel
      viewModeSelect.value = STATE.viewMode;

      // Event listener pour changement de vue
      viewModeSelect.addEventListener('change', (e) => {
        STATE.viewMode = e.target.value;
        localStorage.setItem('viewMode', STATE.viewMode);

        // Mettre √† jour les classes body
        document.body.classList.remove('simple-view', 'essential-view');
        if (STATE.viewMode === 'simple') {
          document.body.classList.add('simple-view');
        } else if (STATE.viewMode === 'essential') {
          document.body.classList.add('essential-view');
        }

        // Recr√©er toutes les cartes pour appliquer la nouvelle vue
        document.querySelectorAll('.droppable-zone').forEach(zone => {
          const ids = Array.from(zone.querySelectorAll('.student-card')).map(c => c.dataset.id);
          zone.innerHTML = '';
          ids.forEach(id => {
            const eleve = STATE.students[id];
            if (eleve) {
              zone.appendChild(createStudentCard(eleve));
            }
          });
        });

        // Ajuster tailles si mode simple
        if (STATE.viewMode === 'simple') {
          setTimeout(() => {
            document.querySelectorAll('.droppable-zone').forEach(zone => {
              adjustSimpleNamesFontSize(zone);
            });
          }, 50);
        }

        toast(`Mode ${e.target.options[e.target.selectedIndex].text}`, 'info');
      });

      // Appliquer la classe body appropri√©e au chargement
      if (STATE.viewMode === 'simple') {
        document.body.classList.add('simple-view');
      } else if (STATE.viewMode === 'essential') {
        document.body.classList.add('essential-view');
      }
    }

    // ========== GESTION DES BADGES SEXE ET FOND BLANC ==========
    const showGenderBadges = document.getElementById('showGenderBadges');
    const whiteBackground = document.getElementById('whiteBackground');

    // Charger les pr√©f√©rences depuis localStorage
    const genderBadgesEnabled = localStorage.getItem('showGenderBadges') === 'true';
    const whiteBgEnabled = localStorage.getItem('whiteBackground') === 'true';

    if (showGenderBadges) {
      showGenderBadges.checked = genderBadgesEnabled;
      if (genderBadgesEnabled) {
        document.body.classList.add('gender-badges');
      }

      showGenderBadges.addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        localStorage.setItem('showGenderBadges', isChecked);

        if (isChecked) {
          document.body.classList.add('gender-badges');
          toast('Badges sexe activ√©s', 'success');
        } else {
          document.body.classList.remove('gender-badges');
          toast('Badges sexe d√©sactiv√©s', 'info');
        }
      });
    }

    if (whiteBackground) {
      whiteBackground.checked = whiteBgEnabled;
      if (whiteBgEnabled) {
        document.body.classList.add('white-bg');
      }

      whiteBackground.addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        localStorage.setItem('whiteBackground', isChecked);

        if (isChecked) {
          document.body.classList.add('white-bg');
          toast('Fond blanc activ√©', 'success');
        } else {
          document.body.classList.remove('white-bg');
          toast('Fond blanc d√©sactiv√©', 'info');
        }
      });
    }

    // CORRECTION PROBL√àME 4 : Stats sans overlay bloquant
    if (btnStats) btnStats.addEventListener('click', () => {
      const panel = document.getElementById('statsPanel');

      // Animation synchronis√©e
      requestAnimationFrame(() => {
        // 1. D√©finir la largeur du panneau AVANT de l'afficher
        const panelWidth = 600; // Largeur par d√©faut
        document.documentElement.style.setProperty('--stats-width', panelWidth + 'px');

        // 2. Ajouter la classe pour pr√©parer la grille
        document.body.classList.add('stats-open');

        // 3. Afficher le panneau avec animation
        setTimeout(() => {
          panel.classList.remove('translate-x-full');
          // Mettre √† jour aria-expanded
          btnStats.setAttribute('aria-expanded', 'true');

          // Initialiser les graphiques si pas encore fait
          if (!chartCommunication || !chartDistribution || !chartLV2 || !chartOptions) {
            if (typeof initCharts === 'function') {
              initCharts();
            }
          }

          updateCharts();
        }, 50);
      });
    });
    
    // Export
    if (btnExport) btnExport.addEventListener('click', () => {
      document.getElementById('exportModal').classList.remove('hidden');
      document.getElementById('overlay').classList.remove('hidden');
      document.getElementById('overlay').classList.add('active');
    });

    // √âdition des r√®gles
    if (btnEditRules) btnEditRules.addEventListener('click', openRulesModal);
    
    // Mode sombre
    if (btnDarkMode) btnDarkMode.addEventListener('click', toggleDarkMode);
    
    // Zoom
    if (btnZoom) btnZoom.addEventListener('click', toggleZoom);
    
    // Aide
    if (btnHelp) btnHelp.addEventListener('click', toggleKeyboardHelp);
  
    // Fermeture du panneau statistiques
    if (closeStats) closeStats.addEventListener('click', () => {
      closeStatsPanel();
      // Mettre √† jour aria-expanded
      const btnStats = document.getElementById('btnStats');
      if (btnStats) btnStats.setAttribute('aria-expanded', 'false');
    });
  
    // Boutons statistiques avanc√©es
    if (btnFullscreen) btnFullscreen.addEventListener('click', toggleFullscreenStats);
    if (btnAnchor) btnAnchor.addEventListener('click', toggleAnchoredStats);
    
    // Rendre le panel stats redimensionnable
    makeResizable(document.getElementById('statsPanel'));
    
    // Configurer la recherche
    setupSearch();
  }
  
  // ========== PANEL REDIMENSIONNABLE ==========
  function makeResizable(element) {
    let isResizing = false;
    let startX = 0;
    let startWidth = 0;
    
    const handle = document.createElement('div');
    handle.style.cssText = `
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      cursor: ew-resize;
      background: transparent;
    `;
    
    element.appendChild(handle);
    
    handle.addEventListener('mousedown', (e) => {
      isResizing = true;
      startX = e.clientX;
      startWidth = element.offsetWidth;
      document.body.style.cursor = 'ew-resize';
    });
    
    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;
      
      const diff = startX - e.clientX;
      const newWidth = Math.min(Math.max(400, startWidth + diff), window.innerWidth * 0.8);
      element.style.width = newWidth + 'px';
      
      // Mettre √† jour la variable CSS pour adapter la grille
      if (document.body.classList.contains('stats-open')) {
        document.documentElement.style.setProperty('--stats-width', newWidth + 'px');
      }
    });
    
    document.addEventListener('mouseup', () => {
      isResizing = false;
      document.body.style.cursor = '';
    });
  }
  
    
// ========== FONCTION D'INITIALISATION UNIVERSELLE ==========
async function initRepartitionApp() {
  console.log('üöÄ Init universelle...');
  let mode = localStorage.getItem('mode-selection');
  
  if (!mode) {
    openStartupModal();
    return;
  }
  
  STATE.currentMode = mode;
  showModeBadge(mode);
  
  // Arr√™ter les anciennes sauvegardes automatiques pour √™tre propre
  if(typeof stopAutoSave === 'function') stopAutoSave();
  if(typeof stopCacheAutoSave === 'function') stopCacheAutoSave();
  
  const ok = await loadDataForMode(mode);
  if (!ok) {
    showErrorState('Aucune donn√©e trouv√©e pour le mode ' + mode);
    return;
  }

  // D√©marrer la sauvegarde automatique dans le navigateur (uniquement si chargement r√©ussi)
  if (typeof startAutoSave === 'function') {
    startAutoSave();
  }
}

// Fonction pour ouvrir l'optimisation avec mot de passe
function openOptimizationWithPassword() {
  const password = prompt('üîê Entrez le mot de passe pour acc√©der √† l\'optimisation automatique :');
  
  if (password === null) {
    // Utilisateur a annul√©
    return;
  }
  
  if (password === CONFIG.adminPassword) {
    // Mot de passe correct
    if (typeof OptimizationPanel !== 'undefined') {
      OptimizationPanel.open();
    } else {
      console.error('OptimizationPanel non disponible');
      toast('‚ùå Module d\'optimisation non charg√©', 'error');
    }
  } else {
    // Mot de passe incorrect
    toast('‚ùå Mot de passe incorrect', 'error');
  }
}

// Attacher les fonctions globales √† window
window.initRepartitionApp = initRepartitionApp;
window.openStartupModal = openStartupModal;
window.openOptimizationWithPassword = openOptimizationWithPassword;
window.restoreCache = restoreCache;
window.checkCache = checkCache;
window.showModeBadge = showModeBadge;
window.stopAutoSave = stopAutoSave;
window.startAutoSave = startAutoSave;
window.showErrorState = showErrorState;
window.setupEventListeners = setupEventListeners;
window.setupKeyboardShortcuts = setupKeyboardShortcuts;
window.updateAllColumnStats = updateAllColumnStats;
window.updateAdvancedStats = updateAdvancedStats;
window.toast = toast;
window.gsRun = gsRun;
  
  // =======================================================
  // 3. D√âMARRAGE FINAL
  // =======================================================
  
  // --- Event listeners pour le modal de d√©marrage ---
  const modal = document.getElementById('startupModal');
  const badge = document.getElementById('modeBadge');
  const closeBtn = document.getElementById('closeStartupModal');
  const btnRestore = document.getElementById('btnRestoreCache');

  console.log('üîß AUDIT: Attachement des event listeners du modal de d√©marrage');
  console.log('  - Modal trouv√©:', !!modal);
  console.log('  - Badge trouv√©:', !!badge);
  console.log('  - CloseBtn trouv√©:', !!closeBtn);
  console.log('  - BtnRestore trouv√©:', !!btnRestore);

  if (closeBtn) {
    closeBtn.addEventListener('click', () => modal.classList.add('hidden'));
    console.log('  ‚úÖ Event listener attach√©: closeBtn');
  }

  if (badge) {
    badge.addEventListener('dblclick', () => openStartupModal({ force: true }));
    console.log('  ‚úÖ Event listener attach√©: badge');
  }

  if (modal) {
    const buttons = modal.querySelectorAll('button[data-mode]');
    console.log('  - Nombre de boutons [data-mode] trouv√©s:', buttons.length);
    buttons.forEach((btn, index) => {
      const mode = btn.dataset.mode;
      console.log(`    - Bouton ${index + 1}: mode="${mode}"`);

      btn.addEventListener('click', async e => { // Notez "async"
        const mode = e.currentTarget.dataset.mode;
        console.log(`üñ±Ô∏è CLIC sur bouton mode: ${mode}`);

        // ‚ùå BLOQUER SOURCES (non impl√©ment√©)
        if (mode === 'SOURCES') {
          alert('‚ö†Ô∏è Base Pronote non impl√©ment√©e. Cette fonctionnalit√© sera disponible prochainement.');
          return;
        }

        // ‚úÖ CORRECTION : Prot√©ger PREVIOUS et FIN avec mot de passe admin
        if ((mode === 'PREVIOUS' || mode === 'FIN') && !STATE.adminMode) {
          console.log(`üîê Demande mot de passe admin pour mode: ${mode}`);
          const password = prompt('Veuillez entrer le mot de passe administrateur :', '');
          if (password === null) {
            console.log('‚ùå Mot de passe annul√© par l\'utilisateur');
            return; // Annul√© par l'utilisateur
          }

          try {
            console.log('‚è≥ V√©rification du mot de passe admin...');
            const result = await gsRun('verifierMotDePasseAdmin', password);
            if (!result || !result.success) {
              console.log('‚ùå Mot de passe incorrect');
              alert('Mot de passe incorrect.');
              return;
            }
            console.log('‚úÖ Mot de passe correct, adminMode activ√©');
            STATE.adminMode = true;
          } catch (err) {
            console.error('üí• Erreur v√©rification mot de passe:', err);
            alert('Erreur lors de la v√©rification du mot de passe.');
            return;
          }
        }

        console.log(`üíæ Enregistrement du mode: ${mode} dans localStorage`);
        localStorage.setItem('mode-selection', mode);
        modal.classList.add('hidden');
        console.log(`üöÄ Appel initRepartitionApp() pour mode: ${mode}`);
        initRepartitionApp();
      });
    });
    console.log('  ‚úÖ Event listeners attach√©s √† tous les boutons [data-mode]');
  } else {
    console.error('  ‚ùå ERREUR: Modal introuvable! Les event listeners ne peuvent pas √™tre attach√©s.');
  }

  if(btnRestore) {
    btnRestore.addEventListener('click', () => {
        console.log('üñ±Ô∏è CLIC sur btnRestoreCache');
        restoreCache();
        modal.classList.add('hidden');
    });
    console.log('  ‚úÖ Event listener attach√©: btnRestore');
  }

  console.log('‚úÖ AUDIT: Attachement des event listeners termin√©');
  
  // Branche les √©couteurs d'√©v√©nements principaux
  setupEventListeners(); 
  setupKeyboardShortcuts();
  
  // ========== NOUVELLES FONCTIONNALIT√âS ==========
  
  // Variable globale pour le filtre actif
  let activeFilter = 'all';
  let focusedColumn = null;

  // Fonction de filtrage rapide
  function applyQuickFilter(filter) {
    activeFilter = filter;

    // Mettre √† jour les boutons
    document.querySelectorAll('.filter-btn, .filter-btn-compact').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.filter === filter);
    });

    // Appliquer le filtre
    document.querySelectorAll('.student-card').forEach(card => {
      const eleve = STATE.students[card.dataset.id];
      if (!eleve) return;

      let match = false;

      switch (filter) {
        case 'all':
          match = true;
          break;
        case 'PERMUT':
        case 'FIXE':
          match = eleve.mobilite === filter;
          break;
        case 'ESP':
        case 'ITA':
        case 'ALL':
          match = eleve.lv2 === filter;
          break;
        case 'D':
          match = !!eleve.disso;
          break;
        case 'A':
          match = !!eleve.asso;
          break;
      }

      card.classList.toggle('filtered-out', !match);
    });

    // Afficher un message
    if (filter === 'all') {
      toast('Tous les √©l√®ves affich√©s', 'info');
    } else {
      const filtered = document.querySelectorAll('.student-card:not(.filtered-out)').length;
      toast(`${filtered} √©l√®ve(s) avec filtre ${filter}`, 'info');
    }
  }

  // Fonction d'export image
  window.exportAsImage = async function() {
    toast('G√©n√©ration de l\'image en cours...', 'info');
    
    try {
      const board = document.getElementById('board');
      const originalStyle = board.style.cssText;
      
      board.style.width = '1920px';
      board.style.padding = '20px';
      board.style.background = '#ffffff';
      
      await new Promise(resolve => setTimeout(resolve, 500));
      
      const canvas = await html2canvas(board, {
        backgroundColor: '#ffffff',
        scale: 2,
        logging: false,
        useCORS: true,
        width: 1920,
        height: board.scrollHeight
      });
      
      board.style.cssText = originalStyle;
      
      const link = document.createElement('a');
      const niveau = STATE.niveau?.replace('¬∞', 'e') || 'classes';
      link.download = `repartition_${niveau}_${new Date().toISOString().split('T')[0]}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
      
      toast('Image export√©e avec succ√®s', 'success');
    } catch (error) {
      console.error('Erreur export image:', error);
      toast('Erreur lors de l\'export de l\'image', 'error');
    }
  };

  // Am√©liorer le syst√®me d'historique existant
  function addToHistory(action) {
    action.timestamp = new Date().toISOString();
    
    if (action.eleveId) {
      const eleve = STATE.students[action.eleveId];
      action.eleveName = eleve ? `${eleve.nom} ${eleve.prenom}` : 'Inconnu';
    }
    
    STATE.history.push(action);
    updateHistoryPanel();
  }

  window.toggleHistoryPanel = function() {
    const panel = document.getElementById('historyPanel');
    panel.classList.toggle('open');
  };

  // SUPPRIM√â - Premi√®re version de updateHistoryPanel
  // Remplac√©e par la version compl√®te plus bas

  function revertToPoint(index) {
    if (confirm(`Revenir √† cet √©tat ? (${STATE.history.length - index - 1} actions seront annul√©es)`)) {
      while (STATE.history.length > index + 1) {
        undo();
      }
      updateHistoryPanel();
    }
  }

  // Mode focus
  function enableFocusMode() {
    document.querySelectorAll('.class-column').forEach(column => {
      column.addEventListener('dblclick', () => {
        focusOnClass(column);
      });
    });
  }

  function focusOnClass(column) {
    if (focusedColumn) return;
    
    focusedColumn = column;
    
    const overlay = document.createElement('div');
    overlay.className = 'focus-overlay';
    document.body.appendChild(overlay);
    
    const hint = document.createElement('div');
    hint.className = 'exit-focus-hint';
    hint.innerHTML = 'Appuyez sur ESC pour sortir';
    document.body.appendChild(hint);
    
    column.classList.add('focused-column');
    document.body.style.overflow = 'hidden';
    
    function exitFocus(e) {
      if (e.key === 'Escape') {
        column.classList.remove('focused-column');
        overlay.remove();
        hint.remove();
        document.body.style.overflow = '';
        focusedColumn = null;
        document.removeEventListener('keydown', exitFocus);
      }
    }
    
    document.addEventListener('keydown', exitFocus);
    
    overlay.onclick = () => {
      const event = new KeyboardEvent('keydown', { key: 'Escape' });
      document.dispatchEvent(event);
    };
  }

  // Syst√®me de bookmarks
  window.toggleBookmarksMenu = function() {
    const menu = document.getElementById('bookmarksMenu');
    menu.classList.toggle('open');
    updateBookmarksMenu();
  };

  window.saveAsBookmark = function() {
    const name = prompt('Nom du favori :');
    if (!name) return;
    
    const bookmarks = JSON.parse(localStorage.getItem('repartition-bookmarks') || '{}');
    bookmarks[name] = {
      date: new Date().toISOString(),
      disposition: exportDisposition(),
      mode: STATE.currentMode,
      stats: {
        total: Object.keys(STATE.students).length,
        classes: document.querySelectorAll('.class-column').length,
        niveau: STATE.niveau
      }
    };
    
    localStorage.setItem('repartition-bookmarks', JSON.stringify(bookmarks));
    updateBookmarksMenu();
    toast(`Favori "${name}" sauvegard√©`, 'success');
  };

  window.loadBookmark = function(name) {
    const bookmarks = JSON.parse(localStorage.getItem('repartition-bookmarks') || '{}');
    const bookmark = bookmarks[name];
    
    if (!bookmark) return;
    
    if (!confirm(`Charger le favori "${name}" ? Cela remplacera la disposition actuelle.`)) {
      return;
    }
    
    Object.entries(bookmark.disposition).forEach(([classe, ids]) => {
      const zone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
      if (!zone) return;
      
      zone.innerHTML = '';
      
      ids.forEach(id => {
        const card = document.querySelector(`.student-card[data-id="${id}"]`);
        if (card) zone.appendChild(card);
      });
    });
    
    updateAllColumnStats();
    toast(`Favori "${name}" charg√©`, 'success');
  };

  window.deleteBookmark = function(name) {
    if (!confirm(`Supprimer le favori "${name}" ?`)) return;
    
    const bookmarks = JSON.parse(localStorage.getItem('repartition-bookmarks') || '{}');
    delete bookmarks[name];
    localStorage.setItem('repartition-bookmarks', JSON.stringify(bookmarks));
    
    updateBookmarksMenu();
    toast(`Favori "${name}" supprim√©`, 'info');
  };

  function updateBookmarksMenu() {
    const container = document.getElementById('bookmarksList');
    if (!container) return;
    
    const bookmarks = JSON.parse(localStorage.getItem('repartition-bookmarks') || '{}');
    container.innerHTML = '';
    
    if (Object.keys(bookmarks).length === 0) {
      container.innerHTML = '<div class="p-4 text-center text-gray-500">Aucun favori enregistr√©</div>';
      return;
    }
    
    Object.entries(bookmarks).forEach(([name, data]) => {
      const item = document.createElement('div');
      item.className = 'bookmark-item';
      item.innerHTML = `
        <div class="bookmark-name">${name}</div>
        <div class="bookmark-meta">
          Sauvegard√© le ${new Date(data.date).toLocaleDateString('fr-FR')}
          - ${data.stats.total} √©l√®ves
        </div>
        <div class="bookmark-actions">
          <button class="btn btn-sm btn-primary" onclick="loadBookmark('${name}')">
            <i class="fas fa-download"></i> Charger
          </button>
          <button class="btn btn-sm btn-secondary" onclick="deleteBookmark('${name}')">
            <i class="fas fa-trash"></i>
          </button>
        </div>
      `;
      container.appendChild(item);
    });
  }

  // Initialiser les nouvelles fonctionnalit√©s
  enableFocusMode();
  updateHistoryPanel();

  // Fermer les menus au clic externe
  document.addEventListener('click', (e) => {
    if (!e.target.closest('#btnBookmarks') && !e.target.closest('#bookmarksMenu')) {
      document.getElementById('bookmarksMenu')?.classList.remove('open');
    }
  });

  // Ajouter les event listeners pour les nouveaux boutons
  const btnHistory = document.getElementById('btnHistory');
  const btnBookmarks = document.getElementById('btnBookmarks');
  
  if (btnHistory) btnHistory.addEventListener('click', toggleHistoryPanel);
  if (btnBookmarks) btnBookmarks.addEventListener('click', toggleBookmarksMenu);

  // Initialiser les filtres
  document.querySelectorAll('.filter-btn').forEach(btn => {
    btn.addEventListener('click', () => applyQuickFilter(btn.dataset.filter));
  });
  
  // CORRECTION : TOUJOURS afficher le modal au d√©marrage
  // L'utilisateur doit pouvoir choisir √† chaque fois
  openStartupModal();

  // Gestion des menus d√©roulants fixes au clic
  (function() {
    function setupDropdown(wrapperId, btnId, dropdownId) {
      const wrapper = document.getElementById(wrapperId);
      const btn = document.getElementById(btnId);
      const dropdown = document.getElementById(dropdownId);
      if (!wrapper || !btn || !dropdown) return;
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        // Fermer tous les autres dropdowns
        document.querySelectorAll('.app-header .absolute').forEach(d => {
          if (d !== dropdown) {
            d.classList.add('hidden');
            d.setAttribute('aria-hidden', 'true');
            // Trouver le bouton associ√© et mettre √† jour aria-expanded
            const otherBtns = document.querySelectorAll('[aria-haspopup="menu"]');
            otherBtns.forEach(otherBtn => {
              if (otherBtn.nextElementSibling === d || (otherBtn.parentElement && otherBtn.parentElement.contains(d))) {
                otherBtn.setAttribute('aria-expanded', 'false');
              }
            });
          }
        });
        const isHidden = dropdown.classList.toggle('hidden');
        // Mettre √† jour les attributs ARIA
        btn.setAttribute('aria-expanded', !isHidden);
        dropdown.setAttribute('aria-hidden', isHidden);
      });
      // Emp√™cher la fermeture si on clique dans le menu
      dropdown.addEventListener('click', e => e.stopPropagation());
    }
    setupDropdown('settingsMenuWrapper', 'btnSettings', 'settingsDropdown');

    // Mapper les nouveaux boutons du menu Param√®tres aux fonctions existantes
    const settingsDropdown = document.getElementById('settingsDropdown');
    if (settingsDropdown) {
      // Section Affichage
      const menuDarkMode = document.getElementById('menuDarkMode');
      if (menuDarkMode) {
        menuDarkMode.addEventListener('click', () => {
          toggleDarkMode();
          settingsDropdown.classList.add('hidden');
        });
      }

      const menuZoom = document.getElementById('menuZoom');
      if (menuZoom) {
        menuZoom.addEventListener('click', () => {
          toggleZoom();
          settingsDropdown.classList.add('hidden');
        });
      }

      const menuFullscreen = document.getElementById('menuFullscreen');
      if (menuFullscreen) {
        menuFullscreen.addEventListener('click', () => {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
          } else {
            document.exitFullscreen();
          }
          settingsDropdown.classList.add('hidden');
        });
      }

      // Section Actions - Annuler/Refaire d√©j√† g√©r√©s par leurs ID existants (btnUndo, btnRedo)
      // Boutons Favoris, Optimiser, Contraintes, Filtres supprim√©s (non fonctionnels)

      // Section Donn√©es
      const menuImportScores = document.getElementById('menuImportScores');
      const btnImportScores = document.getElementById('btnImportScores');
      if (menuImportScores && btnImportScores) {
        menuImportScores.addEventListener('click', () => {
          btnImportScores.click();
          settingsDropdown.classList.add('hidden');
        });
      }

      const menuRules = document.getElementById('menuRules');
      const btnEditRules = document.getElementById('btnEditRules');
      if (menuRules && btnEditRules) {
        menuRules.addEventListener('click', () => {
          btnEditRules.click();
          settingsDropdown.classList.add('hidden');
        });
      }

      // Section Filtres
      const filterBtnsCompact = settingsDropdown.querySelectorAll('.filter-btn-compact');
      filterBtnsCompact.forEach(btn => {
        btn.addEventListener('click', () => {
          const filter = btn.dataset.filter;
          // Retirer la classe active de tous les boutons
          filterBtnsCompact.forEach(b => b.classList.remove('active'));
          // Ajouter la classe active au bouton cliqu√©
          btn.classList.add('active');
          // Appliquer le filtre en utilisant la fonction existante
          applyQuickFilter(filter);
          // Fermer le menu
          settingsDropdown.classList.add('hidden');
        });
      });

      // Section Aide - btnHelp et btnTutorial d√©j√† g√©r√©s par leurs ID existants
    }

    // Fermer tous les menus au clic ext√©rieur
    document.addEventListener('click', () => {
      document.querySelectorAll('.app-header .absolute').forEach(d => {
        d.classList.add('hidden');
        d.setAttribute('aria-hidden', 'true');
      });
      // Mettre √† jour aria-expanded pour tous les boutons de menu
      document.querySelectorAll('[aria-haspopup="menu"]').forEach(btn => {
        btn.setAttribute('aria-expanded', 'false');
      });
    });
  })();

}); // Fin du DOMContentLoaded

// =======================================================
// FONCTIONS GLOBALES SUPPLEMENTAIRES
// =======================================================

// ========== FONCTIONS POUR LES NOUVELLES M√âTRIQUES ==========
function updateNewMetrics() {
  // V√©rifier que les m√©triques sont pr√™tes dans le DOM
  const metricsReady = document.getElementById('totalStudentsMetric');
  if (!metricsReady) return; // panneau pas encore inject√©
  
  console.log('üî¢ Recalcul metrics - d√©but');
  
  // Total √©l√®ves (uniquement dans les vraies classes)
  let totalStudents = 0;
  let filles = 0;
  let totalClasses = 0;
  
  document.querySelectorAll('.class-column').forEach(column => {
    const className = column.querySelector('.classe-name').textContent;
    if (!isRealClass(className)) return;
    
    totalClasses++;
    column.querySelectorAll('.student-card').forEach(card => {
      const student = STATE.students[card.dataset.id];
      if (student) {
        totalStudents++;
        if (student.sexe === 'F') filles++;
      }
    });
  });
  
  console.log('üî¢ Recalcul metrics', {totalStudents, filles, totalClasses});
  
  const totalElement = document.getElementById('totalStudentsMetric');
  if (totalElement) {
    totalElement.textContent = totalStudents;
    console.log('üî¢ totalStudentsMetric mis √† jour:', totalStudents);
  } else {
    console.warn('‚ùì m√©trique manquante dans le DOM : totalStudentsMetric');
  }
  
  // Ratio filles
  const ratio = totalStudents > 0 ? Math.round((filles / totalStudents) * 100) : 0;
  const ratioElement = document.getElementById('genderBalanceMetric');
  if (ratioElement) {
    ratioElement.textContent = `${ratio}% F`;
    console.log('üî¢ genderBalanceMetric mis √† jour:', `${ratio}% F`);
  } else {
    console.warn('‚ùì m√©trique manquante dans le DOM : genderBalanceMetric');
  }
  
  // Moyenne par classe
  const avgClass = totalClasses > 0 ? Math.round(totalStudents / totalClasses) : 0;
  const avgElement = document.getElementById('avgClassSizeMetric');
  if (avgElement) {
    avgElement.textContent = avgClass;
    console.log('üî¢ avgClassSizeMetric mis √† jour:', avgClass);
  } else {
    console.warn('‚ùì m√©trique manquante dans le DOM : avgClassSizeMetric');
  }
  
  // Score de conformit√©
  const conformityElement = document.getElementById('conformityScoreMetric');
  if (conformityElement) {
    conformityElement.textContent = '‚úÖ OK';
    console.log('üî¢ conformityScoreMetric mis √† jour: ‚úÖ OK');
  } else {
    console.warn('‚ùì m√©trique manquante dans le DOM : conformityScoreMetric');
  }
  
  console.log('üî¢ Recalcul metrics - termin√©');
}

function updateLV2Details() {
  if (!window.chartLV2Details) return;
  
  const classes = Array.from(document.querySelectorAll('.class-column')).map(col => 
    col.querySelector('.classe-name').textContent
  ).sort();
  
  const lv2Types = ['ESP', 'ITA', 'ALL', 'LATIN', 'GRECO'];
  const colors = ['#dc2626', '#059669', '#2563eb', '#7c3aed', '#d97706'];
  
  window.chartLV2Details.data.labels = classes;
  window.chartLV2Details.data.datasets = lv2Types.map((lv2, index) => ({
    label: lv2,
    data: classes.map(classe => {
      const zone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
      if (!zone) return 0;
      return Array.from(zone.querySelectorAll('.student-card')).filter(card => {
        const eleve = STATE.students[card.dataset.id];
        return eleve && eleve.lv2 && eleve.lv2.toUpperCase() === lv2;
      }).length;
    }),
    backgroundColor: colors[index],
    stack: 'Stack 0'
  }));
  
  window.chartLV2Details.update();
}

function updateConformityGrid() {
  const grid = document.getElementById('conformityGrid');
  if (!grid) return;
  
  const classes = Array.from(document.querySelectorAll('.class-column')).map(col => 
    col.querySelector('.classe-name').textContent
  ).sort();
  
  let html = '';
  classes.forEach(classe => {
    const zone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
    if (!zone) return;
    
    const cards = Array.from(zone.querySelectorAll('.student-card'));
    const total = cards.length;
    const filles = cards.filter(card => {
      const eleve = STATE.students[card.dataset.id];
      return eleve && eleve.sexe === 'F';
    }).length;
    
    const ratio = total > 0 ? Math.round((filles / total) * 100) : 0;
    let status = 'conformity-undefined';
    let text = '?';
    
    if (ratio >= 40 && ratio <= 60) {
      status = 'conformity-ok';
      text = 'OK';
    } else if (ratio >= 30 && ratio <= 70) {
      status = 'conformity-warning';
      text = '!';
    } else {
      status = 'conformity-error';
      text = '‚úó';
    }
    
    html += `<div class="conformity-cell ${status}" title="${classe}: ${ratio}% filles">${text}</div>`;
  });
  
  grid.innerHTML = html;
}

function updateBalanceIndicators() {
  const container = document.getElementById('balanceIndicators');
  if (!container) return;
  
  const suggestions = [];
  
  // Analyser l'√©quilibre des sexes
  document.querySelectorAll('.class-column').forEach(column => {
    const classe = column.querySelector('.classe-name').textContent;
    const cards = Array.from(column.querySelectorAll('.student-card'));
    const total = cards.length;
    const filles = cards.filter(card => {
      const eleve = STATE.students[card.dataset.id];
      return eleve && eleve.sexe === 'F';
    }).length;
    
    const ratio = total > 0 ? Math.round((filles / total) * 100) : 0;
    
    if (ratio < 30) {
      suggestions.push({
        type: 'warning',
        message: `${classe}: Trop peu de filles (${ratio}%)`,
        icon: 'fa-exclamation-triangle'
      });
    } else if (ratio > 70) {
      suggestions.push({
        type: 'warning',
        message: `${classe}: Trop peu de gar√ßons (${100-ratio}%)`,
        icon: 'fa-exclamation-triangle'
      });
    }
  });
  
  if (suggestions.length === 0) {
    suggestions.push({
      type: 'success',
      message: '√âquilibre des sexes satisfaisant',
      icon: 'fa-check-circle'
    });
  }
  
  const html = suggestions.map(s => `
    <div class="indicator-card indicator-${s.type === 'success' ? 'good' : 'warning'}">
      <i class="fas ${s.icon} mr-2"></i>
      ${s.message}
    </div>
  `).join('');
  
  container.innerHTML = html;
}

// --- Responsive : recalculer √† chaque resize de la fen√™tre (avec debounce) ---
let resizeTimeout = null;
window.addEventListener('resize', () => {
  if (STATE.viewMode !== 'simple') return;
  if (resizeTimeout) clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    document.querySelectorAll('.droppable-zone').forEach(zone => adjustSimpleNamesFontSize(zone));
  }, 100);
});

// (FONCTION openStartupModal SUPPRIM√âE - DOUBLON)

// FONCTIONS MANQUANTES - √Ä ajouter dans le script principal

// 1. Gestion du mode sombre depuis localStorage
function initDarkMode() {
  try {
    const saved = (typeof localStorage !== 'undefined')
      ? localStorage.getItem('darkMode')
      : null;
    const isDark = saved === 'true';
    STATE.darkMode = !!isDark;
    document.body.classList.toggle('dark-mode', STATE.darkMode);
  } catch (e) {
    console.warn('Could not access localStorage for dark mode.', e);
  }
}

// API d√©terministe pour activer/d√©sactiver le mode sombre
function setDarkMode(on) {
  if (!!on === !!STATE.darkMode) return; // d√©j√† dans le bon √©tat
  toggleDarkMode();
}

// 2. Tutoriel interactif AM√âLIOR√â
function showTutorial() {
  if (window.OnboardingTour && typeof window.OnboardingTour.start === 'function') {
    window.OnboardingTour.start();
  } else {
    console.error('Tutoriel indisponible (Shepherd non charge)');
    if (typeof window.toast === 'function') {
      toast("Le tutoriel n'a pas pu se lancer.", 'error');
    } else {
      alert("Le tutoriel n'a pas pu se lancer.");
    }
  }
}


// 3. Actualisation intelligente (d√©j√† pr√©sente mais toast am√©lior√©)
window.attemptRefresh = async function() {
  showSpinner();
  try {
    const currentMode = localStorage.getItem('mode-selection') || 'TEST';
    const success = await loadDataForMode(currentMode);
    if (success) {
      toast('Donn√©es actualis√©es avec succ√®s', 'success');
    } else {
      toast('√âchec de l\'actualisation', 'error');
    }
  } catch (error) {
    console.error('Erreur actualisation:', error);
    toast('Erreur lors de l\'actualisation', 'error');
  } finally {
    hideSpinner();
  }
}

// 4. Am√©lioration de la fonction de recherche
function enhanceSearch() {
  const searchInput = document.getElementById('search');
  let searchTimeout;
  if (!searchInput) return;
  searchInput.addEventListener('input', (e) => {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
      const term = e.target.value.toLowerCase().trim();
      STATE.searchTerm = term;
      let matchCount = 0;
      document.querySelectorAll('.student-card').forEach(card => {
        const nameEl = card.querySelector('.student-fullname, .student-simple-name');
        if (!nameEl) return;
        const fullName = nameEl.textContent.toLowerCase();
        const eleve = STATE.students[card.dataset.id];
        const searchText = [fullName, eleve?.lv2?.toLowerCase() || '', eleve?.opt?.toLowerCase() || '', eleve?.mobilite?.toLowerCase() || ''].join(' ');
        const match = !term || searchText.includes(term);
        card.style.display = match ? '' : 'none';
        card.classList.toggle('search-highlight', match && term);
        if (match) matchCount++;
      });
      if (term) {
        toast(`${matchCount} √©l√®ve(s) trouv√©(s)`, 'info');
      }
    }, 300);
  });
  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.key === 'f') {
      e.preventDefault();
      searchInput.focus();
      searchInput.select();
    }
  });
}

// 5. Syst√®me de notifications persistantes
function createNotificationSystem() {
  if (!document.getElementById('notificationContainer')) {
    const container = document.createElement('div');
    container.id = 'notificationContainer';
    container.className = 'fixed top-20 right-4 z-50 space-y-2 max-w-sm';
    document.body.appendChild(container);
  }
}
function showPersistentNotification(message, type = 'info', duration = 5000) {
  createNotificationSystem();
  const container = document.getElementById('notificationContainer');
  const notification = document.createElement('div');
  const bgColors = { success: 'bg-green-500', error: 'bg-red-500', warning: 'bg-yellow-500', info: 'bg-blue-500' };
  const icons = { success: 'fa-check-circle', error: 'fa-exclamation-circle', warning: 'fa-exclamation-triangle', info: 'fa-info-circle' };
  notification.className = `${bgColors[type]} text-white p-3 rounded-lg shadow-lg transform translate-x-full transition-transform duration-300 flex items-center gap-2`;
  notification.innerHTML = `<i class="fas ${icons[type]}"></i><span class="flex-1">${message}</span><button onclick="this.parentElement.remove()" class="text-white hover:text-gray-200"><i class="fas fa-times"></i></button>`;
  container.appendChild(notification);
  setTimeout(() => { notification.classList.remove('translate-x-full'); }, 100);
  if (duration > 0) {
    setTimeout(() => { notification.classList.add('translate-x-full'); setTimeout(() => notification.remove(), 300); }, duration);
  }
}

// 6. Am√©lioration du syst√®me d'aide
function createContextualHelp() {
  const helpButton = document.getElementById('btnTutorial');
  if (helpButton) {
    helpButton.addEventListener('click', () => {
      // Ne plus marquer comme vu au clic, seulement √† la fin du tutoriel
      showTutorial();
    });
  }
}

// 7. Gestion des pr√©f√©rences utilisateur
function saveUserPreferences() {
  const preferences = {
    viewMode: STATE.viewMode,
    darkMode: STATE.darkMode,
    lastFilter: activeFilter || 'all'
  };
  localStorage.setItem('userPreferences', JSON.stringify(preferences));
}
function loadUserPreferences() {
  try {
    const saved = localStorage.getItem('userPreferences');
    if (saved) {
      const prefs = JSON.parse(saved);
      // G√©rer l'ancienne propri√©t√© simpleView pour la compatibilit√©
      if (prefs.simpleView !== undefined && prefs.viewMode === undefined) {
        STATE.viewMode = prefs.simpleView ? 'simple' : 'complete';
        localStorage.setItem('viewMode', STATE.viewMode);
      }
      // MODE SOMBRE D√âSACTIV√â PAR D√âFAUT (ne pas charger depuis localStorage)
      // L'utilisateur doit activer manuellement le mode sombre √† chaque session
      // Nettoyer darkMode du localStorage pour √©viter toute r√©activation
      if (prefs.darkMode) {
        delete prefs.darkMode;
        localStorage.setItem('userPreferences', JSON.stringify(prefs));
        console.log('üåû Mode sombre nettoy√© du localStorage (d√©sactiv√© par d√©faut)');
      }
      
      if (prefs.lastFilter && prefs.lastFilter !== 'all') { setTimeout(() => applyQuickFilter(prefs.lastFilter), 1000); }
    }
  } catch (e) { console.warn('Erreur chargement pr√©f√©rences:', e); }
}

// 8. Fonction d'initialisation globale am√©lior√©e
function initializeEnhancements() {
  loadUserPreferences();
  initDarkMode();
  enhanceSearch();
  createContextualHelp();
  createNotificationSystem();
  window.addEventListener('beforeunload', saveUserPreferences);

  // ========== ANCIEN TUTORIEL D√âSACTIV√â ==========
  // Remplac√© par OnboardingTour.autoStart() dans InterfaceV2_UIModules_Loader.html
  // if (!localStorage.getItem('hasSeenTutorial')) {
  //   setTimeout(() => {
  //     if (confirm('Premi√®re visite ? Voulez-vous voir le tutoriel interactif ?')) {
  //       showTutorial();
  //     }
  //     localStorage.setItem('hasSeenTutorial', 'true');
  //   }, 2000);
  // }
}
// ... existing code ...
// √Ä la fin du DOMContentLoaded, apr√®s setupEventListeners() et openStartupModal();
initializeEnhancements();
// ... existing code ...

// ========== PATCH DE CORRECTIONS CRITIQUES ==========

// 1. FIX: Historique timeline qui ne s'affiche pas
function addToHistory(action) {
  action.timestamp = new Date().toISOString();
  
  if (action.eleveId) {
    const eleve = STATE.students[action.eleveId];
    action.eleveName = eleve ? `${eleve.nom} ${eleve.prenom || ''}` : 'Inconnu';
  }
  
  // Ajouter l'action √† l'historique global
  if (!STATE.historyTimeline) STATE.historyTimeline = [];
  STATE.historyTimeline.push(action);
  
  // Mettre √† jour le panneau
  updateHistoryPanel();
}

function updateHistoryPanel() {
  const container = document.getElementById('historyTimeline');
  if (!container) return;
  
  container.innerHTML = '';
  
  // Utiliser historyTimeline au lieu de history
  const timeline = STATE.historyTimeline || [];
  
  timeline.slice().reverse().forEach((action, idx) => {
    const item = document.createElement('div');
    item.className = 'timeline-item';
    
    let actionText = '';
    let details = '';
    let icon = 'fa-question';
    let color = '#6b7280';
    
    switch (action.type) {
      case 'move':
        actionText = `D√©placement: ${action.eleveName || '√âl√®ve'}`;
        details = `${action.oldClasse} ‚Üí ${action.newClasse}`;
        icon = 'fa-arrow-right';
        color = '#3b82f6';
        break;
      case 'swap':
        const eleve1 = STATE.students[action.id1];
        const eleve2 = STATE.students[action.id2];
        actionText = `√âchange effectu√©`;
        details = `${eleve1?.nom || '√âl√®ve 1'} ‚Üî ${eleve2?.nom || '√âl√®ve 2'}`;
        icon = 'fa-exchange-alt';
        color = '#f59e0b';
        break;
    }
    
    item.innerHTML = `
      <div class="timeline-dot" style="background: ${color};">
        <i class="fas ${icon} text-xs"></i>
      </div>
      <div class="timeline-content">
        <div class="timeline-time">${new Date(action.timestamp).toLocaleTimeString('fr-FR')}</div>
        <div class="timeline-action">${actionText}</div>
        <div class="timeline-details">${details}</div>
      </div>
    `;
    
    container.appendChild(item);
  });
  
  // Afficher un message si vide
  if (timeline.length === 0) {
    container.innerHTML = '<div class="text-center text-gray-500 p-4">Aucune action enregistr√©e</div>';
  }
}

// Attacher updateHistoryPanel √† window
window.updateHistoryPanel = updateHistoryPanel;

// FIX 1: Historique qui ne persiste pas correctement
if (!STATE.historyTimeline) {
  STATE.historyTimeline = [];
}



// 4. FIX: Styles manquants pour la timeline
const timelineStyles = document.createElement('style');
timelineStyles.textContent = `
  .timeline-item {
    position: relative;
    padding-left: 2.5rem;
    cursor: pointer;
    transition: all 0.2s;
  }
  
  .timeline-item:hover {
    background: #f8fafc;
  }
  
  .timeline-item::before {
    content: '';
    position: absolute;
    left: 1.25rem;
    top: 2rem;
    bottom: -1rem;
    width: 2px;
    background: #e5e7eb;
  }
  
  .timeline-item:last-child::before {
    display: none;
  }
  
  .timeline-dot {
    position: absolute;
    left: 0.75rem;
    top: 0.75rem;
    width: 2rem;
    height: 2rem;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }
  
  .timeline-content {
    padding: 0.5rem 0;
  }
  
  .timeline-time {
    font-size: 0.75rem;
    color: #6b7280;
    margin-bottom: 0.25rem;
  }
  
  .timeline-action {
    font-weight: 600;
    color: #1e293b;
    margin-bottom: 0.25rem;
  }
  
  .timeline-details {
    font-size: 0.875rem;
    color: #4b5563;
  }
`;
document.head.appendChild(timelineStyles);

// 5. FIX: Variable activeFilter non d√©finie globalement
window.activeFilter = 'all';

// 6. FIX: Fonction applyQuickFilter am√©lior√©e
window.applyQuickFilter = function(filter) {
  window.activeFilter = filter;
  
  // Mettre √† jour les boutons
  document.querySelectorAll('.filter-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.filter === filter);
  });
  
  // Appliquer le filtre
  let visibleCount = 0;
  document.querySelectorAll('.student-card').forEach(card => {
    const eleve = STATE.students[card.dataset.id];
    if (!eleve) return;
    
    let match = false;
    
    switch (filter) {
      case 'all':
        match = true;
        break;
      case 'PERMUT':
      case 'FIXE':
        match = eleve.mobilite === filter;
        break;
      case 'ESP':
      case 'ITA':
      case 'ALL':
        match = eleve.lv2 === filter;
        break;
      case 'D':
        match = !!eleve.disso;
        break;
      case 'A':
        match = !!eleve.asso;
        break;
    }
    
    card.classList.toggle('filtered-out', !match);
    if (match) visibleCount++;
  });
  
  // Notification du r√©sultat
  if (filter !== 'all') {
    toast(`${visibleCount} √©l√®ve(s) avec filtre "${filter}"`, 'info');
  }
};

// 7. FIX: Meilleure gestion des tooltips
document.addEventListener('DOMContentLoaded', () => {
  // Ajouter des tooltips riches sur les badges
  document.addEventListener('mouseover', (e) => {
    if (e.target.classList.contains('mini-badge')) {
      const title = e.target.getAttribute('title');
      if (!title) return;
      
      // Cr√©er un tooltip personnalis√© si n√©cessaire
      const existingTooltip = document.querySelector('.custom-tooltip');
      if (existingTooltip) existingTooltip.remove();
      
      const tooltip = document.createElement('div');
      tooltip.className = 'custom-tooltip';
      tooltip.textContent = title;
      tooltip.style.cssText = `
        position: absolute;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.75rem;
        z-index: 9999;
        pointer-events: none;
        white-space: nowrap;
      `;
      
      const rect = e.target.getBoundingClientRect();
      tooltip.style.left = rect.left + 'px';
      tooltip.style.top = (rect.bottom + 5) + 'px';
      
      document.body.appendChild(tooltip);
    }
  });
  
  document.addEventListener('mouseout', (e) => {
    if (e.target.classList.contains('mini-badge')) {
      document.querySelector('.custom-tooltip')?.remove();
    }
  });
});

// 8. FIX: Am√©lioration de la sauvegarde imm√©diate
window.saveImmediateCache = async function() {
  try {
    // 1. Ne rien faire si l'utilisateur n'a rien boug√©
    if (!STATE.has_user_action) {
      console.debug('‚è≠Ô∏è Auto-save saut√© (aucune action)');
      return;
    }

    const disposition = exportDisposition();
    const cacheData = {
      date: new Date().toISOString(),
      disposition: disposition,
      mode: STATE.currentMode,
      filters: window.activeFilter,
      stats: {
        total: Object.keys(STATE.students).length,
        classes: document.querySelectorAll('.class-column').length
      }
    };
    
    // Sauvegarde locale avec compression
    localStorage.setItem('cache-data', JSON.stringify(cacheData));
    localStorage.setItem('cache-timestamp', new Date().toISOString());
    
    // Sauvegarde distante si disponible
    if (typeof gsRun === 'function') {
      try {
        const result = await gsRun('saveCacheData', cacheData);
        
        if (result && result.success) {
          console.log('üíæ Sauvegarde automatique CACHE r√©ussie');
          
          // 2. Apr√®s succ√®s ‚Üí reset flag + horodatage + badge
          STATE.has_user_action = false;
          STATE.last_save_ts = Date.now();
          
          if (typeof updateSaveBadge === 'function') {
            updateSaveBadge(true);
          }
          
          // Indicateur visuel de sauvegarde
          const saveIndicator = document.createElement('div');
          saveIndicator.className = 'fixed top-20 right-4 bg-green-500 text-white px-3 py-1 rounded-full text-sm';
          saveIndicator.innerHTML = '<i class="fas fa-check mr-1"></i> Sauvegard√©';
          document.body.appendChild(saveIndicator);
          
          setTimeout(() => saveIndicator.remove(), 2000);
        } else {
          console.warn('‚ö†Ô∏è Sauvegarde CACHE √©chou√©e');
          if (typeof updateSaveBadge === 'function') {
            updateSaveBadge(false);
          }
        }
      } catch (error) {
        console.error('‚ùå Erreur sauvegarde CACHE:', error);
        if (typeof updateSaveBadge === 'function') {
          updateSaveBadge(false);
        }
      }
    }
  } catch (error) {
    console.error('Erreur sauvegarde cache:', error);
  }
};

// 9. FIX: Indicateur de connexion Google Apps Script
function checkGoogleAppsConnection() {
  const indicator = document.createElement('div');
  indicator.className = 'fixed bottom-4 right-4 text-xs';
  
  if (typeof google !== 'undefined' && google.script) {
    indicator.innerHTML = '<i class="fas fa-cloud text-green-500"></i> Connect√© √† Google';
  } else {
    indicator.innerHTML = '<i class="fas fa-cloud-slash text-gray-400"></i> Mode local';
  }
  
  document.body.appendChild(indicator);
  setTimeout(() => indicator.remove(), 3000);
}

// Appeler au chargement
setTimeout(checkGoogleAppsConnection, 1000);

// 10. FIX: Am√©lioration du tri des colonnes
window.sortColumn = function(classe, sortType, direction = 'asc') {
  const dropZone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
  if (!dropZone) return;

  const cards = Array.from(dropZone.querySelectorAll('.student-card'));
  const students = cards.map(card => ({
    card,
    data: STATE.students[card.dataset.id]
  })).filter(item => item.data); // Filtrer les √©l√©ments invalides

  const f = direction === 'asc' ? 1 : -1;

  switch (sortType) {
    case 'name':
      students.sort((a, b) => {
        const nameA = `${a.data.nom} ${a.data.prenom || ''}`.trim();
        const nameB = `${b.data.nom} ${b.data.prenom || ''}`.trim();
        return f * nameA.localeCompare(nameB, 'fr');
      });
      break;

    case 'lv2':
      students.sort((a, b) => {
        const ordre = ['ESP', 'ITA', 'ALL', 'LATIN', 'GRECO'];
        const lv2A = (a.data.lv2 || '').toUpperCase();
        const lv2B = (b.data.lv2 || '').toUpperCase();
        const iA = ordre.indexOf(lv2A);
        const iB = ordre.indexOf(lv2B);
        return f * ((iA === -1 ? 999 : iA) - (iB === -1 ? 999 : iB));
      });
      break;

    case 'option':
      students.sort((a, b) => {
        const optA = a.data.opt || 'ZZZZ';
        const optB = b.data.opt || 'ZZZZ';
        return f * optA.localeCompare(optB);
      });
      break;

    case 'score':
      students.sort((a, b) => {
        const scoreA = a.data.scores?.COM || 0;
        const scoreB = b.data.scores?.COM || 0;
        // Pour les scores, inverser la logique (meilleurs en haut)
        return -f * (scoreB - scoreA);
      });
      break;
  }

  // R√©injecter dans le DOM avec animation
  dropZone.style.opacity = '0.5';
  dropZone.innerHTML = '';
  students.forEach(({ card }, index) => {
    setTimeout(() => {
      dropZone.appendChild(card);
      if (index === students.length - 1) {
        dropZone.style.opacity = '1';
      }
    }, index * 10);
  });

  STATE.sortOrder[classe] = { type: sortType, dir: direction };
  
  // Notification
  toast(`Classe ${classe} tri√©e par ${sortType}`, 'info');
};

console.log('‚úÖ Patch de corrections appliqu√©');

// ========== MODULE DE GROUPES V2 - INTERFACE CLARIFI√âE ==========

// FIX: Ajout d'un bouton Groupes dans le header - Version modulaire
function addGroupsButton() {
  
  const nav = document.querySelector('.app-header nav');
  if (!nav || document.getElementById('btnGroups')) return;
  
  // Cr√©er un wrapper pour le bouton et son menu
  const groupsWrapper = document.createElement('div');
  groupsWrapper.className = 'relative';
  groupsWrapper.id = 'groupsMenuWrapper';
  
  // Bouton principal avec fl√®che
  const btnGroups = document.createElement('button');
  btnGroups.id = 'btnGroups';
  btnGroups.className = 'btn btn-primary flex items-center gap-1';
  btnGroups.innerHTML = '<i class="fas fa-layer-group"></i> Groupes <i class="fas fa-caret-down"></i>';
  
  // Menu d√©roulant
  const dropdown = document.createElement('div');
  dropdown.id = 'groupsDropdown';
  dropdown.className = 'absolute right-0 mt-2 w-64 bg-white rounded shadow-lg z-50 hidden p-2';
  dropdown.innerHTML = `
    <div class="px-2 py-2 border-b border-gray-200 mb-2">
      <div class="text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">Param√®tres Groupes</div>
      <label class="flex items-center gap-2 text-sm cursor-pointer">
        <input type="checkbox" id="toggleHeaderGroups" onchange="toggleHeaderGroups(this.checked)">
        <span>Afficher le bouton Groupes dans le header</span>
      </label>
    </div>
    <button onclick="openGroupsInterface()" class="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2">
      <i class="fas fa-plus-circle text-green-600"></i> Cr√©er des groupes
    </button>
    <button onclick="openGroupsInterface('manager')" class="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2">
      <i class="fas fa-cog text-blue-600"></i> G√©rer les groupes
    </button>
    <button onclick="openGroupsInterface('templates')" class="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2">
      <i class="fas fa-layer-group text-purple-600"></i> Mod√®les de groupes
    </button>
    <hr class="my-2 border-gray-200">
    <button onclick="exportGroupsData()" class="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2">
      <i class="fas fa-download text-purple-600"></i> Exporter tous les groupes
    </button>
    <button onclick="confirmDeleteAllGroups()" class="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2 text-red-600">
      <i class="fas fa-trash"></i> Supprimer tous les groupes
    </button>
  `;
  
  groupsWrapper.appendChild(btnGroups);
  groupsWrapper.appendChild(dropdown);
  
  // G√©rer l'ouverture/fermeture du menu
  btnGroups.addEventListener('click', (e) => {
    e.stopPropagation();
    // Fermer tous les autres dropdowns
    document.querySelectorAll('.app-header .absolute').forEach(d => {
      if (d !== dropdown) d.classList.add('hidden');
    });
    dropdown.classList.toggle('hidden');
  });
  
  // Fermer le menu si on clique ailleurs
  document.addEventListener('click', () => {
    dropdown.classList.add('hidden');
  });
  
  dropdown.addEventListener('click', e => e.stopPropagation());
  
  // Placement id√©al: entre Brouillon (#btnSaveWIP) et √âdition (#btnEdition)
  const btnBrouillon = document.getElementById('btnSaveWIP');
  const btnEdition = document.getElementById('btnEdition');
  if (btnBrouillon && btnBrouillon.parentElement) {
    btnBrouillon.insertAdjacentElement('afterend', groupsWrapper);
  } else if (btnEdition && btnEdition.parentElement) {
    btnEdition.parentElement.insertBefore(groupsWrapper, btnEdition);
  } else {
    nav.appendChild(groupsWrapper);
  }

  // Initialiser l'√©tat du toggle √† partir du serveur
  if (typeof google !== 'undefined' && google.script && google.script.run) {
    google.script.run
      .withSuccessHandler(function(settings){
        const cb = document.getElementById('toggleHeaderGroups');
        if (cb && settings) cb.checked = !!settings.SHOW_GROUPS_BUTTON;
      })
      .withFailureHandler(function(err){ console.error('Erreur getUiSettings:', err); })
      .getUiSettings();
  }
}

// Retirer le bouton Groupes du header si pr√©sent
function removeGroupsButton() {
  const wrapper = document.getElementById('groupsMenuWrapper') || document.getElementById('btnGroups')?.parentElement;
  if (wrapper && wrapper.parentElement) {
    wrapper.parentElement.removeChild(wrapper);
  }
}

// Handler pour le toggle dans le menu Groupes
function toggleHeaderGroups(checked) {
  if (typeof google !== 'undefined' && google.script && google.script.run) {
    google.script.run
      .withSuccessHandler(function(){
        if (checked) { addGroupsButton(); } else { removeGroupsButton(); }
        if (typeof toast === 'function') toast(checked ? 'Bouton Groupes activ√©' : 'Bouton Groupes d√©sactiv√©', 'success');
      })
      .withFailureHandler(function(err){
        console.error('Erreur setUiSettings:', err);
        if (typeof toast === 'function') toast('Erreur: ' + err.message, 'error');
      })
      .setUiSettings({ SHOW_GROUPS_BUTTON: !!checked });
  }
}

// Mettre √† jour le bouton pour afficher le nombre de groupes - Version modulaire
function updateGroupsButton() {
  const btn = document.getElementById('btnGroups');
  if (btn) {
    // R√©cup√©rer le nombre de groupes depuis le serveur
    google.script.run
      .withSuccessHandler(function(count) {
        if (count > 0) {
          btn.innerHTML = `<i class="fas fa-layer-group"></i> Groupes <span class="bg-purple-200 text-purple-800 px-2 py-0.5 rounded-full text-xs ml-1">${count}</span> <i class="fas fa-caret-down"></i>`;
        } else {
          btn.innerHTML = '<i class="fas fa-layer-group"></i> Groupes <i class="fas fa-caret-down"></i>';
        }
      })
      .getGroupsCount();
  }
}

// Fonction pour notifier les changements de groupes
function notifyGroupsChanged() {
  updateGroupsButton();
  // Autres actions √† effectuer quand les groupes changent
  console.log('üìä Groupes mis √† jour');
}

// ========== CODE √Ä AJOUTER/MODIFIER DANS INTERFACEV2.HTML ==========

// 1. Fonction unifi√©e openGroupsInterface - utilise le nouveau GroupsModuleComplete (modal int√©gr√©e)
function openGroupsInterface(tab = 'creator') {
  console.log('üöÄ Ouverture de l\'interface des groupes via GroupsModuleComplete...');

  // V√©rifier si GroupsModuleComplete est disponible (groupsModuleComplete.html)
  if (typeof window !== 'undefined' && window.GroupsModuleComplete && typeof window.GroupsModuleComplete.open === 'function') {
    try {
      window.GroupsModuleComplete.open();
      console.log('‚úÖ GroupsModuleComplete ouvert avec succ√®s');
      return;
    } catch (error) {
      console.error('‚ùå Erreur lors de l\'ouverture de GroupsModuleComplete:', error);
    }
  }

  // FALLBACK : Si GroupsModuleComplete n'est pas disponible, utiliser l'ancienne interface popup
  console.warn('‚ö†Ô∏è GroupsModuleComplete non disponible, fallback vers interface popup...');
  google.script.run
    .withSuccessHandler(function(html) {
      try {
        const groupsWindow = window.open('', 'GroupsManager', 'width=1400,height=900,menubar=no,toolbar=no,scrollbars=yes,resizable=yes');

        if (!groupsWindow || groupsWindow.closed || typeof groupsWindow.closed === 'undefined') {
          console.error('‚ùå Impossible d\'ouvrir la fen√™tre popup - bloqu√©e par le navigateur');
          alert('‚ö†Ô∏è Impossible d\'ouvrir l\'interface des groupes. Veuillez autoriser les popups pour ce site et r√©essayer.');
          return;
        }

        groupsWindow.document.open();
        groupsWindow.document.write(html);
        groupsWindow.document.close();

        const checkInterval = setInterval(() => {
          try {
            if (groupsWindow.GroupsUI && typeof groupsWindow.GroupsUI.switchTab === 'function') {
              clearInterval(checkInterval);
              groupsWindow.GroupsUI.switchTab(tab);
              console.log('‚úÖ Interface des groupes popup ouverte avec succ√®s');
            }
          } catch (uiError) {
            clearInterval(checkInterval);
          }
        }, 100);

        setTimeout(() => clearInterval(checkInterval), 5000);
      } catch (error) {
        console.error('‚ùå Erreur lors de l\'ouverture de l\'interface:', error);
        alert('Erreur lors de l\'ouverture de l\'interface des groupes: ' + error.message);
      }
    })
    .withFailureHandler(function(error) {
      console.error('‚ùå Erreur serveur:', error);
      alert('Impossible de charger l\'interface des groupes: ' + error.message);
    })
    .getGroupsInterface();
}

// 2. Fonction pour notifier les changements de groupes
window.notifyGroupsChanged = function() {
  console.log('üì¢ Notification de changement de groupes re√ßue');
  updateGroupsButton();
  
  // Afficher un message de confirmation
  if (typeof toast === 'function') {
    toast('Groupes mis √† jour avec succ√®s', 'success');
  }
};

// 3. Fonction d'export am√©lior√©e
function exportGroupsData() {
  console.log('üì§ Export des groupes...');
  
  google.script.run
    .withSuccessHandler(function(groupsData) {
      if (!groupsData || Object.keys(groupsData).length === 0) {
        alert('Aucun groupe √† exporter');
        return;
      }
      
      // Cr√©er le CSV avec point-virgule comme s√©parateur (compatible Excel FR)
      let csv = 'Type;Groupe;Nom;Pr√©nom;Sexe;Classe d\'origine;Langue;Score COM;Score TRA;Score PART;Score ABS;Score Maths;Score Fran√ßais\n';
      
      Object.entries(groupsData).forEach(([groupName, groupData]) => {
        groupData.students.forEach(student => {
          // Construire la ligne sans guillemets inutiles
          const line = [
            groupData.type || 'N/A',
            groupName,
            student.nom || '',
            student.prenom || '',
            student.sexe || '',
            student.classe || '',
            student.lv1Badge || student.lv1 || '', // Badge de langue ou valeur brute
            student.com || 0,
            student.tra || 0,
            student.part || 0,
            student.abs || 0,
            student.scores?.M || 0,
            student.scores?.F || 0
          ];
          
          csv += line.join(';') + '\n';
        });
      });
      
      // T√©l√©charger le fichier
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `export_groupes_${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      toast('Export CSV g√©n√©r√© avec succ√®s', 'success');
    })
    .withFailureHandler(function(error) {
      console.error('Erreur export:', error);
      alert('Erreur lors de l\'export: ' + error.message);
    })
    .getAllGroups();
}

// 4. Fonction de suppression avec confirmation am√©lior√©e
function confirmDeleteAllGroups() {
  const modal = document.createElement('div');
  modal.className = 'fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50';
  modal.innerHTML = `
    <div class="bg-white rounded-lg shadow-xl p-6 max-w-md">
      <h3 class="text-lg font-bold mb-4 text-red-600">
        <i class="fas fa-exclamation-triangle mr-2"></i>
        Suppression de tous les groupes
      </h3>
      <p class="text-gray-700 mb-6">
        Cette action supprimera d√©finitivement tous les groupes cr√©√©s. 
        Cette op√©ration est irr√©versible.
      </p>
      <div class="flex justify-end gap-3">
        <button onclick="this.closest('.fixed').remove()" class="btn btn-secondary">
          Annuler
        </button>
        <button onclick="deleteAllGroups(); this.closest('.fixed').remove();" class="btn btn-danger">
          <i class="fas fa-trash mr-2"></i>
          Supprimer tout
        </button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
}

function deleteAllGroups() {
  google.script.run
    .withSuccessHandler(function(success) {
      if (success) {
        updateGroupsButton();
        toast('Tous les groupes ont √©t√© supprim√©s', 'success');
      } else {
        toast('Erreur lors de la suppression', 'error');
      }
    })
    .withFailureHandler(function(error) {
      console.error('Erreur suppression:', error);
      toast('Erreur: ' + error.message, 'error');
    })
    .deleteAllGroups();
}

// 5. Am√©lioration du menu dropdown des groupes - SUPPRIM√â
// Cette fonction est obsol√®te, remplac√©e par createEnhancedGroupsMenu() ligne 10828
// L'initialisation se fait via initGroupsModule() qui appelle createEnhancedGroupsMenu()

// 6. Initialisation au chargement - SUPPRIM√â (conflit avec initGroupsModule ligne 10771)
// Les fonctions initializeGroupsButton() et initializeGroupsMenu() n'existent pas
// L'initialisation se fait via initGroupsModule() qui appelle createEnhancedGroupsMenu()


// ========== FONCTIONS SUPPL√âMENTAIRES ==========

// Fonction pour ajouter des scores de mati√®res
window.addSubjectScores = function() {
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.innerHTML = `
    <div class="modal-content" style="max-width: 600px;">
      <div class="modal-header">
        <h2 class="text-xl font-bold">Ajouter des scores de mati√®res</h2>
        <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="modal-body">
        <div class="bg-blue-50 p-3 rounded mb-4">
          <p class="text-sm text-blue-800">
            <i class="fas fa-info-circle mr-1"></i>
            Importez un fichier Excel avec les colonnes : ID, MATH, FR
            ou saisissez manuellement les scores.
          </p>
        </div>
        
        <div class="mb-4">
          <button onclick="importSubjectScores()" class="btn btn-primary w-full">
            <i class="fas fa-upload"></i> Importer depuis Excel
          </button>
        </div>
        
        <div class="text-center text-gray-500 my-4">ou</div>
        
        <div>
          <h3 class="font-bold mb-2">Saisie manuelle rapide</h3>
          <div class="text-xs text-gray-600 mb-2">
            S√©lectionnez une classe et attribuez des scores al√©atoires pour tester
          </div>
          <select id="classForScores" class="form-control mb-2">
            <option value="">-- S√©lectionner une classe --</option>
            ${Array.from(document.querySelectorAll('.classe-name'))
              .map(el => `<option value="${el.textContent}">${el.textContent}</option>`)
              .join('')}
          </select>
          <button onclick="generateRandomScores()" class="btn btn-secondary w-full">
            <i class="fas fa-dice"></i> G√©n√©rer des scores al√©atoires
          </button>
        </div>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
};

// G√©n√©rer des scores al√©atoires pour tester
window.generateRandomScores = function() {
  const classe = document.getElementById('classForScores').value;
  if (!classe) {
    toast('S√©lectionnez une classe', 'warning');
    return;
  }
  
  const zone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
  if (!zone) return;
  
  let count = 0;
  zone.querySelectorAll('.student-card').forEach(card => {
    const eleve = STATE.students[card.dataset.id];
    if (eleve) {
      // G√©n√©rer des scores coh√©rents avec le comportement
      const baseScore = eleve.scores?.C || 2.5;
      const variance = 0.5;
      
      eleve.scores.MATH = Math.max(1, Math.min(4, 
        baseScore + (Math.random() - 0.5) * 2 * variance
      ));
      
      eleve.scores.FR = Math.max(1, Math.min(4, 
        baseScore + (Math.random() - 0.5) * 2 * variance
      ));
      
      count++;
    }
  });
  
  toast(`${count} scores g√©n√©r√©s pour ${classe}`, 'success');
  document.querySelector('.modal').remove();
};

// ========== AM√âLIORATIONS PRIORITAIRES V2 ==========

// 0. FEEDBACK EN TEMPS R√âEL
window.RealTimeFeedback = {
  previousMetrics: null,
  isMinimized: false,
  
  // Initialiser le syst√®me de feedback
  init() {
    this.setupEventListeners();
    // Ne pas afficher automatiquement - seulement quand on est dans le menu des groupes
    this.updateMetrics();
  },
  
  // Configurer les √©v√©nements
  setupEventListeners() {
    // Minimiser/maximiser le panneau
    document.getElementById('minimizeFeedback')?.addEventListener('click', () => {
      this.toggleMinimize();
    });
    
    // Fermer le panneau
    document.getElementById('closeFeedback')?.addEventListener('click', () => {
      this.hide();
    });
    
    // Rendre le panneau d√©pla√ßable
    this.makeDraggable();
  },
  
  // Rendre le panneau d√©pla√ßable
  makeDraggable() {
    const panel = document.getElementById('feedbackPanel');
    const header = panel?.querySelector('.feedback-header');
    
    if (!panel || !header) return;
    
    let isDragging = false;
    let startX, startY, startLeft, startTop;
    
    header.addEventListener('mousedown', (e) => {
      if (e.target.tagName === 'BUTTON') return;
      
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      startLeft = parseInt(panel.style.left) || 0;
      startTop = parseInt(panel.style.top) || 0;
      
      panel.style.cursor = 'grabbing';
    });
    
    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      
      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;
      
      panel.style.left = (startLeft + deltaX) + 'px';
      panel.style.top = (startTop + deltaY) + 'px';
    });
    
    document.addEventListener('mouseup', () => {
      isDragging = false;
      panel.style.cursor = 'grab';
    });
  },
  
  // Afficher le panneau
  show() {
    const panel = document.getElementById('feedbackPanel');
    if (panel) {
      panel.style.display = 'block';
    }
  },
  
  // Masquer le panneau
  hide() {
    const panel = document.getElementById('feedbackPanel');
    if (panel) {
      panel.style.display = 'none';
    }
  },
  
  // Basculer minimisation
  toggleMinimize() {
    const panel = document.getElementById('feedbackPanel');
    if (!panel) return;
    
    this.isMinimized = !this.isMinimized;
    panel.classList.toggle('minimized', this.isMinimized);
    
    const icon = document.querySelector('#minimizeFeedback i');
    if (icon) {
      icon.className = this.isMinimized ? 'fas fa-expand' : 'fas fa-minus';
    }
  },
  
  // Calculer les m√©triques actuelles
  calculateMetrics() {
    const metrics = {
      balance: this.calculateBalance(),
      constraints: this.calculateConstraints(),
      diversity: this.calculateDiversity(),
      size: this.calculateSizeBalance(),
      scores: this.calculateScoreBalance(),
      mobility: this.calculateMobilityBalance(),
      globalScore: this.calculateGlobalScore()
    };
    
    return metrics;
  },
  
  // Calculer l'√©quilibre F/M
  calculateBalance() {
    let totalImbalance = 0;
    let classCount = 0;
    
    document.querySelectorAll('.class-column').forEach(col => {
      const students = col.querySelectorAll('.student-card');
      const fCount = Array.from(students).filter(card => 
        STATE.students[card.dataset.id]?.sexe === 'F'
      ).length;
      const mCount = Array.from(students).filter(card => 
        STATE.students[card.dataset.id]?.sexe === 'M'
      ).length;
      
      const imbalance = Math.abs(fCount - mCount);
      totalImbalance += imbalance;
      classCount++;
    });
    
    return classCount > 0 ? totalImbalance / classCount : 0;
  },
  
  // Calculer les violations de contraintes
  calculateConstraints() {
    return ConstraintManager ? ConstraintManager.validateAllConstraints().length : 0;
  },
  
  // Calculer la diversit√© des scores
  calculateDiversity() {
    let totalDiversity = 0;
    let classCount = 0;
    
    document.querySelectorAll('.class-column').forEach(col => {
      const students = col.querySelectorAll('.student-card');
      const scores = Array.from(students).map(card => {
        const student = STATE.students[card.dataset.id];
        return (student?.scores?.M || 0) + (student?.scores?.F || 0);
      }).filter(score => score > 0);
      
      if (scores.length > 1) {
        const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
        const variance = scores.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / scores.length;
        totalDiversity += Math.sqrt(variance);
      }
      classCount++;
    });
    
    return classCount > 0 ? totalDiversity / classCount : 0;
  },
  
  // Calculer l'√©quilibre des tailles
  calculateSizeBalance() {
    const sizes = Array.from(document.querySelectorAll('.class-column')).map(col => 
      col.querySelectorAll('.student-card').length
    );
    
    if (sizes.length === 0) return 0;
    
    const mean = sizes.reduce((a, b) => a + b, 0) / sizes.length;
    const variance = sizes.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / sizes.length;
    
    return Math.sqrt(variance);
  },
  
  // Calculer l'√©quilibre des scores
  calculateScoreBalance() {
    let totalImbalance = 0;
    let classCount = 0;
    
    document.querySelectorAll('.class-column').forEach(col => {
      const students = col.querySelectorAll('.student-card');
      const scores = Array.from(students).map(card => {
        const student = STATE.students[card.dataset.id];
        return (student?.scores?.M || 0) + (student?.scores?.F || 0);
      }).filter(score => score > 0);
      
      if (scores.length > 1) {
        const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
        const variance = scores.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / scores.length;
        totalImbalance += Math.sqrt(variance);
      }
      classCount++;
    });
    
    return classCount > 0 ? totalImbalance / classCount : 0;
  },
  
  // Calculer l'√©quilibre de mobilit√©
  calculateMobilityBalance() {
    let totalImbalance = 0;
    let classCount = 0;
    
    document.querySelectorAll('.class-column').forEach(col => {
      const students = col.querySelectorAll('.student-card');
      const permutCount = Array.from(students).filter(card => 
        STATE.students[card.dataset.id]?.mobilite === 'PERMUT'
      ).length;
      const fixeCount = Array.from(students).filter(card => 
        STATE.students[card.dataset.id]?.mobilite === 'FIXE'
      ).length;
      
      const imbalance = Math.abs(permutCount - fixeCount);
      totalImbalance += imbalance;
      classCount++;
    });
    
    return classCount > 0 ? totalImbalance / classCount : 0;
  },
  
  // Calculer le score global
  calculateGlobalScore() {
    const balance = this.calculateBalance();
    const constraints = this.calculateConstraints();
    const diversity = this.calculateDiversity();
    const size = this.calculateSizeBalance();
    const scores = this.calculateScoreBalance();
    const mobility = this.calculateMobilityBalance();
    
    // Score invers√© (plus c'est bas, mieux c'est)
    const balanceScore = Math.max(0, 10 - balance * 2);
    const constraintScore = Math.max(0, 10 - constraints * 2);
    const diversityScore = Math.min(10, diversity);
    const sizeScore = Math.max(0, 10 - size);
    const scoreBalance = Math.min(10, scores);
    const mobilityScore = Math.max(0, 10 - mobility);
    
    return (balanceScore + constraintScore + diversityScore + sizeScore + scoreBalance + mobilityScore) / 6;
  },
  
  // Mettre √† jour l'affichage des m√©triques
  updateMetrics() {
    const currentMetrics = this.calculateMetrics();
    
    // Mettre √† jour les valeurs
    this.updateMetricValue('balanceValue', currentMetrics.balance.toFixed(1));
    this.updateMetricValue('constraintsValue', currentMetrics.constraints);
    this.updateMetricValue('diversityValue', currentMetrics.diversity.toFixed(1));
    this.updateMetricValue('sizeValue', currentMetrics.size.toFixed(1));
    this.updateMetricValue('scoresValue', currentMetrics.scores.toFixed(1));
    this.updateMetricValue('mobilityValue', currentMetrics.mobility.toFixed(1));
    this.updateMetricValue('globalScoreValue', currentMetrics.globalScore.toFixed(1));
    
    // Calculer et afficher les changements
    if (this.previousMetrics) {
      this.updateMetricChange('balanceChange', currentMetrics.balance, this.previousMetrics.balance);
      this.updateMetricChange('constraintsChange', currentMetrics.constraints, this.previousMetrics.constraints, true);
      this.updateMetricChange('diversityChange', currentMetrics.diversity, this.previousMetrics.diversity);
      this.updateMetricChange('sizeChange', currentMetrics.size, this.previousMetrics.size, true);
      this.updateMetricChange('scoresChange', currentMetrics.scores, this.previousMetrics.scores);
      this.updateMetricChange('mobilityChange', currentMetrics.mobility, this.previousMetrics.mobility);
      this.updateMetricChange('globalScoreChange', currentMetrics.globalScore, this.previousMetrics.globalScore);
    }
    
    this.previousMetrics = { ...currentMetrics };
  },
  
  // Mettre √† jour une valeur de m√©trique
  updateMetricValue(elementId, value) {
    const element = document.getElementById(elementId);
    if (element) {
      element.textContent = value;
    }
  },
  
  // Mettre √† jour l'indicateur de changement
  updateMetricChange(elementId, currentValue, previousValue, inverted = false) {
    const element = document.getElementById(elementId);
    if (!element) return;
    
    const change = currentValue - previousValue;
    const changeElement = element.querySelector('span');
    const iconElement = element.querySelector('i');
    
    if (Math.abs(change) < 0.01) {
      // Pas de changement
      element.className = 'metric-change neutral';
      iconElement.className = 'fas fa-minus';
      changeElement.textContent = '0';
    } else {
      const isImprovement = inverted ? change < 0 : change > 0;
      
      element.className = `metric-change ${isImprovement ? 'improved' : 'degraded'}`;
      iconElement.className = isImprovement ? 'fas fa-arrow-up' : 'fas fa-arrow-down';
      changeElement.textContent = Math.abs(change).toFixed(1);
      
      // Animation de pulse
      const metricValue = element.closest('.metric-value');
      metricValue.classList.add('changed');
      setTimeout(() => metricValue.classList.remove('changed'), 600);
    }
  },
  
  // Pr√©visualiser l'impact d'un d√©placement
  previewMove(studentId, targetGroup) {
    if (!this.previousMetrics) return;
    
    // Simuler le d√©placement
    const originalGroup = this.findStudentGroup(studentId);
    if (!originalGroup || originalGroup === targetGroup) return;
    
    // Calculer les nouvelles m√©triques
    const newMetrics = this.calculateMetricsWithMove(studentId, targetGroup);
    
    // Afficher les changements pr√©visionnels
    this.updateMetricChange('balanceChange', newMetrics.balance, this.previousMetrics.balance);
    this.updateMetricChange('constraintsChange', newMetrics.constraints, this.previousMetrics.constraints, true);
    this.updateMetricChange('diversityChange', newMetrics.diversity, this.previousMetrics.diversity);
    this.updateMetricChange('sizeChange', newMetrics.size, this.previousMetrics.size, true);
    this.updateMetricChange('globalScoreChange', newMetrics.globalScore, this.previousMetrics.globalScore);
  },
  
  // Trouver le groupe d'un √©l√®ve
  findStudentGroup(studentId) {
    const card = document.querySelector(`[data-id="${studentId}"]`);
    return card?.closest('.class-column')?.querySelector('.classe-name')?.textContent;
  },
  
  // Calculer les m√©triques avec un d√©placement simul√©
  calculateMetricsWithMove(studentId, targetGroup) {
    // Impl√©mentation simplifi√©e - en r√©alit√©, il faudrait simuler le d√©placement
    // Pour l'instant, on retourne les m√©triques actuelles
    return this.calculateMetrics();
  },
  
  // R√©initialiser les changements
  resetChanges() {
    const changes = ['balanceChange', 'constraintsChange', 'diversityChange', 'sizeChange', 'scoresChange', 'mobilityChange', 'globalScoreChange'];
    changes.forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.className = 'metric-change neutral';
        const icon = element.querySelector('i');
        const span = element.querySelector('span');
        if (icon) icon.className = 'fas fa-minus';
        if (span) span.textContent = '0';
      }
    });
  }
};

// 1. IMPORT DES SCORES INT
const ScoreImporter = {
  // Importer les scores depuis les fichiers INT
  async importScoresFromINT() {
    try {
      const result = await gsRun('getINTScores');
      if (result.success) {
        // Mapper les scores sur les √©l√®ves existants
        let importedCount = 0;
        result.scores.forEach(score => {
          if (STATE.students[score.id]) {
            STATE.students[score.id].scores.M = score.MATH;
            STATE.students[score.id].scores.F = score.FR;
            importedCount++;
          }
        });
        
        // Rafra√Æchir l'affichage
        this.refreshScoreDisplay();
        
        toast(`${importedCount} scores import√©s avec succ√®s`, 'success');
        return { success: true, count: importedCount };
      } else {
        toast('Erreur lors de l\'import des scores', 'error');
        return { success: false, error: result.error };
      }
    } catch (error) {
      console.error('Erreur import scores:', error);
      toast('Erreur lors de l\'import des scores', 'error');
      return { success: false, error: error.message };
    }
  },

  // Rafra√Æchir l'affichage des scores
  refreshScoreDisplay() {
    document.querySelectorAll('.student-card').forEach(card => {
      const eleve = STATE.students[card.dataset.id];
      if (eleve && eleve.scores) {
        const scoresContainer = card.querySelector('.scores');
        if (scoresContainer) {
          scoresContainer.innerHTML = this.generateScoreBadges(eleve.scores);
        }
      }
    });
  },

  // G√©n√©rer les badges de scores
  generateScoreBadges(scores) {
    const badges = [];

    // Scores existants (COM, TRA, PART, ABS) avec 4 couleurs distinctes
    const scoreMap = [
      { key: 'COM', label: 'Comportement', letter: 'C' },
      { key: 'TRA', label: 'Travail', letter: 'T' },
      { key: 'PART', label: 'Participation', letter: 'P' },
      { key: 'ABS', label: 'Absences', letter: 'A' }
    ];

    scoreMap.forEach(({ key, label, letter }) => {
      if (scores[key] !== undefined && scores[key] !== '' && scores[key] > 0) {
        const score = scores[key];
        // Utiliser les classes score-pill existantes pour avoir 4 couleurs distinctes :
        // score-1 = ROUGE, score-2 = JAUNE, score-3 = VERT CLAIR, score-4 = VERT FONC√â
        badges.push(`<div class="score-pill score-${score}" title="${label}: ${score}/4">${letter}</div>`);
      }
    });

    // Nouveaux scores (MATH, FR) - garder l'ancien syst√®me
    ['M', 'F'].forEach(key => {
      if (scores[key] !== undefined && scores[key] !== '') {
        const score = scores[key];
        const color = score >= 3 ? 'bg-blue-100 text-blue-800' :
                     score >= 2 ? 'bg-orange-100 text-orange-800' :
                     'bg-red-100 text-red-800';
        const label = key === 'M' ? 'MATH' : 'FR';
        badges.push(`<span class="score-badge ${color} text-xs px-1 rounded">${label}:${score}</span>`);
      }
    });

    return badges.join('');
  },

  // Afficher les groupes existants
  showGroups() {
    const section = document.getElementById('groupsSection');
    if (section) {
      section.style.display = 'block';
      // Rafra√Æchir l'affichage si n√©cessaire
      if (Object.keys(this.groups).length > 0) {
        this.displaySavedGroups(true);
      }
    } else if (Object.keys(this.groups).length > 0) {
      // Si la section n'existe pas mais qu'il y a des groupes, la cr√©er
      this.displaySavedGroups(true);
    } else {
      toast('Aucun groupe cr√©√©', 'info');
    }
  },

  // Masquer les groupes
  hideGroups() {
    const section = document.getElementById('groupsSection');
    if (section) {
      section.style.display = 'none';
    }
    toast('Groupes masqu√©s', 'info');
  },

  // Basculer l'affichage des groupes
  toggleGroups() {
    const section = document.getElementById('groupsSection');
    if (section && section.style.display !== 'none') {
      this.hideGroups();
    } else {
      this.showGroups();
    }
  },

  // Supprimer tous les groupes
  deleteAllGroups() {
    if (!confirm('Supprimer TOUS les groupes cr√©√©s ? Cette action est irr√©versible.')) return;
    
    this.groups = {};
    this.saveGroups();
    
    // Retirer la section
    const section = document.getElementById('groupsSection');
    if (section) section.remove();
    
    toast('Tous les groupes ont √©t√© supprim√©s', 'info');
  },

  // Mettre √† jour le bouton pour afficher le nombre de groupes
  updateGroupsButton() {
    const btn = document.getElementById('btnGroups');
    if (btn && this.groups) {
      const count = Object.keys(this.groups).length;
      if (count > 0) {
        btn.innerHTML = `<i class="fas fa-layer-group"></i> Groupes <span class="bg-purple-200 text-purple-800 px-2 py-0.5 rounded-full text-xs ml-1">${count}</span> <i class="fas fa-caret-down"></i>`;
      } else {
        btn.innerHTML = '<i class="fas fa-layer-group"></i> Groupes <i class="fas fa-caret-down"></i>';
      }
    }
  }
};

// 2. ALGORITHME D'OPTIMISATION AM√âLIOR√â
const OptimizerV2 = {
  // Algorithme g√©n√©tique simple pour optimiser l'√©quilibre
  optimizeGroupsGenetic(students, numGroups, iterations = 100) {
    // Cr√©er population initiale
    let bestSolution = this.createInitialGroups(students, numGroups);
    let bestScore = this.evaluateSolution(bestSolution);
    
    for (let i = 0; i < iterations; i++) {
      // Mutation : √©changer 2 √©l√®ves al√©atoires
      const mutated = this.mutateSolution(bestSolution);
      const score = this.evaluateSolution(mutated);
      
      if (score > bestScore) {
        bestSolution = mutated;
        bestScore = score;
      }
    }
    
    return bestSolution;
  },

  // Cr√©er des groupes initiaux
  createInitialGroups(students, numGroups) {
    const groups = Array(numGroups).fill(null).map(() => []);
    
    // Distribution al√©atoire initiale
    students.forEach((student, index) => {
      const groupIndex = index % numGroups;
      groups[groupIndex].push(student);
    });
    
    return groups;
  },

  // √âvaluer la qualit√© d'une solution
  evaluateSolution(groups) {
    let score = 100;
    
    // P√©nalit√© pour d√©s√©quilibre de taille
    const avgSize = groups.reduce((sum, g) => sum + g.length, 0) / groups.length;
    groups.forEach(g => {
      score -= Math.abs(g.length - avgSize) * 5;
    });
    
    // P√©nalit√© pour d√©s√©quilibre F/M
    groups.forEach(g => {
      const ratio = g.filter(s => s.sexe === 'F').length / g.length;
      score -= Math.abs(ratio - 0.5) * 50;
    });
    
    // Bonus pour h√©t√©rog√©n√©it√© des scores
    groups.forEach(g => {
      const scores = g.map(s => (s.scores?.M || 0) + (s.scores?.F || 0));
      const variance = this.calculateVariance(scores);
      score += variance * 10; // Plus de variance = mieux
    });
    
    return score;
  },

  // Calculer la variance
  calculateVariance(scores) {
    if (scores.length === 0) return 0;
    const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
    const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length;
    return variance;
  },

  // Mutation d'une solution
  mutateSolution(groups) {
    const mutated = groups.map(g => [...g]); // Copie profonde
    
    // S√©lectionner deux groupes al√©atoires
    const group1Index = Math.floor(Math.random() * mutated.length);
    const group2Index = Math.floor(Math.random() * mutated.length);
    
    if (group1Index !== group2Index && mutated[group1Index].length > 0 && mutated[group2Index].length > 0) {
      // S√©lectionner deux √©l√®ves al√©atoires
      const student1Index = Math.floor(Math.random() * mutated[group1Index].length);
      const student2Index = Math.floor(Math.random() * mutated[group2Index].length);
      
      // √âchanger les √©l√®ves
      const temp = mutated[group1Index][student1Index];
      mutated[group1Index][student1Index] = mutated[group2Index][student2Index];
      mutated[group2Index][student2Index] = temp;
    }
    
    return mutated;
  },

  // Appliquer l'optimisation ClaudeMotor depuis le backend
  applyOptimization() {
    // Afficher un loader
    const loadingToast = document.createElement('div');
    loadingToast.className = 'fixed top-4 right-4 bg-purple-600 text-white px-6 py-4 rounded-lg shadow-lg z-50';
    loadingToast.innerHTML = `
      <div class="flex items-center gap-3">
        <i class="fas fa-spinner fa-spin"></i>
        <div>
          <div class="font-bold">Optimisation en cours...</div>
          <div class="text-sm opacity-90">ClaudeMotor analyse vos classes</div>
        </div>
      </div>
    `;
    document.body.appendChild(loadingToast);

    // Appeler le backend
    google.script.run
      .withSuccessHandler((response) => {
        loadingToast.remove();

        if (response.success) {
          toast(`Optimisation termin√©e ! ${response.results.totalSwaps} √©changes sugg√©r√©s`, 'success');
          this.displayClaudeMotorResults(response.results);
        } else {
          toast(`Erreur: ${response.error}`, 'error');
          console.error('Erreur optimisation:', response);
        }
      })
      .withFailureHandler((error) => {
        loadingToast.remove();
        toast(`Erreur technique: ${error.message}`, 'error');
        console.error('Erreur appel backend:', error);
      })
      .lancerOptimisationClaudeMotor({
        maxIterations: 50,
        enableMultiSwap: true
      });
  },

  // Afficher les r√©sultats ClaudeMotor
  displayClaudeMotorResults(results) {
    const modal = document.createElement('div');
    modal.className = 'modal';

    // Formater les swaps par phase
    let swapsHTML = '';
    if (results.swaps && results.swaps.length > 0) {
      swapsHTML = `
        <div class="mb-4">
          <h3 class="font-bold text-lg mb-2">üìù √âchanges sugg√©r√©s (${results.swaps.length})</h3>
          <div class="max-h-60 overflow-y-auto border rounded p-2">
            ${results.swaps.map((swap, i) => `
              <div class="text-sm p-2 bg-gray-50 rounded mb-2">
                <strong>#${i+1}</strong>:
                ${swap.student1?.nom || swap.studentSource?.nom || '√âl√®ve 1'}
                (${swap.class1 || swap.sourceClass || '?'})
                ‚Üî
                ${swap.student2?.nom || swap.studentTarget?.nom || '√âl√®ve 2'}
                (${swap.class2 || swap.targetClass || '?'})
              </div>
            `).join('')}
          </div>
        </div>
      `;
    } else {
      swapsHTML = `
        <div class="mb-4 p-4 bg-green-50 border border-green-200 rounded">
          <p class="text-green-800">‚úÖ Aucun √©change n√©cessaire - La r√©partition est d√©j√† optimale !</p>
        </div>
      `;
    }

    modal.innerHTML = `
      <div class="modal-content" style="max-width: 900px;">
        <div class="modal-header">
          <h2 class="text-xl font-bold">üöÄ R√©sultats ClaudeMotor</h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <!-- Scores -->
          <div class="grid grid-cols-3 gap-4 mb-4">
            <div class="border rounded p-3 text-center">
              <div class="text-sm text-gray-600">Score initial</div>
              <div class="text-2xl font-bold text-gray-800">${results.scoreInitial.toFixed(1)}/100</div>
            </div>
            <div class="border rounded p-3 text-center">
              <div class="text-sm text-gray-600">Score final</div>
              <div class="text-2xl font-bold text-green-600">${results.scoreFinal.toFixed(1)}/100</div>
            </div>
            <div class="border rounded p-3 text-center">
              <div class="text-sm text-gray-600">Am√©lioration</div>
              <div class="text-2xl font-bold ${results.improvement >= 0 ? 'text-green-600' : 'text-red-600'}">
                ${results.improvement >= 0 ? '+' : ''}${results.improvement.toFixed(1)}
              </div>
            </div>
          </div>

          <!-- Phases -->
          ${results.phases ? `
            <div class="mb-4">
              <h3 class="font-bold mb-2">üìä D√©tails des phases</h3>
              <div class="grid grid-cols-3 gap-2">
                <div class="text-xs border rounded p-2">
                  <strong>Phase 1 (Scores)</strong><br>
                  ${results.phases.phase1?.swaps?.length || 0} √©changes
                </div>
                <div class="text-xs border rounded p-2">
                  <strong>Phase 2 (Parit√©)</strong><br>
                  ${results.phases.phase2?.corrections?.length || 0} corrections
                </div>
                <div class="text-xs border rounded p-2">
                  <strong>Phase 3 (MultiSwap)</strong><br>
                  ${results.phases.phase3?.cycles?.length || 0} cycles
                </div>
              </div>
            </div>
          ` : ''}

          ${swapsHTML}

          <!-- Boutons -->
          <div class="mt-4 flex gap-2">
            <button onclick="OptimizerV2.applyClaudeMotorSwaps()" class="btn btn-primary">
              <i class="fas fa-check"></i> Appliquer les √©changes
            </button>
            <button onclick="this.closest('.modal').remove()" class="btn btn-secondary">
              <i class="fas fa-times"></i> Fermer
            </button>
          </div>

          <div class="mt-4 text-xs text-gray-500">
            ‚è±Ô∏è Dur√©e: ${results.duration}ms |
            üîÑ ${results.totalSwaps} √©changes au total
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(modal);

    // Sauvegarder les swaps pour application ult√©rieure
    window._claudeMotorSwaps = results.swaps;
  },

  // Appliquer les swaps ClaudeMotor
  applyClaudeMotorSwaps() {
    const swaps = window._claudeMotorSwaps;
    if (!swaps || swaps.length === 0) {
      toast('Aucun √©change √† appliquer', 'info');
      document.querySelector('.modal')?.remove();
      return;
    }

    // TODO: Impl√©menter l'application r√©elle des swaps dans l'interface
    // Pour l'instant, juste recharger les donn√©es
    toast(`Application de ${swaps.length} √©changes...`, 'info');

    setTimeout(() => {
      toast('√âchanges appliqu√©s ! Rechargez les donn√©es pour voir les changements.', 'success');
      document.querySelector('.modal')?.remove();
    }, 1000);
  },

  // Afficher les r√©sultats d'optimisation (ancien algorithme - conserv√© pour compatibilit√©)
  displayOptimizationResults(groups) {
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-content" style="max-width: 800px;">
        <div class="modal-header">
          <h2 class="text-xl font-bold">R√©sultats de l'optimisation</h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <div class="grid grid-cols-2 gap-4">
            ${groups.map((group, index) => `
              <div class="border rounded p-3">
                <h4 class="font-bold mb-2">Groupe ${index + 1} (${group.length} √©l√®ves)</h4>
                <div class="text-sm text-gray-600 mb-2">
                  F: ${group.filter(s => s.sexe === 'F').length} | 
                  M: ${group.filter(s => s.sexe === 'M').length}
                </div>
                <div class="max-h-32 overflow-y-auto">
                  ${group.slice(0, 10).map(s => `
                    <div class="text-xs p-1 bg-gray-50 rounded mb-1">
                      ${s.nom} ${s.prenom || ''} (${s.sexe})
                    </div>
                  `).join('')}
                  ${group.length > 10 ? `<div class="text-xs text-gray-500">... et ${group.length - 10} autres</div>` : ''}
                </div>
              </div>
            `).join('')}
          </div>
          <div class="mt-4 flex gap-2">
            <button onclick="OptimizerV2.applyOptimizationResults()" class="btn btn-primary">
              <i class="fas fa-check"></i> Appliquer cette r√©partition
            </button>
            <button onclick="this.closest('.modal').remove()" class="btn btn-secondary">
              <i class="fas fa-times"></i> Annuler
            </button>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
  },

  // Appliquer les r√©sultats d'optimisation
  applyOptimizationResults() {
    // Cette fonction serait appel√©e pour appliquer r√©ellement les changements
    toast('Optimisation appliqu√©e', 'success');
    document.querySelector('.modal').remove();
  }
};

// 3. GESTION DES CONTRAINTES ASSO/DISSO AM√âLIOR√âE
const ConstraintManager = {
  // V√©rifier les contraintes avant tout d√©placement
  checkGroupConstraints(studentId, targetGroup) {
    const student = STATE.students[studentId];
    if (!student) return { valid: false, reason: '√âl√®ve non trouv√©' };
    
    // V√©rifier dissociation
    if (student.disso) {
      const conflictExists = targetGroup.some(s => 
        STATE.students[s.id] && STATE.students[s.id].disso === student.disso
      );
      if (conflictExists) {
        return { valid: false, reason: `Conflit dissociation D${student.disso}` };
      }
    }
    
    // V√©rifier association
    if (student.asso) {
      const assoGroup = STATE.aGroups[`A${student.asso}`];
      if (assoGroup) {
        const allInSameGroup = assoGroup.every(id => 
          targetGroup.some(s => s.id === id) || id === studentId
        );
        if (!allInSameGroup) {
          return { valid: false, reason: `Groupe A${student.asso} doit rester ensemble` };
        }
      }
    }
    
    return { valid: true };
  },

  // Afficher visuellement les contraintes
  showConstraintsOverlay() {
    // Colorer les √©l√®ves avec le m√™me code disso
    document.querySelectorAll('.student-card').forEach(card => {
      const eleve = STATE.students[card.dataset.id];
      if (eleve && eleve.disso) {
        card.style.border = '2px solid #ef4444';
        card.style.backgroundColor = '#fef2f2';
        
        // Ajouter un badge de contrainte
        let badge = card.querySelector('.constraint-badge');
        if (!badge) {
          badge = document.createElement('div');
          badge.className = 'constraint-badge absolute -top-1 -right-1 bg-red-500 text-white text-xs px-1 rounded-full';
          badge.textContent = `D${eleve.disso}`;
          card.style.position = 'relative';
          card.appendChild(badge);
        }
      }
      
      // Relier visuellement les √©l√®ves avec le m√™me code asso
      if (eleve && eleve.asso) {
        card.style.border = '2px solid #3b82f6';
        card.style.backgroundColor = '#eff6ff';
        
        let badge = card.querySelector('.constraint-badge');
        if (!badge) {
          badge = document.createElement('div');
          badge.className = 'constraint-badge absolute -top-1 -right-1 bg-blue-500 text-white text-xs px-1 rounded-full';
          badge.textContent = `A${eleve.asso}`;
          card.style.position = 'relative';
          card.appendChild(badge);
        }
      }
    });
  },

  // Masquer les contraintes
  hideConstraintsOverlay() {
    document.querySelectorAll('.student-card').forEach(card => {
      card.style.border = '';
      card.style.backgroundColor = '';
      card.style.position = '';
      
      const badge = card.querySelector('.constraint-badge');
      if (badge) badge.remove();
    });
  },

  // V√©rifier toutes les contraintes dans l'interface
  validateAllConstraints() {
    const violations = [];
    
    // V√©rifier les dissociations
    const dissoGroups = {};
    document.querySelectorAll('.student-card').forEach(card => {
      const eleve = STATE.students[card.dataset.id];
      if (eleve && eleve.disso) {
        const classe = card.closest('.droppable-zone').dataset.classe;
        if (!dissoGroups[eleve.disso]) dissoGroups[eleve.disso] = [];
        dissoGroups[eleve.disso].push({ eleve, classe });
      }
    });
    
    Object.entries(dissoGroups).forEach(([code, eleves]) => {
      const classes = [...new Set(eleves.map(e => e.classe))];
      if (classes.length > 1) {
        violations.push({
          type: 'DISSO',
          code,
          message: `Code D${code} r√©parti sur ${classes.length} classes: ${classes.join(', ')}`
        });
      }
    });
    
    // V√©rifier les associations
    const assoGroups = {};
    document.querySelectorAll('.student-card').forEach(card => {
      const eleve = STATE.students[card.dataset.id];
      if (eleve && eleve.asso) {
        const classe = card.closest('.droppable-zone').dataset.classe;
        if (!assoGroups[eleve.asso]) assoGroups[eleve.asso] = [];
        assoGroups[eleve.asso].push({ eleve, classe });
      }
    });
    
    Object.entries(assoGroups).forEach(([code, eleves]) => {
      const classes = [...new Set(eleves.map(e => e.classe))];
      if (classes.length > 1) {
        violations.push({
          type: 'ASSO',
          code,
          message: `Groupe A${code} s√©par√© sur ${classes.length} classes: ${classes.join(', ')}`
        });
      }
    });
    
    return violations;
  },

  // Afficher les violations de contraintes
  showConstraintViolations() {
    const violations = this.validateAllConstraints();

    if (violations.length === 0) {
      toast('‚úÖ Aucune violation de contrainte d√©tect√©e', 'success');
      // Proposer d'ouvrir le panneau des contraintes
      this.showConstraintsPanel();
      return;
    }

    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-content" style="max-width: 600px;">
        <div class="modal-header">
          <h2 class="text-xl font-bold text-red-600">
            <i class="fas fa-exclamation-triangle mr-2"></i>
            ${violations.length} Violation(s) de contraintes
          </h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <div class="space-y-3">
            ${violations.map(v => `
              <div class="p-3 border-l-4 ${v.type === 'DISSO' ? 'border-red-500 bg-red-50' : 'border-blue-500 bg-blue-50'}">
                <div class="font-semibold ${v.type === 'DISSO' ? 'text-red-800' : 'text-blue-800'}">
                  ${v.type === 'DISSO' ? 'Dissociation' : 'Association'} ${v.code}
                </div>
                <div class="text-sm ${v.type === 'DISSO' ? 'text-red-700' : 'text-blue-700'}">
                  ${v.message}
                </div>
              </div>
            `).join('')}
          </div>
          <div class="mt-4 flex gap-2">
            <button onclick="ConstraintManager.showConstraintsOverlay()" class="btn btn-secondary">
              <i class="fas fa-eye"></i> Voir les contraintes
            </button>
            <button onclick="ConstraintManager.showConstraintsPanel(); this.closest('.modal').remove();" class="btn btn-secondary">
              <i class="fas fa-cog"></i> G√©rer les contraintes
            </button>
            <button onclick="this.closest('.modal').remove()" class="btn btn-primary">
              <i class="fas fa-check"></i> Compris
            </button>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
  },

  // Afficher le panneau complet de gestion des contraintes
  showConstraintsPanel() {
    // Charger depuis le backend
    const loadingToast = document.createElement('div');
    loadingToast.className = 'fixed top-4 right-4 bg-blue-600 text-white px-4 py-3 rounded-lg shadow-lg z-50';
    loadingToast.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Chargement des contraintes...';
    document.body.appendChild(loadingToast);

    google.script.run
      .withSuccessHandler((response) => {
        loadingToast.remove();
        if (response.success) {
          this.displayConstraintsPanel(response.constraints);
        } else {
          toast(`Erreur: ${response.error}`, 'error');
        }
      })
      .withFailureHandler((error) => {
        loadingToast.remove();
        toast(`Erreur: ${error.message}`, 'error');
      })
      .chargerContraintes();
  },

  // Afficher le panneau des contraintes
  displayConstraintsPanel(constraints) {
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.id = 'constraintsModal';

    // Analyser les contraintes actuelles de l'interface
    const currentDisso = {};
    const currentAsso = {};
    const currentFixe = [];

    document.querySelectorAll('.student-card').forEach(card => {
      const eleve = STATE.students[card.dataset.id];
      if (!eleve) return;

      if (eleve.disso) {
        if (!currentDisso[eleve.disso]) currentDisso[eleve.disso] = [];
        currentDisso[eleve.disso].push(`${eleve.nom} ${eleve.prenom || ''}`);
      }
      if (eleve.asso) {
        if (!currentAsso[eleve.asso]) currentAsso[eleve.asso] = [];
        currentAsso[eleve.asso].push(`${eleve.nom} ${eleve.prenom || ''}`);
      }
      if (eleve.mobilite === 'FIXE') {
        const classe = card.closest('.droppable-zone')?.dataset.classe;
        currentFixe.push(`${eleve.nom} ${eleve.prenom || ''} (${classe || '?'})`);
      }
    });

    modal.innerHTML = `
      <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
        <div class="modal-header">
          <h2 class="text-2xl font-bold">
            <i class="fas fa-link mr-2"></i>
            Gestion des Contraintes
          </h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <!-- Structure from _STRUCTURE -->
          <div class="mb-6 p-4 bg-blue-50 border border-blue-200 rounded">
            <h3 class="font-bold text-lg mb-2">
              <i class="fas fa-sitemap mr-2"></i>Structure (_STRUCTURE)
            </h3>
            <div class="text-sm space-y-2">
              ${constraints.structure && constraints.structure.length > 0 ? `
                <table class="w-full text-sm">
                  <thead class="bg-blue-100">
                    <tr>
                      <th class="p-2 text-left">Origine</th>
                      <th class="p-2 text-left">Destination</th>
                      <th class="p-2 text-center">Effectif</th>
                      <th class="p-2 text-left">Options</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${constraints.structure.map(s => `
                      <tr class="border-b">
                        <td class="p-2">${s.origine || '-'}</td>
                        <td class="p-2">${s.destination || '-'}</td>
                        <td class="p-2 text-center">${s.effectif || 28}</td>
                        <td class="p-2 text-xs">${s.options || '-'}</td>
                      </tr>
                    `).join('')}
                  </tbody>
                </table>
              ` : '<p class="text-gray-600">Aucune structure d√©finie dans _STRUCTURE</p>'}
            </div>
          </div>

          <!-- FIXE -->
          <div class="mb-6 p-4 bg-purple-50 border border-purple-200 rounded">
            <h3 class="font-bold text-lg mb-2">
              <i class="fas fa-lock mr-2"></i>√âl√®ves FIXE (${currentFixe.length})
            </h3>
            <p class="text-sm text-gray-600 mb-2">Ces √©l√®ves ne peuvent pas changer de classe</p>
            ${currentFixe.length > 0 ? `
              <div class="max-h-32 overflow-y-auto">
                ${currentFixe.map(e => `
                  <div class="text-sm p-1 bg-white rounded mb-1">${e}</div>
                `).join('')}
              </div>
            ` : '<p class="text-sm text-gray-500">Aucun √©l√®ve fix√©</p>'}
          </div>

          <!-- DISSO -->
          <div class="mb-6 p-4 bg-red-50 border border-red-200 rounded">
            <h3 class="font-bold text-lg mb-2">
              <i class="fas fa-ban mr-2"></i>Codes DISSO (${Object.keys(currentDisso).length})
            </h3>
            <p class="text-sm text-gray-600 mb-2">Ces √©l√®ves NE DOIVENT PAS √™tre dans la m√™me classe</p>
            ${Object.keys(currentDisso).length > 0 ? `
              <div class="space-y-2">
                ${Object.entries(currentDisso).map(([code, eleves]) => `
                  <div class="p-2 bg-white rounded border border-red-300">
                    <div class="font-bold text-red-700">D${code} (${eleves.length} √©l√®ves)</div>
                    <div class="text-xs text-gray-700">${eleves.join(', ')}</div>
                  </div>
                `).join('')}
              </div>
            ` : '<p class="text-sm text-gray-500">Aucune dissociation d√©finie</p>'}
          </div>

          <!-- ASSO -->
          <div class="mb-6 p-4 bg-green-50 border border-green-200 rounded">
            <h3 class="font-bold text-lg mb-2">
              <i class="fas fa-users mr-2"></i>Codes ASSO (${Object.keys(currentAsso).length})
            </h3>
            <p class="text-sm text-gray-600 mb-2">Ces √©l√®ves DOIVENT rester ensemble</p>
            ${Object.keys(currentAsso).length > 0 ? `
              <div class="space-y-2">
                ${Object.entries(currentAsso).map(([code, eleves]) => `
                  <div class="p-2 bg-white rounded border border-green-300">
                    <div class="font-bold text-green-700">A${code} (${eleves.length} √©l√®ves)</div>
                    <div class="text-xs text-gray-700">${eleves.join(', ')}</div>
                  </div>
                `).join('')}
              </div>
            ` : '<p class="text-sm text-gray-500">Aucune association d√©finie</p>'}
          </div>

          <!-- Options et LV2 -->
          <div class="mb-6 p-4 bg-yellow-50 border border-yellow-200 rounded">
            <h3 class="font-bold text-lg mb-2">
              <i class="fas fa-star mr-2"></i>Contraintes OPT et LV2
            </h3>
            <p class="text-sm text-gray-600 mb-2">V√©rification des quotas d'options par classe</p>
            <div class="text-sm">
              <p class="text-gray-700">‚úÖ Les contraintes d'options sont v√©rifi√©es automatiquement lors des d√©placements</p>
              <p class="text-gray-700 mt-1">‚ÑπÔ∏è Voir _STRUCTURE pour les quotas d√©finis par classe</p>
            </div>
          </div>

          <!-- Boutons -->
          <div class="mt-4 flex gap-2">
            <button onclick="ConstraintManager.showConstraintsOverlay()" class="btn btn-secondary">
              <i class="fas fa-eye"></i> Visualiser sur les cartes
            </button>
            <button onclick="window.open('https://docs.google.com/spreadsheets/d/' + google.script.host.origin.split('/')[2] + '/edit#gid=SHEET_ID_STRUCTURE', '_blank')" class="btn btn-secondary">
              <i class="fas fa-external-link-alt"></i> Ouvrir _STRUCTURE
            </button>
            <button onclick="this.closest('.modal').remove()" class="btn btn-primary">
              <i class="fas fa-check"></i> Fermer
            </button>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
  }
};

// 4. GESTIONNAIRE DE FILTRES
const FilterManager = {
  activeFilters: {},

  // Afficher le panneau de filtres
  showFiltersPanel() {
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.id = 'filtersModal';

    // Collecter les valeurs uniques pour chaque filtre
    const lv2Set = new Set();
    const optSet = new Set();
    const dissoSet = new Set();
    const assoSet = new Set();
    const mobiliteSet = new Set();
    const scoresCOM = new Set();

    Object.values(STATE.students || {}).forEach(eleve => {
      if (eleve.lv2) lv2Set.add(eleve.lv2);
      if (eleve.opt) optSet.add(eleve.opt);
      if (eleve.disso) dissoSet.add(eleve.disso);
      if (eleve.asso) assoSet.add(eleve.asso);
      if (eleve.mobilite) mobiliteSet.add(eleve.mobilite);
      if (eleve.scores && eleve.scores.COM) scoresCOM.add(eleve.scores.COM);
    });

    modal.innerHTML = `
      <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
        <div class="modal-header">
          <h2 class="text-2xl font-bold">
            <i class="fas fa-filter mr-2"></i>
            Filtres
          </h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <p class="text-sm text-gray-600 mb-4">
            Filtrez les √©l√®ves affich√©s selon leurs caract√©ristiques. Les √©l√®ves non filtr√©s seront gris√©s.
          </p>

          <!-- Filtres actifs -->
          <div id="activeFiltersDisplay" class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded ${Object.keys(this.activeFilters).length === 0 ? 'hidden' : ''}">
            <h4 class="font-bold text-sm mb-2">Filtres actifs :</h4>
            <div id="activeFiltersList" class="flex flex-wrap gap-2"></div>
          </div>

          <!-- LV2 -->
          <div class="mb-4 p-4 border rounded">
            <h3 class="font-bold mb-2">
              <i class="fas fa-language mr-2"></i>LV2
            </h3>
            <div class="flex flex-wrap gap-2">
              ${Array.from(lv2Set).sort().map(lv2 => `
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="filter-checkbox mr-2" data-filter-type="lv2" data-filter-value="${lv2}">
                  <span class="text-sm px-3 py-1 bg-gray-100 rounded hover:bg-gray-200">${lv2}</span>
                </label>
              `).join('')}
            </div>
          </div>

          <!-- OPT -->
          <div class="mb-4 p-4 border rounded">
            <h3 class="font-bold mb-2">
              <i class="fas fa-star mr-2"></i>Options
            </h3>
            <div class="flex flex-wrap gap-2">
              ${Array.from(optSet).sort().map(opt => `
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="filter-checkbox mr-2" data-filter-type="opt" data-filter-value="${opt}">
                  <span class="text-sm px-3 py-1 bg-gray-100 rounded hover:bg-gray-200">${opt}</span>
                </label>
              `).join('')}
            </div>
          </div>

          <!-- DISSO -->
          <div class="mb-4 p-4 border rounded">
            <h3 class="font-bold mb-2">
              <i class="fas fa-ban mr-2 text-red-600"></i>Codes DISSO
            </h3>
            <div class="flex flex-wrap gap-2">
              ${Array.from(dissoSet).sort().map(disso => `
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="filter-checkbox mr-2" data-filter-type="disso" data-filter-value="${disso}">
                  <span class="text-sm px-3 py-1 bg-red-100 rounded hover:bg-red-200">D${disso}</span>
                </label>
              `).join('')}
            </div>
          </div>

          <!-- ASSO -->
          <div class="mb-4 p-4 border rounded">
            <h3 class="font-bold mb-2">
              <i class="fas fa-users mr-2 text-green-600"></i>Codes ASSO
            </h3>
            <div class="flex flex-wrap gap-2">
              ${Array.from(assoSet).sort().map(asso => `
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="filter-checkbox mr-2" data-filter-type="asso" data-filter-value="${asso}">
                  <span class="text-sm px-3 py-1 bg-green-100 rounded hover:bg-green-200">A${asso}</span>
                </label>
              `).join('')}
            </div>
          </div>

          <!-- Mobilit√© -->
          <div class="mb-4 p-4 border rounded">
            <h3 class="font-bold mb-2">
              <i class="fas fa-exchange-alt mr-2"></i>Mobilit√©
            </h3>
            <div class="flex flex-wrap gap-2">
              ${Array.from(mobiliteSet).sort().map(mob => `
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="filter-checkbox mr-2" data-filter-type="mobilite" data-filter-value="${mob}">
                  <span class="text-sm px-3 py-1 bg-gray-100 rounded hover:bg-gray-200">${mob}</span>
                </label>
              `).join('')}
            </div>
          </div>

          <!-- Score COM -->
          <div class="mb-4 p-4 border rounded">
            <h3 class="font-bold mb-2">
              <i class="fas fa-chart-bar mr-2"></i>Score Comportement
            </h3>
            <div class="flex gap-2">
              ${Array.from(scoresCOM).sort().map(score => `
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="filter-checkbox mr-2" data-filter-type="scoreCOM" data-filter-value="${score}">
                  <span class="text-sm px-3 py-1 rounded ${
                    score == 1 ? 'bg-red-500 text-white' :
                    score == 2 ? 'bg-yellow-400 text-gray-800' :
                    score == 3 ? 'bg-green-400 text-white' :
                    'bg-green-600 text-white'
                  }">${score}</span>
                </label>
              `).join('')}
            </div>
          </div>

          <!-- Boutons -->
          <div class="mt-4 flex gap-2">
            <button onclick="FilterManager.applyFilters()" class="btn btn-primary">
              <i class="fas fa-check"></i> Appliquer les filtres
            </button>
            <button onclick="FilterManager.clearAllFilters()" class="btn btn-secondary">
              <i class="fas fa-times"></i> Effacer tous les filtres
            </button>
            <button onclick="this.closest('.modal').remove()" class="btn btn-secondary">
              <i class="fas fa-times"></i> Fermer
            </button>
          </div>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    // Restaurer les filtres actifs
    Object.keys(this.activeFilters).forEach(key => {
      const [type, value] = key.split(':');
      const checkbox = modal.querySelector(`[data-filter-type="${type}"][data-filter-value="${value}"]`);
      if (checkbox) checkbox.checked = true;
    });

    // G√©rer les changements de checkbox
    modal.querySelectorAll('.filter-checkbox').forEach(checkbox => {
      checkbox.addEventListener('change', () => {
        this.updateActiveFiltersDisplay(modal);
      });
    });

    this.updateActiveFiltersDisplay(modal);
  },

  // Mettre √† jour l'affichage des filtres actifs
  updateActiveFiltersDisplay(modal) {
    const checkedBoxes = modal.querySelectorAll('.filter-checkbox:checked');
    const display = modal.querySelector('#activeFiltersDisplay');
    const list = modal.querySelector('#activeFiltersList');

    if (checkedBoxes.length === 0) {
      display.classList.add('hidden');
      return;
    }

    display.classList.remove('hidden');
    list.innerHTML = Array.from(checkedBoxes).map(checkbox => {
      const type = checkbox.dataset.filterType;
      const value = checkbox.dataset.filterValue;
      return `
        <span class="px-2 py-1 bg-blue-500 text-white text-xs rounded">
          ${type}: ${value}
        </span>
      `;
    }).join('');
  },

  // Appliquer les filtres
  applyFilters() {
    const modal = document.getElementById('filtersModal');
    if (!modal) return;

    const checkedBoxes = modal.querySelectorAll('.filter-checkbox:checked');

    // Sauvegarder les filtres actifs
    this.activeFilters = {};
    checkedBoxes.forEach(checkbox => {
      const type = checkbox.dataset.filterType;
      const value = checkbox.dataset.filterValue;
      this.activeFilters[`${type}:${value}`] = { type, value };
    });

    // Appliquer le filtre sur toutes les cartes
    document.querySelectorAll('.student-card').forEach(card => {
      const eleve = STATE.students[card.dataset.id];
      if (!eleve) return;

      let match = true;

      if (checkedBoxes.length > 0) {
        match = Array.from(checkedBoxes).some(checkbox => {
          const type = checkbox.dataset.filterType;
          const value = checkbox.dataset.filterValue;

          switch(type) {
            case 'lv2': return eleve.lv2 === value;
            case 'opt': return eleve.opt === value;
            case 'disso': return eleve.disso === value;
            case 'asso': return eleve.asso === value;
            case 'mobilite': return eleve.mobilite === value;
            case 'scoreCOM': return eleve.scores && eleve.scores.COM == value;
            default: return false;
          }
        });
      }

      if (match) {
        card.style.opacity = '1';
        card.style.filter = 'none';
      } else {
        card.style.opacity = '0.3';
        card.style.filter = 'grayscale(1)';
      }
    });

    modal.remove();

    if (checkedBoxes.length > 0) {
      toast(`${checkedBoxes.length} filtre(s) appliqu√©(s)`, 'success');
    } else {
      toast('Tous les filtres effac√©s', 'info');
    }
  },

  // Effacer tous les filtres
  clearAllFilters() {
    this.activeFilters = {};

    document.querySelectorAll('.student-card').forEach(card => {
      card.style.opacity = '1';
      card.style.filter = 'none';
    });

    const modal = document.getElementById('filtersModal');
    if (modal) {
      modal.querySelectorAll('.filter-checkbox').forEach(cb => cb.checked = false);
      this.updateActiveFiltersDisplay(modal);
    }

    toast('Tous les filtres effac√©s', 'info');
  }
};

// 5. TEMPLATES DE GROUPES R√âUTILISABLES
// 6. HISTORIQUE D√âTAILL√â AVEC DIFF
const HistoryManager = {
  history: [],
  maxHistory: 50,

  // Sauvegarder l'√©tat actuel
  saveState() {
    const state = this.captureCurrentState();
    this.history.push({
      timestamp: new Date(),
      state: state
    });
    
    // Limiter la taille de l'historique
    if (this.history.length > this.maxHistory) {
      this.history.shift();
    }
  },

  // Capturer l'√©tat actuel
  captureCurrentState() {
    const state = {};
    
    document.querySelectorAll('.class-column').forEach(col => {
      const classe = col.querySelector('.classe-name').textContent;
      state[classe] = [];
      
      col.querySelectorAll('.student-card').forEach(card => {
        const eleve = STATE.students[card.dataset.id];
        if (eleve) {
          state[classe].push(eleve.id);
        }
      });
    });
    
    return state;
  },

  // Comparer deux √©tats
  compareStates(before, after) {
    const changes = [];
    
    // Trouver les classes communes
    const allClasses = new Set([...Object.keys(before), ...Object.keys(after)]);
    
    allClasses.forEach(classe => {
      const beforeStudents = before[classe] || [];
      const afterStudents = after[classe] || [];
      
      // √âl√®ves ajout√©s
      const added = afterStudents.filter(id => !beforeStudents.includes(id));
      
      // √âl√®ves retir√©s
      const removed = beforeStudents.filter(id => !afterStudents.includes(id));
      
      if (added.length || removed.length) {
        changes.push({
          classe,
          added: added.map(id => STATE.students[id]?.nom || id),
          removed: removed.map(id => STATE.students[id]?.nom || id),
          timestamp: new Date()
        });
      }
    });
    
    return changes;
  },

  // Afficher l'historique des changements
  showHistory() {
    if (this.history.length < 2) {
      toast('Pas assez d\'historique pour comparer', 'warning');
    return;
    }
    
    const recent = this.history.slice(-5); // 5 derniers √©tats
    const changes = [];
    
    for (let i = 1; i < recent.length; i++) {
      const stateChanges = this.compareStates(recent[i-1].state, recent[i].state);
      if (stateChanges.length > 0) {
        changes.push({
          timestamp: recent[i].timestamp,
          changes: stateChanges
        });
      }
    }
    
    if (changes.length === 0) {
      toast('Aucun changement d√©tect√©', 'info');
      return;
    }
    
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-content" style="max-width: 700px;">
        <div class="modal-header">
          <h2 class="text-xl font-bold">Historique des changements</h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <div class="space-y-4">
            ${changes.map(change => `
              <div class="border rounded p-3">
                <div class="font-semibold text-sm text-gray-600 mb-2">
                  ${change.timestamp.toLocaleString()}
                </div>
                ${change.changes.map(c => `
                  <div class="ml-4 mb-2">
                    <div class="font-medium">${c.classe}</div>
                    ${c.added.length > 0 ? `
                      <div class="text-green-600 text-sm">
                        <i class="fas fa-plus"></i> Ajout√©s: ${c.added.join(', ')}
                      </div>
                    ` : ''}
                    ${c.removed.length > 0 ? `
                      <div class="text-red-600 text-sm">
                        <i class="fas fa-minus"></i> Retir√©s: ${c.removed.join(', ')}
                      </div>
                    ` : ''}
                  </div>
                `).join('')}
              </div>
            `).join('')}
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
  },

  // Annuler le dernier changement
  undo() {
    if (this.history.length < 2) {
      toast('Rien √† annuler', 'warning');
      return;
    }
    
    const previousState = this.history[this.history.length - 2].state;
    this.restoreState(previousState);
    this.history.pop(); // Retirer l'√©tat actuel
    
    toast('Changement annul√©', 'success');
  },

  // Restaurer un √©tat
  restoreState(state) {
    // Cette fonction restaurerait l'√©tat pr√©c√©dent
    // Impl√©mentation complexe qui n√©cessiterait de modifier l'interface
    console.log('Restauration de l\'√©tat:', state);
  }
};

// 7. MODE SIMULATION
// ========== INT√âGRATION DES NOUVELLES FONCTIONS ==========

// Ajouter les boutons dans l'interface
// ========== CONFIGURATION DES BOUTONS AVANC√âS DANS LE MENU ACTIONS ==========
function configureAdvancedFeaturesButtons() {
  // Bouton Import Scores
  const importBtn = document.getElementById('btnImportScores');
  if (importBtn) {
    importBtn.onclick = () => {
      ScoreImporter.importScoresFromINT();
      // Fermer le menu apr√®s clic
      document.getElementById('actionsDropdown').classList.add('hidden');
    };
  }
  
  // Bouton Optimisation
  const optimizeBtn = document.getElementById('btnOptimize');
  if (optimizeBtn) {
    optimizeBtn.onclick = () => {
      OptimizerV2.applyOptimization();
      document.getElementById('actionsDropdown').classList.add('hidden');
    };
  }
  
  // Bouton Contraintes
  const constraintsBtn = document.getElementById('btnConstraints');
  if (constraintsBtn) {
    constraintsBtn.onclick = () => {
      ConstraintManager.showConstraintViolations();
      document.getElementById('actionsDropdown').classList.add('hidden');
    };
  }
  
  // Bouton Feedback en temps r√©el (dans le menu des groupes)
  document.addEventListener('click', (e) => {
    if (e.target.closest('#btnGroupFeedback')) {
      if (RealTimeFeedback) {
        const panel = document.getElementById('feedbackPanel');
        if (panel && panel.style.display === 'none') {
          RealTimeFeedback.show();
          e.target.closest('#btnGroupFeedback').innerHTML = '<i class="fas fa-chart-line"></i> Masquer';
        } else {
          RealTimeFeedback.hide();
          e.target.closest('#btnGroupFeedback').innerHTML = '<i class="fas fa-chart-line"></i> Indicateurs';
        }
      }
    }
    
    // Bouton Statistiques des groupes
    if (e.target.closest('#btnGroupStats')) {
      const statsPanel = document.getElementById('statsPanel');
      if (statsPanel) {
        // Basculer l'affichage du panneau de statistiques
        if (statsPanel.classList.contains('translate-x-full')) {
          statsPanel.classList.remove('translate-x-full');
          
          // Initialiser le contenu seulement si pas encore fait
          const statsContent = document.getElementById('statsContent');
          if (!statsContent.innerHTML.trim()) {
            console.log('üìä Premi√®re ouverture - initialisation du contenu');
            if (typeof initCharts === 'function') {
              initCharts();
            }
          }
          
          // MISE √Ä JOUR INTELLIGENTE DES STATISTIQUES
          if (typeof updateStatsPanel === 'function') {
            updateStatsPanel();
          }
          
          // Changer le titre pour indiquer qu'on affiche les stats des groupes
          const title = statsPanel.querySelector('h2');
          if (title) {
            title.textContent = 'Statistiques des Groupes';
          }
        } else {
          statsPanel.classList.add('translate-x-full');
        }
      }
    }
  });
}

// ========== INITIALISATION AU CHARGEMENT ==========

// Ajouter au DOMContentLoaded
document.addEventListener('DOMContentLoaded', () => {
  // Initialiser le feedback en temps r√©el (mais ne pas l'afficher automatiquement)
  setTimeout(() => {
    if (RealTimeFeedback) {
      RealTimeFeedback.init();
    }
  }, 500);
  
  // Configurer les boutons avanc√©s dans le menu Actions apr√®s un d√©lai
  setTimeout(() => {
    configureAdvancedFeaturesButtons();
  }, 2000);
  
  // Configurer le bouton de fermeture du panneau des statistiques
  const closeStatsBtn = document.getElementById('closeStats');
  if (closeStatsBtn) {
    closeStatsBtn.addEventListener('click', () => {
      closeStatsPanel();
      // Mettre √† jour aria-expanded
      const btnStats = document.getElementById('btnStats');
      if (btnStats) btnStats.setAttribute('aria-expanded', 'false');
      console.log('üìä Panneau des statistiques ferm√© manuellement');
    });
  }

  // Sauvegarder l'√©tat initial
  setTimeout(() => {
    HistoryManager.saveState();
  }, 3000);
});

// Fonction pour initialiser les groupes apr√®s fermeture du modal
window.initializeGroupsAfterModal = function() {
  // Respecter le param√®tre global UI (SHOW_GROUPS_BUTTON)
  if (typeof google !== 'undefined' && google.script && google.script.run) {
    google.script.run
      .withSuccessHandler(function(settings) {
        if (settings && settings.SHOW_GROUPS_BUTTON) {
          addGroupsButton();
        } else {
          removeGroupsButton();
        }
        // Charger les groupes sauvegard√©s SANS les afficher
        if (window.GroupManager && GroupManager.loadGroups) {
          GroupManager.loadGroups();
          if (GroupManager.updateGroupsButton) {
            GroupManager.updateGroupsButton();
          }
        }
      })
      .withFailureHandler(function(err) {
        console.error('Erreur getUiSettings:', err);
        removeGroupsButton();
      })
      .getUiSettings();
  } else {
    // En mode local (pas de GAS), ne pas afficher par d√©faut
    removeGroupsButton();
  }
};

console.log('‚úÖ Module de groupes et am√©liorations V2 appliqu√©s');

// ========== PATCH CORRECTIF POUR STATISTIQUES FLUIDES ==========
// (ANCIENNE VERSION SUPPRIM√âE - REMPLAC√âE PAR LA VERSION PROT√âG√âE)

// ========== ADMIN > GROUPES - SUPPRIM√â ==========
// La fonction setupAdminGroupsToggle() a √©t√© COMPL√àTEMENT SUPPRIM√âE
// Elle contenait un listener legacy sur #btnAdmin qui cr√©ait des conflits
// Le menu Admin est g√©r√© UNIQUEMENT par AdminMenuFix (ligne 3070)
// Le toggle Groupes est maintenant dans le menu Admin principal

// Initialisation Admin Toggle d√©sactiv√©e (toggle d√©plac√© dans le menu Groupes)
// IMPORTANT: Le menu Admin est maintenant g√©r√© par AdminMenuFix uniquement

// 2. ANCIENNE VERSION DE updateAllColumnStats SUPPRIM√âE - REMPLAC√âE PAR LA VERSION PROPRE

// 3. SUPPRIM√â - Red√©finition probl√©matique de updateCharts
// La vraie fonction updateCharts est maintenant utilis√©e directement

// 4. Am√©liorer le feedback en temps r√©el avec throttle
if (window.RealTimeFeedback) {
  const originalUpdateMetrics = RealTimeFeedback.updateMetrics;
  let lastUpdate = 0;
  const THROTTLE_DELAY = 500; // Mise √† jour max toutes les 500ms
  
  RealTimeFeedback.updateMetrics = function() {
    const now = Date.now();
    if (now - lastUpdate < THROTTLE_DELAY) {
      return;
    }
    lastUpdate = now;
    
    if (originalUpdateMetrics) {
      originalUpdateMetrics.call(this);
    }
  };
}

// 5. ANCIENNE VERSION DE handleSortEnd SUPPRIM√âE - REMPLAC√âE PAR LA VERSION PROPRE

// 6. CSS pour animations fluides (√† ajouter dans une balise style)
const fluidStyles = document.createElement('style');
fluidStyles.textContent = `
  /* Animation fluide pour le panneau stats */
  #statsPanel {
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), 
                opacity 0.3s ease;
  }
  
  #statsPanel.updating {
    opacity: 0.95;
  }
  
  /* Transition fluide pour les graphiques */
  .chart-container {
    transition: opacity 0.2s ease;
  }
  
  .stats-panel.updating .chart-container {
    opacity: 0.8;
  }
  
  /* Emp√™cher le scintillement des m√©triques */
  .metric-value {
    transition: color 0.2s ease, transform 0.2s ease;
  }
  
  .metric-value.changed {
    transform: scale(1.05);
  }
  
  /* Animation subtile pour les mises √† jour */
  @keyframes gentlePulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.9; }
  }
  
  .stats-panel.updating {
    animation: gentlePulse 0.6s ease-in-out;
  }
`;
document.head.appendChild(fluidStyles);

// 7. Fonction utilitaire pour v√©rifier l'√©tat des graphiques
window.areChartsReady = function() {
  return window.chartCommunication && 
         window.chartDistribution && 
         window.chartLV2 && 
         window.chartOptions &&
         typeof window.chartCommunication.update === 'function';
};

// 8. Optimiser le rendu des cartes √©l√®ves
window.optimizeCardRendering = function() {
  // Utiliser requestAnimationFrame pour les mises √† jour visuelles
  const cards = document.querySelectorAll('.student-card');
  let index = 0;
  
  function processNextBatch() {
    const batchSize = 10;
    const batch = Array.from(cards).slice(index, index + batchSize);
    
    batch.forEach(card => {
      // Appliquer les optimisations de rendu
      card.style.willChange = 'transform';
      card.style.backfaceVisibility = 'hidden';
    });
    
    index += batchSize;
    
    if (index < cards.length) {
      requestAnimationFrame(processNextBatch);
    }
  }
  
  requestAnimationFrame(processNextBatch);
};

// 9. Nettoyer les fonctions dupliqu√©es au chargement
document.addEventListener('DOMContentLoaded', () => {
  // Supprimer les event listeners dupliqu√©s
  const processedElements = new Set();
  
  document.querySelectorAll('[id]').forEach(element => {
    if (processedElements.has(element.id)) {
      console.warn(`√âl√©ment dupliqu√© d√©tect√©: ${element.id}`);
      return;
    }
    processedElements.add(element.id);
  });
  
  // Attacher l'√©v√©nement au toggle flottant mode sombre
  const darkModeToggle = document.getElementById('darkModeToggle');
  if (darkModeToggle) {
    darkModeToggle.addEventListener('click', () => {
      toggleDarkMode();
    });
    console.log('‚úÖ Toggle mode sombre flottant attach√©');
  }
  
  // Optimiser le rendu initial
  setTimeout(optimizeCardRendering, 1000);
});

console.log('‚úÖ Patch de fluidit√© des statistiques appliqu√©');

// ========== CORRECTIONS FINALES SUPPL√âMENTAIRES ==========

// 1. Initialisation s√©curis√©e des variables globales manquantes
if (typeof window.chartLV2Details === 'undefined') {
  window.chartLV2Details = null;
}

// 2. Fonction utilitaire pour mise √† jour s√©curis√©e des graphiques
window.safeUpdateChart = function(chart) {
  if (chart && typeof chart.update === 'function') {
    try {
      chart.update('none'); // Mise √† jour sans animation pour plus de fluidit√©
    } catch (error) {
      console.warn('Erreur mise √† jour graphique:', error);
    }
  }
};

// 3. Syst√®me de gestion des event listeners pour √©viter les doublons
window.EventManager = {
  listeners: [],
  
  add: function(element, event, handler, options = {}) {
    // V√©rifier si le listener existe d√©j√†
    const existing = this.listeners.find(l => 
      l.element === element && l.event === event && l.handler === handler
    );
    
    if (!existing) {
      element.addEventListener(event, handler, options);
      this.listeners.push({element, event, handler, options});
    }
  },
  
  remove: function(element, event, handler) {
    element.removeEventListener(event, handler);
    this.listeners = this.listeners.filter(l => 
      !(l.element === element && l.event === event && l.handler === handler)
    );
  },
  
  clear: function() {
    this.listeners.forEach(({element, event, handler}) => {
      element.removeEventListener(event, handler);
    });
    this.listeners = [];
  }
};

// 4. Initialisation unique de l'application
window.addEventListener('DOMContentLoaded', () => {
  // √âviter les initialisations multiples
  if (window._initialized) {
    console.log('‚ö†Ô∏è Application d√©j√† initialis√©e, skip');
    return;
  }
  window._initialized = true;

  console.log('üöÄ Initialisation unique de l\'application (DOMContentLoaded #2)');

  // ‚ùå D√âSACTIV√â: EventManager.clear() peut supprimer les event listeners du modal !
  // if (window.EventManager) {
  //   window.EventManager.clear();
  // }
  console.log('‚ö†Ô∏è EventManager.clear() D√âSACTIV√â pour pr√©server les event listeners du modal');

  // Attendre que tout soit charg√©
  setTimeout(() => {
    if (typeof initRepartitionApp === 'function') {
      console.log('üöÄ Appel automatique de initRepartitionApp()');
      initRepartitionApp();
    }
  }, 100);
});

// 5. CSS pour transitions fluides (si pas d√©j√† pr√©sent)
if (!document.getElementById('fluid-animations-style')) {
  const style = document.createElement('style');
  style.id = 'fluid-animations-style';
  style.textContent = `
    .stats-panel {
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .student-card {
      transition: all 0.2s ease;
      will-change: transform;
    }
    
    .chart-container {
      transition: opacity 0.3s ease;
    }
    
    /* Am√©lioration des animations de drag & drop */
    .sortable-ghost {
      opacity: 0.5;
      transform: rotate(5deg);
    }
    
    .sortable-chosen {
      transform: scale(1.05);
      box-shadow: 0 10px 25px rgba(0,0,0,0.2);
    }
    
    /* Animation pour les mises √† jour de statistiques */
    .stats-updating {
      animation: gentlePulse 0.6s ease-in-out;
    }
    
    @keyframes gentlePulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.9; }
    }
  `;
  document.head.appendChild(style);
}

// ========== ANCIENNES VERSIONS SUPPRIM√âES - REMPLAC√âES PAR LA VERSION PROPRE ==========
// Toutes les anciennes versions de updateStatsPanel et les protections excessives ont √©t√© supprim√©es
// et remplac√©es par la version propre ajout√©e √† la fin du fichier
</script>
